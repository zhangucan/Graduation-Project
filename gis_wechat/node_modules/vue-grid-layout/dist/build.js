/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(16)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzP2E2OGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/NTU0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIHNjb3BlSWQsXG4gIGNzc01vZHVsZXNcbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIC8vIGluamVjdCBjc3NNb2R1bGVzXG4gIGlmIChjc3NNb2R1bGVzKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmNvbXB1dGVkIHx8IG51bGwpXG4gICAgT2JqZWN0LmtleXMoY3NzTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbW9kdWxlID0gY3NzTW9kdWxlc1trZXldXG4gICAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kdWxlIH1cbiAgICB9KVxuICAgIG9wdGlvbnMuY29tcHV0ZWQgPSBjb21wdXRlZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/*!\n * Vue.js v2.5.13\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value e.g. [object Object]\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm || {};\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode, deep) {\n  var componentOptions = vnode.componentOptions;\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.isCloned = true;\n  if (deep) {\n    if (vnode.children) {\n      cloned.children = cloneVNodes(vnode.children, true);\n    }\n    if (componentOptions && componentOptions.children) {\n      componentOptions.children = cloneVNodes(componentOptions.children, true);\n    }\n  }\n  return cloned\n}\n\nfunction cloneVNodes (vnodes, deep) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep);\n  }\n  return res\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'can only contain alphanumeric characters and the hyphen, ' +\n      'and must start with a letter.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false && isObject(value) && ('@binding' in value))\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', ')) +\n      \", got \" + (toRawType(value)) + \".\",\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while ((cur = cur.$parent)) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) { return }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n/* globals MessageChannel */\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both micro and macro tasks.\n// In < 2.4 we used micro tasks everywhere, but there are some scenarios where\n// micro tasks have too high a priority and fires in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using macro tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use micro task by default, but expose a way to force macro task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) Task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else if (typeof MessageChannel !== 'undefined' && (\n  isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\n)) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function () {\n    port.postMessage(1);\n  };\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine MicroTask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a Task instead of a MicroTask.\n */\nfunction withMacroTask (fn) {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true;\n    var res = fn.apply(null, arguments);\n    useMacroTask = false;\n    return res\n  })\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, def, cur, old, event;\n  for (name in on) {\n    def = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    /* istanbul ignore if */\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\n      })\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes) {\n      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {\n        warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n      }\n      slotNodes._rendered = true;\n    }\n    nodes = slotNodes || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias,\n  eventKeyName\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (keyCodes) {\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var options = Ctor.options;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () { return resolveSlots(children, parent); };\n\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm = Object.create(parent);\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = data.scopedSlots || emptyObject;\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    vnode.fnContext = contextVm;\n    vnode.fnOptions = options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n\n\n\n// Register the component hook to weex native render engine.\n// The hook will be triggered by native, not javascript.\n\n\n// Updates the state of the component to weex native render engine.\n\n/*  */\n\n// https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n// listening on native callback\n\n/*  */\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  // Weex specific: invoke recycle-list optimized @render function for\n  // extracting cell-slot template.\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n  /* istanbul ignore if */\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    _parentVnode: vnode,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // if the parent didn't update, the slot nodes will be the ones from\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\n      for (var key in vm.$slots) {\n        var slot = vm.$slots[key];\n        // _rendered is a flag added by renderSlot, but may not be present\n        // if the slot is passed from manually written render functions\n        if (slot._rendered || (slot[0] && slot[0].elm)) {\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n        }\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.5.13';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove () {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove.listeners = listeners;\n    return remove\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setAttribute(vnode.elm, i, '');\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value) {\n  el.attrsMap[name] = value;\n  el.attrsList.push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n  el.plain = false;\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (name === 'click') {\n    if (modifiers.right) {\n      name = 'contextmenu';\n      delete modifiers.right;\n    } else if (modifiers.middle) {\n      name = 'mouseup';\n    }\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = { value: value };\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat([$$v]))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  if (process.env.NODE_ENV !== 'production') {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    if (value$1) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally'\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler (handler, event, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  handler = withMacroTask(handler);\n  if (once$$1) { handler = createOnceHandler(handler, event, capture); }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    event,\n    handler._withTask || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.lazy) {\n      // inputs with lazy should only be updated when not in focus\n      return false\n    }\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def) {\n  if (!def) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def === 'object') {\n    var res = {};\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n    extend(res, def);\n    return res\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nVue$3.nextTick(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function closeElement (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        // element-scope stuff\n        processElement(element, options);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      closeElement(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var res;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (element, options) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = !element.key && !element.attrsList.length;\n\n  processRef(element);\n  processSlot(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n    }\n  }\n}\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '');\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget);\n      }\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true');\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\n/**\n * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {\n      var typeBinding = getBindingAttr(el, 'type');\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$2 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$2\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    /* istanbul ignore if */\n    return (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    /* istanbul ignore if */\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var code = keyCodes[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(code)) + \",\" +\n    \"$event.key)\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  var fn = \"function(\" + (String(el.slotScope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if\n        ? ((el.if) + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  return (\"{key:\" + key + \",fn:\" + fn + \"}\")\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    /* istanbul ignore if */\n    {\n      res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n    }\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  errors\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n    }\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim())\n      );\n    } else {\n      errors.push(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\"\n      );\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn$$1(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(5), __webpack_require__(11).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcz8yMzcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxr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QUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTLHFCQUFxQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFB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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQixFQUFFO0FBQ3JFLEtBQUs7QUFDTDtBQUNBLHdDQUF3Qyw0QkFBNEIsRUFBRTtBQUN0RTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QixFQUFFO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQixFQUFFO0FBQzlFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxxQ0FBcUM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUNBQXVDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJDQUEyQyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw4QkFBOEIsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx1Q0FBdUMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQSx1REFBdUQsNkRBQTZEO0FBQ3BILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCLEVBQUU7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjUuMTNcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJ1xuXTtcblxuLyogICovXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtIHx8IHt9O1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSwgZGVlcCkge1xuICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIGlmIChkZWVwKSB7XG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICBjbG9uZWQuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyh2bm9kZS5jaGlsZHJlbiwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPcHRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyhjb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSwgZGVlcCk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNybyBhbmQgbWFjcm8gdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvIHRhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZXMgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvIHRhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSBtYWNybyB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgTWljcm9UYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSBUYXNrIGluc3RlYWQgb2YgYSBNaWNyb1Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IChwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIHZub2RlLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICAvLyBfcmVuZGVyZWQgaXMgYSBmbGFnIGFkZGVkIGJ5IHJlbmRlclNsb3QsIGJ1dCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgLy8gaWYgdGhlIHNsb3QgaXMgcGFzc2VkIGZyb20gbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGUsIGtleSwgdGhpcyQxLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjUuMTMnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUgfTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoWyQkdl0pKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgaWYgKHZhbHVlJDEpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxhenkpIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIGxhenkgc2hvdWxkIG9ubHkgYmUgdXBkYXRlZCB3aGVuIG5vdCBpbiBmb2N1c1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZikge1xuICBpZiAoIWRlZikge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50IGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WdWUkMy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJyk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90U2NvcGU7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5YW5taWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKG1hcFsndi1tb2RlbCddICYmIChtYXBbJ3YtYmluZDp0eXBlJ10gfHwgbWFwWyc6dHlwZSddKSkge1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDJcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBjb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXkpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmXG4gICAgICAgID8gKChlbC5pZikgKyBcIj9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICBlcnJvcnNcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlJDM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(18)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(20),\n  /* template */\n  __webpack_require__(23),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZEl0ZW0udnVlP2RlNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQW1NOztBQUVuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP21pbmltaXplIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWYyZWY5Y2QyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9HcmlkSXRlbS52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vR3JpZEl0ZW0udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1mMmVmOWNkMlxcXCJ9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9HcmlkSXRlbS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0dyaWRJdGVtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTransformRtl = setTransformRtl;\nexports.setTopLeft = setTopLeft;\nexports.setTopRight = setTopRight;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.validateLayout = validateLayout;\nexports.autoBindHandlers = autoBindHandlers;\nexports.createMarkup = createMarkup;\nexports.addPx = addPx;\nexports.hyphenate = hyphenate;\nexports.findItemInArray = findItemInArray;\nexports.findAndRemove = findAndRemove;\n// @flow\n/*:: export type LayoutItemRequired = {w: number, h: number, x: number, y: number, i: string};*/\n/*:: export type LayoutItem = LayoutItemRequired &\r\n                         {minW?: number, minH?: number, maxW?: number, maxH?: number,\r\n                          moved?: boolean, static?: boolean,\r\n                          isDraggable?: ?boolean, isResizable?: ?boolean};*/\n/*:: export type Layout = Array<LayoutItem>;*/\n/*:: export type Position = {left: number, top: number, width: number, height: number};*/\n/*:: export type DragCallbackData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number\r\n};*/\n/*:: export type DragEvent = {e: Event} & DragCallbackData;*/\n/*:: export type Size = {width: number, height: number};*/\n/*:: export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};*/\n\n\nvar isProduction = process.env.NODE_ENV === 'production';\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\nfunction bottom(layout /*: Layout*/) /*: number*/ {\n  var max = 0,\n      bottomY = void 0;\n  for (var _i = 0, len = layout.length; _i < len; _i++) {\n    bottomY = layout[_i].y + layout[_i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\n\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/ {\n  var newLayout = Array(layout.length);\n  for (var _i2 = 0, len = layout.length; _i2 < len; _i2++) {\n    newLayout[_i2] = cloneLayoutItem(layout[_i2]);\n  }\n  return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/ {\n  /*return {\r\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\r\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\r\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\r\n    // These can be null\r\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\r\n  };*/\n  return JSON.parse(JSON.stringify(layoutItem));\n}\n\n/**\r\n * Given two layoutitems, check if they collide.\r\n *\r\n * @return {Boolean}   True if colliding.\r\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/ {\n  if (l1 === l2) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\nfunction compact(layout /*: Layout*/, verticalCompact /*: Boolean*/) /*: Layout*/ {\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  var sorted = sortLayoutItemsByRowCol(layout);\n  // Holding for new items.\n  var out = Array(layout.length);\n\n  for (var _i3 = 0, len = sorted.length; _i3 < len; _i3++) {\n    var l = sorted[_i3];\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(l)] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n\n  return out;\n}\n\n/**\r\n * Compact an item in the layout.\r\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, verticalCompact /*: boolean*/) /*: LayoutItem*/ {\n  if (verticalCompact) {\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  var collides = void 0;\n  while (collides = getFirstCollision(compareWith, l)) {\n    l.y = collides.y + collides.h;\n  }\n  return l;\n}\n\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: {cols: number}*/) /*: Layout*/ {\n  var collidesWith = getStatics(layout);\n  for (var _i4 = 0, len = layout.length; _i4 < len; _i4++) {\n    var l = layout[_i4];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/ {\n  for (var _i5 = 0, len = layout.length; _i5 < len; _i5++) {\n    if (layout[_i5].i === id) return layout[_i5];\n  }\n}\n\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/ {\n  for (var _i6 = 0, len = layout.length; _i6 < len; _i6++) {\n    if (collides(layout[_i6], layoutItem)) return layout[_i6];\n  }\n}\n\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/ {\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/ {\n  //return [];\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout Full layout to modify.\r\n * @param  {LayoutItem} l      element to move.\r\n * @param  {Number}     [x]    X position in grid units.\r\n * @param  {Number}     [y]    Y position in grid units.\r\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\r\n *                                     being dragged/resized by th euser.\r\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: Number*/, y /*: Number*/, isUserAction /*: Boolean*/) /*: Layout*/ {\n  if (l.static) return layout;\n\n  // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  var movingUp = y && l.y > y;\n  // This is quite a bit faster than extending the object\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  var sorted = sortLayoutItemsByRowCol(layout);\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n\n  // Move each item that collides away from this element.\n  for (var _i7 = 0, len = collisions.length; _i7 < len; _i7++) {\n    var collision = collisions[_i7];\n    // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\n    }\n  }\n\n  return layout;\n}\n\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\r\n *                                   by the user.\r\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/) /*: Layout*/ {\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    var fakeItem /*: LayoutItem*/ = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: '-1'\n    };\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(layout, itemToMove, undefined, fakeItem.y);\n    }\n  }\n\n  // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1);\n}\n\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\nfunction perc(num /*: number*/) /*: string*/ {\n  return num * 100 + '%';\n}\n\nfunction setTransform(top, left, width, height) /*: Object*/ {\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTransform method, but instead it will return a negative value of right.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\r\n */\nfunction setTransformRtl(top, right, width, height) /*: Object*/ {\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n\nfunction setTopLeft(top, left, width, height) /*: Object*/ {\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\r\n */\nfunction setTopRight(top, right, width, height) /*: Object*/ {\n  return {\n    top: top + \"px\",\n    right: right + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/ {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\r\n * Generate a layout using the initialLayout and children as a template.\r\n * Missing entries will be added, extraneous ones will be truncated.\r\n *\r\n * @param  {Array}  initialLayout Layout passed in through props.\r\n * @param  {String} breakpoint    Current responsive breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\r\n * @return {Array}                Working layout.\r\n */\n/*\r\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\r\n                                              cols: number, verticalCompact: boolean): Layout {\r\n  // ensure 'children' is always an array\r\n  if (!Array.isArray(children)) {\r\n    children = [children];\r\n  }\r\n  initialLayout = initialLayout || [];\r\n\r\n  // Generate one layout item per child.\r\n  let layout: Layout = [];\r\n  for (let i = 0, len = children.length; i < len; i++) {\r\n    let newItem;\r\n    const child = children[i];\r\n\r\n    // Don't overwrite if it already exists.\r\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\r\n    if (exists) {\r\n      newItem = exists;\r\n    } else {\r\n      const g = child.props._grid;\r\n\r\n      // Hey, this item has a _grid property, use it.\r\n      if (g) {\r\n        if (!isProduction) {\r\n          validateLayout([g], 'ReactGridLayout.children');\r\n        }\r\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        if (verticalCompact) {\r\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\r\n        } else {\r\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\r\n        }\r\n      }\r\n      // Nothing provided: ensure this is added to the bottom\r\n      else {\r\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\r\n      }\r\n    }\r\n    layout[i] = newItem;\r\n  }\r\n\r\n  // Correct the layout.\r\n  layout = correctBounds(layout, {cols: cols});\r\n  layout = compact(layout, verticalCompact);\r\n\r\n  return layout;\r\n}\r\n*/\n\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\nfunction validateLayout(layout /*: Layout*/, contextName /*: string*/) /*: void*/ {\n  contextName = contextName || \"Layout\";\n  var subProps = ['x', 'y', 'w', 'h'];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (var _i8 = 0, len = layout.length; _i8 < len; _i8++) {\n    var item = layout[_i8];\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('VueGridLayout: ' + contextName + '[' + _i8 + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n    if (item.i && typeof item.i !== 'string') {\n      throw new Error('VueGridLayout: ' + contextName + '[' + _i8 + '].i must be a string!');\n    }\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('VueGridLayout: ' + contextName + '[' + _i8 + '].static must be a boolean!');\n    }\n  }\n}\n\n// Flow can't really figure this out, so we just use Object\nfunction autoBindHandlers(el /*: Object*/, fns /*: Array<string>*/) /*: void*/ {\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n\n/**\r\n * Convert a JS object to CSS string. Similar to React's output of CSS.\r\n * @param obj\r\n * @returns {string}\r\n */\nfunction createMarkup(obj) {\n  var keys = Object.keys(obj);\n  if (!keys.length) return '';\n  var i,\n      len = keys.length;\n  var result = '';\n\n  for (i = 0; i < len; i++) {\n    var key = keys[i];\n    var val = obj[key];\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\n  }\n\n  return result;\n}\n\n/* The following list is defined in React's core */\nvar IS_UNITLESS = exports.IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\r\n * Will add px to the end of style values which are Numbers.\r\n * @param name\r\n * @param value\r\n * @returns {*}\r\n */\nfunction addPx(name, value) {\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n}\n\n/**\r\n * Hyphenate a camelCase string.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\n\nvar hyphenateRE = exports.hyphenateRE = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\n\nfunction findItemInArray(array, property, value) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i][property] == value) return true;\n  }return false;\n}\n\nfunction findAndRemove(array, property, value) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1);\n    }\n  });\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MmZmOCJdLCJuYW1lcyI6WyJib3R0b20iLCJjbG9uZUxheW91dCIsImNsb25lTGF5b3V0SXRlbSIsImNvbGxpZGVzIiwiY29tcGFjdCIsImNvbXBhY3RJdGVtIiwiY29ycmVjdEJvdW5kcyIsImdldExheW91dEl0ZW0iLCJnZXRGaXJzdENvbGxpc2lvbiIsImdldEFsbENvbGxpc2lvbnMiLCJnZXRTdGF0aWNzIiwibW92ZUVsZW1lbnQiLCJtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uIiwicGVyYyIsInNldFRyYW5zZm9ybSIsInNldFRyYW5zZm9ybVJ0bCIsInNldFRvcExlZnQiLCJzZXRUb3BSaWdodCIsInNvcnRMYXlvdXRJdGVtc0J5Um93Q29sIiwidmFsaWRhdGVMYXlvdXQiLCJhdXRvQmluZEhhbmRsZXJzIiwiY3JlYXRlTWFya3VwIiwiYWRkUHgiLCJoeXBoZW5hdGUiLCJmaW5kSXRlbUluQXJyYXkiLCJmaW5kQW5kUmVtb3ZlIiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibGF5b3V0IiwibWF4IiwiYm90dG9tWSIsImkiLCJsZW4iLCJsZW5ndGgiLCJ5IiwiaCIsIm5ld0xheW91dCIsIkFycmF5IiwibGF5b3V0SXRlbSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImwxIiwibDIiLCJ4IiwidyIsInZlcnRpY2FsQ29tcGFjdCIsImNvbXBhcmVXaXRoIiwic29ydGVkIiwib3V0IiwibCIsInN0YXRpYyIsInB1c2giLCJpbmRleE9mIiwibW92ZWQiLCJib3VuZHMiLCJjb2xsaWRlc1dpdGgiLCJjb2xzIiwiaWQiLCJmaWx0ZXIiLCJpc1VzZXJBY3Rpb24iLCJtb3ZpbmdVcCIsInJldmVyc2UiLCJjb2xsaXNpb25zIiwiY29sbGlzaW9uIiwiaXRlbVRvTW92ZSIsImZha2VJdGVtIiwiTWF0aCIsInVuZGVmaW5lZCIsIm51bSIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInRyYW5zbGF0ZSIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsIk1velRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiT1RyYW5zZm9ybSIsInBvc2l0aW9uIiwicmlnaHQiLCJjb25jYXQiLCJzb3J0IiwiYSIsImIiLCJjb250ZXh0TmFtZSIsInN1YlByb3BzIiwiaXNBcnJheSIsIkVycm9yIiwiaXRlbSIsImoiLCJlbCIsImZucyIsImZvckVhY2giLCJrZXkiLCJiaW5kIiwib2JqIiwia2V5cyIsIk9iamVjdCIsInJlc3VsdCIsInZhbCIsIklTX1VOSVRMRVNTIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRDb2x1bW4iLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwibmFtZSIsInZhbHVlIiwiaHlwaGVuYXRlUkUiLCJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsInByb3BlcnR5IiwiaW5kZXgiLCJzcGxpY2UiXSwibWFwcGluZ3MiOiI7Ozs7O1FBeUJnQkEsTSxHQUFBQSxNO1FBU0FDLFcsR0FBQUEsVztRQVNBQyxlLEdBQUFBLGU7UUFnQkFDLFEsR0FBQUEsUTtRQWtCQUMsTyxHQUFBQSxPO1FBaUNBQyxXLEdBQUFBLFc7UUFzQkFDLGEsR0FBQUEsYTtRQThCQUMsYSxHQUFBQSxhO1FBY0FDLGlCLEdBQUFBLGlC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QXhDLEVBQStDO0FBQ2xESyxRQUFNM0MsT0FBTixDQUFjLFVBQVVNLE1BQVYsRUFBa0J1QyxLQUFsQixFQUF5QjtBQUNuQyxRQUFJdkMsT0FBT3NDLFFBQVAsTUFBcUJOLEtBQXpCLEVBQWdDO0FBQzVCO0FBQ0FLLFlBQU1HLE1BQU4sQ0FBYUQsS0FBYixFQUFvQixDQUFwQjtBQUNIO0FBQ0osR0FMRDtBQU1ILEMiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcbmV4cG9ydCB0eXBlIExheW91dEl0ZW1SZXF1aXJlZCA9IHt3OiBudW1iZXIsIGg6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGk6IHN0cmluZ307XHJcbmV4cG9ydCB0eXBlIExheW91dEl0ZW0gPSBMYXlvdXRJdGVtUmVxdWlyZWQgJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAge21pblc/OiBudW1iZXIsIG1pbkg/OiBudW1iZXIsIG1heFc/OiBudW1iZXIsIG1heEg/OiBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQ/OiBib29sZWFuLCBzdGF0aWM/OiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dhYmxlPzogP2Jvb2xlYW4sIGlzUmVzaXphYmxlPzogP2Jvb2xlYW59O1xyXG5leHBvcnQgdHlwZSBMYXlvdXQgPSBBcnJheTxMYXlvdXRJdGVtPjtcclxuZXhwb3J0IHR5cGUgUG9zaXRpb24gPSB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9O1xyXG5leHBvcnQgdHlwZSBEcmFnQ2FsbGJhY2tEYXRhID0ge1xyXG4gIG5vZGU6IEhUTUxFbGVtZW50LFxyXG4gIHg6IG51bWJlciwgeTogbnVtYmVyLFxyXG4gIGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcixcclxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyXHJcbn07XHJcbmV4cG9ydCB0eXBlIERyYWdFdmVudCA9IHtlOiBFdmVudH0gJiBEcmFnQ2FsbGJhY2tEYXRhO1xyXG5leHBvcnQgdHlwZSBTaXplID0ge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfTtcclxuZXhwb3J0IHR5cGUgUmVzaXplRXZlbnQgPSB7ZTogRXZlbnQsIG5vZGU6IEhUTUxFbGVtZW50LCBzaXplOiBTaXplfTtcclxuXHJcbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGJvdHRvbSBjb29yZGluYXRlIG9mIHRoZSBsYXlvdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIEJvdHRvbSBjb29yZGluYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJvdHRvbShsYXlvdXQ6IExheW91dCk6IG51bWJlciB7XHJcbiAgbGV0IG1heCA9IDAsIGJvdHRvbVk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgYm90dG9tWSA9IGxheW91dFtpXS4geSArIGxheW91dFtpXS5oO1xyXG4gICAgaWYgKGJvdHRvbVkgPiBtYXgpIG1heCA9IGJvdHRvbVk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXg7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUxheW91dChsYXlvdXQ6IExheW91dCk6IExheW91dCB7XHJcbiAgY29uc3QgbmV3TGF5b3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgbmV3TGF5b3V0W2ldID0gY2xvbmVMYXlvdXRJdGVtKGxheW91dFtpXSk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdMYXlvdXQ7XHJcbn1cclxuXHJcbi8vIEZhc3QgcGF0aCB0byBjbG9uaW5nLCBzaW5jZSB0aGlzIGlzIG1vbm9tb3JwaGljXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUxheW91dEl0ZW0obGF5b3V0SXRlbTogTGF5b3V0SXRlbSk6IExheW91dEl0ZW0ge1xyXG4gIC8qcmV0dXJuIHtcclxuICAgIHc6IGxheW91dEl0ZW0udywgaDogbGF5b3V0SXRlbS5oLCB4OiBsYXlvdXRJdGVtLngsIHk6IGxheW91dEl0ZW0ueSwgaTogbGF5b3V0SXRlbS5pLFxyXG4gICAgbWluVzogbGF5b3V0SXRlbS5taW5XLCBtYXhXOiBsYXlvdXRJdGVtLm1heFcsIG1pbkg6IGxheW91dEl0ZW0ubWluSCwgbWF4SDogbGF5b3V0SXRlbS5tYXhILFxyXG4gICAgbW92ZWQ6IEJvb2xlYW4obGF5b3V0SXRlbS5tb3ZlZCksIHN0YXRpYzogQm9vbGVhbihsYXlvdXRJdGVtLnN0YXRpYyksXHJcbiAgICAvLyBUaGVzZSBjYW4gYmUgbnVsbFxyXG4gICAgaXNEcmFnZ2FibGU6IGxheW91dEl0ZW0uaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlOiBsYXlvdXRJdGVtLmlzUmVzaXphYmxlXHJcbiAgfTsqL1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGF5b3V0SXRlbSkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIGxheW91dGl0ZW1zLCBjaGVjayBpZiB0aGV5IGNvbGxpZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgVHJ1ZSBpZiBjb2xsaWRpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29sbGlkZXMobDE6IExheW91dEl0ZW0sIGwyOiBMYXlvdXRJdGVtKTogYm9vbGVhbiB7XHJcbiAgaWYgKGwxID09PSBsMikgcmV0dXJuIGZhbHNlOyAvLyBzYW1lIGVsZW1lbnRcclxuICBpZiAobDEueCArIGwxLncgPD0gbDIueCkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBsZWZ0IG9mIGwyXHJcbiAgaWYgKGwxLnggPj0gbDIueCArIGwyLncpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgcmlnaHQgb2YgbDJcclxuICBpZiAobDEueSArIGwxLmggPD0gbDIueSkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBhYm92ZSBsMlxyXG4gIGlmIChsMS55ID49IGwyLnkgKyBsMi5oKSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGJlbG93IGwyXHJcbiAgcmV0dXJuIHRydWU7IC8vIGJveGVzIG92ZXJsYXBcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBjb21wYWN0IGl0LiBUaGlzIGludm9sdmVzIGdvaW5nIGRvd24gZWFjaCB5IGNvb3JkaW5hdGUgYW5kIHJlbW92aW5nIGdhcHNcclxuICogYmV0d2VlbiBpdGVtcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQuXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcclxuICogICB2ZXJ0aWNhbGx5LlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0KGxheW91dDogTGF5b3V0LCB2ZXJ0aWNhbENvbXBhY3Q6IEJvb2xlYW4pOiBMYXlvdXQge1xyXG4gICAgLy8gU3RhdGljcyBnbyBpbiB0aGUgY29tcGFyZVdpdGggYXJyYXkgcmlnaHQgYXdheSBzbyBpdGVtcyBmbG93IGFyb3VuZCB0aGVtLlxyXG4gIGNvbnN0IGNvbXBhcmVXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xyXG4gIC8vIFdlIGdvIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IHJvdyBhbmQgY29sdW1uLlxyXG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dCk7XHJcbiAgLy8gSG9sZGluZyBmb3IgbmV3IGl0ZW1zLlxyXG4gIGNvbnN0IG91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc29ydGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBsZXQgbCA9IHNvcnRlZFtpXTtcclxuXHJcbiAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBlbGVtZW50c1xyXG4gICAgaWYgKCFsLnN0YXRpYykge1xyXG4gICAgICBsID0gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGgsIGwsIHZlcnRpY2FsQ29tcGFjdCk7XHJcblxyXG4gICAgICAvLyBBZGQgdG8gY29tcGFyaXNvbiBhcnJheS4gV2Ugb25seSBjb2xsaWRlIHdpdGggaXRlbXMgYmVmb3JlIHRoaXMgb25lLlxyXG4gICAgICAvLyBTdGF0aWNzIGFyZSBhbHJlYWR5IGluIHRoaXMgYXJyYXkuXHJcbiAgICAgIGNvbXBhcmVXaXRoLnB1c2gobCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRvIG91dHB1dCBhcnJheSB0byBtYWtlIHN1cmUgdGhleSBzdGlsbCBjb21lIG91dCBpbiB0aGUgcmlnaHQgb3JkZXIuXHJcbiAgICBvdXRbbGF5b3V0LmluZGV4T2YobCldID0gbDtcclxuXHJcbiAgICAvLyBDbGVhciBtb3ZlZCBmbGFnLCBpZiBpdCBleGlzdHMuXHJcbiAgICBsLm1vdmVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcGFjdCBhbiBpdGVtIGluIHRoZSBsYXlvdXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGg6IExheW91dCwgbDogTGF5b3V0SXRlbSwgdmVydGljYWxDb21wYWN0OiBib29sZWFuKTogTGF5b3V0SXRlbSB7XHJcbiAgaWYgKHZlcnRpY2FsQ29tcGFjdCkge1xyXG4gICAgLy8gTW92ZSB0aGUgZWxlbWVudCB1cCBhcyBmYXIgYXMgaXQgY2FuIGdvIHdpdGhvdXQgY29sbGlkaW5nLlxyXG4gICAgd2hpbGUgKGwueSA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xyXG4gICAgICBsLnktLTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE1vdmUgaXQgZG93biwgYW5kIGtlZXAgbW92aW5nIGl0IGRvd24gaWYgaXQncyBjb2xsaWRpbmcuXHJcbiAgbGV0IGNvbGxpZGVzO1xyXG4gIHdoaWxlKChjb2xsaWRlcyA9IGdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkpIHtcclxuICAgIGwueSA9IGNvbGxpZGVzLnkgKyBjb2xsaWRlcy5oO1xyXG4gIH1cclxuICByZXR1cm4gbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGZpdCB3aXRoaW4gaXRzIGJvdW5kcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYm91bmRzIE51bWJlciBvZiBjb2x1bW5zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcnJlY3RCb3VuZHMobGF5b3V0OiBMYXlvdXQsIGJvdW5kczoge2NvbHM6IG51bWJlcn0pOiBMYXlvdXQge1xyXG4gIGNvbnN0IGNvbGxpZGVzV2l0aCA9IGdldFN0YXRpY3MobGF5b3V0KTtcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBjb25zdCBsID0gbGF5b3V0W2ldO1xyXG4gICAgLy8gT3ZlcmZsb3dzIHJpZ2h0XHJcbiAgICBpZiAobC54ICsgbC53ID4gYm91bmRzLmNvbHMpIGwueCA9IGJvdW5kcy5jb2xzIC0gbC53O1xyXG4gICAgLy8gT3ZlcmZsb3dzIGxlZnRcclxuICAgIGlmIChsLnggPCAwKSB7XHJcbiAgICAgIGwueCA9IDA7XHJcbiAgICAgIGwudyA9IGJvdW5kcy5jb2xzO1xyXG4gICAgfVxyXG4gICAgaWYgKCFsLnN0YXRpYykgY29sbGlkZXNXaXRoLnB1c2gobCk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIGNvbGxpZGVzIHdpdGggb3RoZXIgc3RhdGljcywgd2UgbXVzdCBtb3ZlIGl0IGRvd24uXHJcbiAgICAgIC8vIFdlIGhhdmUgdG8gZG8gc29tZXRoaW5nIG5pY2VyIHRoYW4ganVzdCBsZXR0aW5nIHRoZW0gb3ZlcmxhcC5cclxuICAgICAgd2hpbGUoZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlkZXNXaXRoLCBsKSkge1xyXG4gICAgICAgIGwueSsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsYXlvdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBsYXlvdXQgaXRlbSBieSBJRC4gVXNlZCBzbyB3ZSBjYW4gb3ZlcnJpZGUgbGF0ZXIgb24gaWYgbmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxheW91dCBMYXlvdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgIElEXHJcbiAqIEByZXR1cm4ge0xheW91dEl0ZW19ICAgIEl0ZW0gYXQgSUQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF5b3V0SXRlbShsYXlvdXQ6IExheW91dCwgaWQ6IHN0cmluZyk6ID9MYXlvdXRJdGVtIHtcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAobGF5b3V0W2ldLmkgPT09IGlkKSByZXR1cm4gbGF5b3V0W2ldO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhpcyBsYXlvdXQgY29sbGlkZXMgd2l0aC5cclxuICogSXQgZG9lc24ndCBhcHBlYXIgdG8gbWF0dGVyIHdoaWNoIG9yZGVyIHdlIGFwcHJvYWNoIHRoaXMgZnJvbSwgYWx0aG91Z2hcclxuICogcGVyaGFwcyB0aGF0IGlzIHRoZSB3cm9uZyB0aGluZyB0byBkby5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBsYXlvdXRJdGVtIExheW91dCBpdGVtLlxyXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAgQSBjb2xsaWRpbmcgbGF5b3V0IGl0ZW0sIG9yIHVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihsYXlvdXQ6IExheW91dCwgbGF5b3V0SXRlbTogTGF5b3V0SXRlbSk6ID9MYXlvdXRJdGVtIHtcclxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAoY29sbGlkZXMobGF5b3V0W2ldLCBsYXlvdXRJdGVtKSkgcmV0dXJuIGxheW91dFtpXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb2xsaXNpb25zKGxheW91dDogTGF5b3V0LCBsYXlvdXRJdGVtOiBMYXlvdXRJdGVtKTogQXJyYXk8TGF5b3V0SXRlbT4ge1xyXG4gIHJldHVybiBsYXlvdXQuZmlsdGVyKChsKSA9PiBjb2xsaWRlcyhsLCBsYXlvdXRJdGVtKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYWxsIHN0YXRpYyBlbGVtZW50cy5cclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBBcnJheSBvZiBzdGF0aWMgbGF5b3V0IGl0ZW1zLi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNzKGxheW91dDogTGF5b3V0KTogQXJyYXk8TGF5b3V0SXRlbT4ge1xyXG4gICAgLy9yZXR1cm4gW107XHJcbiAgICByZXR1cm4gbGF5b3V0LmZpbHRlcigobCkgPT4gbC5zdGF0aWMpO1xyXG59XHJcblxyXG4vKipcclxuICogTW92ZSBhbiBlbGVtZW50LiBSZXNwb25zaWJsZSBmb3IgZG9pbmcgY2FzY2FkaW5nIG1vdmVtZW50cyBvZiBvdGhlciBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGF5b3V0IEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cclxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gbCAgICAgIGVsZW1lbnQgdG8gbW92ZS5cclxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3hdICAgIFggcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cclxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3ldICAgIFkgcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cclxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgW2lzVXNlckFjdGlvbl0gSWYgdHJ1ZSwgZGVzaWduYXRlcyB0aGF0IHRoZSBpdGVtIHdlJ3JlIG1vdmluZyBpc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWluZyBkcmFnZ2VkL3Jlc2l6ZWQgYnkgdGggZXVzZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbW92ZUVsZW1lbnQobGF5b3V0OiBMYXlvdXQsIGw6IExheW91dEl0ZW0sIHg6IE51bWJlciwgeTogTnVtYmVyLCBpc1VzZXJBY3Rpb246IEJvb2xlYW4pOiBMYXlvdXQge1xyXG4gIGlmIChsLnN0YXRpYykgcmV0dXJuIGxheW91dDtcclxuXHJcbiAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3RoaW5nIHRvIGRvLlxyXG4gIC8vaWYgKGwueSA9PT0geSAmJiBsLnggPT09IHgpIHJldHVybiBsYXlvdXQ7XHJcblxyXG4gIGNvbnN0IG1vdmluZ1VwID0geSAmJiBsLnkgPiB5O1xyXG4gIC8vIFRoaXMgaXMgcXVpdGUgYSBiaXQgZmFzdGVyIHRoYW4gZXh0ZW5kaW5nIHRoZSBvYmplY3RcclxuICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSBsLnggPSB4O1xyXG4gIGlmICh0eXBlb2YgeSA9PT0gJ251bWJlcicpIGwueSA9IHk7XHJcbiAgbC5tb3ZlZCA9IHRydWU7XHJcblxyXG4gIC8vIElmIHRoaXMgY29sbGlkZXMgd2l0aCBhbnl0aGluZywgbW92ZSBpdC5cclxuICAvLyBXaGVuIGRvaW5nIHRoaXMgY29tcGFyaXNvbiwgd2UgaGF2ZSB0byBzb3J0IHRoZSBpdGVtcyB3ZSBjb21wYXJlIHdpdGhcclxuICAvLyB0byBlbnN1cmUsIGluIHRoZSBjYXNlIG9mIG11bHRpcGxlIGNvbGxpc2lvbnMsIHRoYXQgd2UncmUgZ2V0dGluZyB0aGVcclxuICAvLyBuZWFyZXN0IGNvbGxpc2lvbi5cclxuICBsZXQgc29ydGVkID0gc29ydExheW91dEl0ZW1zQnlSb3dDb2wobGF5b3V0KTtcclxuICBpZiAobW92aW5nVXApIHNvcnRlZCA9IHNvcnRlZC5yZXZlcnNlKCk7XHJcbiAgY29uc3QgY29sbGlzaW9ucyA9IGdldEFsbENvbGxpc2lvbnMoc29ydGVkLCBsKTtcclxuXHJcbiAgLy8gTW92ZSBlYWNoIGl0ZW0gdGhhdCBjb2xsaWRlcyBhd2F5IGZyb20gdGhpcyBlbGVtZW50LlxyXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xyXG4gICAgLy8gY29uc29sZS5sb2coJ3Jlc29sdmluZyBjb2xsaXNpb24gYmV0d2VlbicsIGwuaSwgJ2F0JywgbC55LCAnYW5kJywgY29sbGlzaW9uLmksICdhdCcsIGNvbGxpc2lvbi55KTtcclxuXHJcbiAgICAvLyBTaG9ydCBjaXJjdWl0IHNvIHdlIGNhbid0IGluZmluaXRlIGxvb3BcclxuICAgIGlmIChjb2xsaXNpb24ubW92ZWQpIGNvbnRpbnVlO1xyXG5cclxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZmVlbCBhIGJpdCBtb3JlIHByZWNpc2UgYnkgd2FpdGluZyB0byBzd2FwIGZvciBqdXN0IGEgYml0IHdoZW4gbW92aW5nIHVwLlxyXG4gICAgaWYgKGwueSA+IGNvbGxpc2lvbi55ICYmIGwueSAtIGNvbGxpc2lvbi55ID4gY29sbGlzaW9uLmggLyA0KSBjb250aW51ZTtcclxuXHJcbiAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBpdGVtcyAtIHdlIGhhdmUgdG8gbW92ZSAqdGhpcyogZWxlbWVudCBhd2F5XHJcbiAgICBpZiAoY29sbGlzaW9uLnN0YXRpYykge1xyXG4gICAgICBsYXlvdXQgPSBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dCwgY29sbGlzaW9uLCBsLCBpc1VzZXJBY3Rpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQsIGwsIGNvbGxpc2lvbiwgaXNVc2VyQWN0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBsYXlvdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHdoZXJlIHRoZSBtYWdpYyBuZWVkcyB0byBoYXBwZW4gLSBnaXZlbiBhIGNvbGxpc2lvbiwgbW92ZSBhbiBlbGVtZW50IGF3YXkgZnJvbSB0aGUgY29sbGlzaW9uLlxyXG4gKiBXZSBhdHRlbXB0IHRvIG1vdmUgaXQgdXAgaWYgdGhlcmUncyByb29tLCBvdGhlcndpc2UgaXQgZ29lcyBiZWxvdy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cclxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gY29sbGlkZXNXaXRoIExheW91dCBpdGVtIHdlJ3JlIGNvbGxpZGluZyB3aXRoLlxyXG4gKiBAcGFyYW0gIHtMYXlvdXRJdGVtfSBpdGVtVG9Nb3ZlICAgTGF5b3V0IGl0ZW0gd2UncmUgbW92aW5nLlxyXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbaXNVc2VyQWN0aW9uXSAgSWYgdHJ1ZSwgZGVzaWduYXRlcyB0aGF0IHRoZSBpdGVtIHdlJ3JlIG1vdmluZyBpcyBiZWluZyBkcmFnZ2VkL3Jlc2l6ZWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSB1c2VyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0OiBMYXlvdXQsIGNvbGxpZGVzV2l0aDogTGF5b3V0SXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvTW92ZTogTGF5b3V0SXRlbSwgaXNVc2VyQWN0aW9uOiA/Ym9vbGVhbik6IExheW91dCB7XHJcblxyXG4gIC8vIElmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBhYm92ZSB0aGUgY29sbGlzaW9uIHRvIHB1dCB0aGlzIGVsZW1lbnQsIG1vdmUgaXQgdGhlcmUuXHJcbiAgLy8gV2Ugb25seSBkbyB0aGlzIG9uIHRoZSBtYWluIGNvbGxpc2lvbiBhcyB0aGlzIGNhbiBnZXQgZnVua3kgaW4gY2FzY2FkZXMgYW5kIGNhdXNlXHJcbiAgLy8gdW53YW50ZWQgc3dhcHBpbmcgYmVoYXZpb3IuXHJcbiAgaWYgKGlzVXNlckFjdGlvbikge1xyXG4gICAgLy8gTWFrZSBhIG1vY2sgaXRlbSBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIGl0ZW0gaGVyZSwgb25seSBtb2RpZnkgaW4gbW92ZUVsZW1lbnQuXHJcbiAgICBjb25zdCBmYWtlSXRlbTogTGF5b3V0SXRlbSA9IHtcclxuICAgICAgeDogaXRlbVRvTW92ZS54LFxyXG4gICAgICB5OiBpdGVtVG9Nb3ZlLnksXHJcbiAgICAgIHc6IGl0ZW1Ub01vdmUudyxcclxuICAgICAgaDogaXRlbVRvTW92ZS5oLFxyXG4gICAgICBpOiAnLTEnXHJcbiAgICB9O1xyXG4gICAgZmFrZUl0ZW0ueSA9IE1hdGgubWF4KGNvbGxpZGVzV2l0aC55IC0gaXRlbVRvTW92ZS5oLCAwKTtcclxuICAgIGlmICghZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0LCBmYWtlSXRlbSkpIHtcclxuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgaXRlbVRvTW92ZSwgdW5kZWZpbmVkLCBmYWtlSXRlbS55KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByZXZpb3VzbHkgdGhpcyB3YXMgb3B0aW1pemVkIHRvIG1vdmUgYmVsb3cgdGhlIGNvbGxpc2lvbiBkaXJlY3RseSwgYnV0IHRoaXMgY2FuIGNhdXNlIHByb2JsZW1zXHJcbiAgLy8gd2l0aCBjYXNjYWRpbmcgbW92ZXMsIGFzIGFuIGl0ZW0gbWF5IGFjdHVhbGx5IGxlYXBmbG9nIGEgY29sbGlzaW9uIGFuZCBjYXVzZSBhIHJldmVyc2FsIGluIG9yZGVyLlxyXG4gIHJldHVybiBtb3ZlRWxlbWVudChsYXlvdXQsIGl0ZW1Ub01vdmUsIHVuZGVmaW5lZCwgaXRlbVRvTW92ZS55ICsgMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gY29udmVydCBhIG51bWJlciB0byBhIHBlcmNlbnRhZ2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG51bSBBbnkgbnVtYmVyXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoYXQgbnVtYmVyIGFzIGEgcGVyY2VudGFnZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwZXJjKG51bTogbnVtYmVyKTogc3RyaW5nIHtcclxuICByZXR1cm4gbnVtICogMTAwICsgJyUnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCk6IE9iamVjdCB7XHJcbiAgLy8gUmVwbGFjZSB1bml0bGVzcyBpdGVtcyB3aXRoIHB4XHJcbiAgY29uc3QgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUzZChcIiArIGxlZnQgKyBcInB4LFwiICsgdG9wICsgXCJweCwgMClcIjtcclxuICByZXR1cm4ge1xyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUsXHJcbiAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgIE1velRyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgIE9UcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgIHdpZHRoOiB3aWR0aCArIFwicHhcIixcclxuICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxyXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcclxuICB9O1xyXG59XHJcbi8qKlxyXG4gKiBKdXN0IGxpa2UgdGhlIHNldFRyYW5zZm9ybSBtZXRob2QsIGJ1dCBpbnN0ZWFkIGl0IHdpbGwgcmV0dXJuIGEgbmVnYXRpdmUgdmFsdWUgb2YgcmlnaHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0b3BcclxuICogQHBhcmFtIHJpZ2h0XHJcbiAqIEBwYXJhbSB3aWR0aFxyXG4gKiBAcGFyYW0gaGVpZ2h0XHJcbiAqIEByZXR1cm5zIHt7dHJhbnNmb3JtOiBzdHJpbmcsIFdlYmtpdFRyYW5zZm9ybTogc3RyaW5nLCBNb3pUcmFuc2Zvcm06IHN0cmluZywgbXNUcmFuc2Zvcm06IHN0cmluZywgT1RyYW5zZm9ybTogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgcG9zaXRpb246IHN0cmluZ319XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtUnRsKHRvcCwgcmlnaHQsIHdpZHRoLCBoZWlnaHQpOiBPYmplY3Qge1xyXG4gICAgLy8gUmVwbGFjZSB1bml0bGVzcyBpdGVtcyB3aXRoIHB4XHJcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBcInRyYW5zbGF0ZTNkKFwiICsgcmlnaHQgKiAtMSArIFwicHgsXCIgKyB0b3AgKyBcInB4LCAwKVwiO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgICAgICBNb3pUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgICAgICBtc1RyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgICAgIE9UcmFuc2Zvcm06IHRyYW5zbGF0ZSxcclxuICAgICAgICB3aWR0aDogd2lkdGggKyBcInB4XCIsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUb3BMZWZ0KHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCk6IE9iamVjdCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogdG9wICsgXCJweFwiLFxyXG4gICAgICAgIGxlZnQ6IGxlZnQgKyBcInB4XCIsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgXCJweFwiLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBKdXN0IGxpa2UgdGhlIHNldFRvcExlZnQgbWV0aG9kLCBidXQgaW5zdGVhZCwgaXQgd2lsbCByZXR1cm4gYSByaWdodCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGxlZnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0b3BcclxuICogQHBhcmFtIHJpZ2h0XHJcbiAqIEBwYXJhbSB3aWR0aFxyXG4gKiBAcGFyYW0gaGVpZ2h0XHJcbiAqIEByZXR1cm5zIHt7dG9wOiBzdHJpbmcsIHJpZ2h0OiBzdHJpbmcsIHdpZHRoOiBzdHJpbmcsIGhlaWdodDogc3RyaW5nLCBwb3NpdGlvbjogc3RyaW5nfX1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUb3BSaWdodCh0b3AsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0KTogT2JqZWN0IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiB0b3AgKyBcInB4XCIsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0KyBcInB4XCIsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgXCJweFwiLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCBsYXlvdXQgaXRlbXMgc29ydGVkIGZyb20gdG9wIGxlZnQgdG8gcmlnaHQgYW5kIGRvd24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBMYXlvdXQsIHNvcnRlZCBzdGF0aWMgaXRlbXMgZmlyc3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydExheW91dEl0ZW1zQnlSb3dDb2wobGF5b3V0OiBMYXlvdXQpOiBMYXlvdXQge1xyXG4gIHJldHVybiBbXS5jb25jYXQobGF5b3V0KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIGlmIChhLnkgPiBiLnkgfHwgKGEueSA9PT0gYi55ICYmIGEueCA+IGIueCkpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGxheW91dCB1c2luZyB0aGUgaW5pdGlhbExheW91dCBhbmQgY2hpbGRyZW4gYXMgYSB0ZW1wbGF0ZS5cclxuICogTWlzc2luZyBlbnRyaWVzIHdpbGwgYmUgYWRkZWQsIGV4dHJhbmVvdXMgb25lcyB3aWxsIGJlIHRydW5jYXRlZC5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICBpbml0aWFsTGF5b3V0IExheW91dCBwYXNzZWQgaW4gdGhyb3VnaCBwcm9wcy5cclxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgIEN1cnJlbnQgcmVzcG9uc2l2ZSBicmVha3BvaW50LlxyXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0IHZlcnRpY2FsbHkuXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICBXb3JraW5nIGxheW91dC5cclxuICovXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbihpbml0aWFsTGF5b3V0OiBMYXlvdXQsIGNoaWxkcmVuOiBBcnJheTxSZWFjdC5FbGVtZW50PnxSZWFjdC5FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sczogbnVtYmVyLCB2ZXJ0aWNhbENvbXBhY3Q6IGJvb2xlYW4pOiBMYXlvdXQge1xyXG4gIC8vIGVuc3VyZSAnY2hpbGRyZW4nIGlzIGFsd2F5cyBhbiBhcnJheVxyXG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICB9XHJcbiAgaW5pdGlhbExheW91dCA9IGluaXRpYWxMYXlvdXQgfHwgW107XHJcblxyXG4gIC8vIEdlbmVyYXRlIG9uZSBsYXlvdXQgaXRlbSBwZXIgY2hpbGQuXHJcbiAgbGV0IGxheW91dDogTGF5b3V0ID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBsZXQgbmV3SXRlbTtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcblxyXG4gICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxyXG4gICAgY29uc3QgZXhpc3RzID0gZ2V0TGF5b3V0SXRlbShpbml0aWFsTGF5b3V0LCBjaGlsZC5rZXkgfHwgXCIxXCIgLyEqIEZJWE1FIHNhdGlzZmllcyBGbG93ICohLyk7XHJcbiAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgIG5ld0l0ZW0gPSBleGlzdHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBnID0gY2hpbGQucHJvcHMuX2dyaWQ7XHJcblxyXG4gICAgICAvLyBIZXksIHRoaXMgaXRlbSBoYXMgYSBfZ3JpZCBwcm9wZXJ0eSwgdXNlIGl0LlxyXG4gICAgICBpZiAoZykge1xyXG4gICAgICAgIGlmICghaXNQcm9kdWN0aW9uKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUxheW91dChbZ10sICdSZWFjdEdyaWRMYXlvdXQuY2hpbGRyZW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVmFsaWRhdGVkOyBhZGQgaXQgdG8gdGhlIGxheW91dC4gQm90dG9tICd5JyBwb3NzaWJsZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBsYXlvdXQuXHJcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIGRvIG5pY2Ugc3R1ZmYgbGlrZSBzcGVjaWZ5IHt5OiBJbmZpbml0eX1cclxuICAgICAgICBpZiAodmVydGljYWxDb21wYWN0KSB7XHJcbiAgICAgICAgICBuZXdJdGVtID0gY2xvbmVMYXlvdXRJdGVtKHsuLi5nLCB5OiBNYXRoLm1pbihib3R0b20obGF5b3V0KSwgZy55KSwgaTogY2hpbGQua2V5fSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0l0ZW0gPSBjbG9uZUxheW91dEl0ZW0oey4uLmcsIHk6IGcueSwgaTogY2hpbGQua2V5fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIE5vdGhpbmcgcHJvdmlkZWQ6IGVuc3VyZSB0aGlzIGlzIGFkZGVkIHRvIHRoZSBib3R0b21cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbmV3SXRlbSA9IGNsb25lTGF5b3V0SXRlbSh7dzogMSwgaDogMSwgeDogMCwgeTogYm90dG9tKGxheW91dCksIGk6IGNoaWxkLmtleSB8fCBcIjFcIn0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsYXlvdXRbaV0gPSBuZXdJdGVtO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29ycmVjdCB0aGUgbGF5b3V0LlxyXG4gIGxheW91dCA9IGNvcnJlY3RCb3VuZHMobGF5b3V0LCB7Y29sczogY29sc30pO1xyXG4gIGxheW91dCA9IGNvbXBhY3QobGF5b3V0LCB2ZXJ0aWNhbENvbXBhY3QpO1xyXG5cclxuICByZXR1cm4gbGF5b3V0O1xyXG59XHJcbiovXHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgYSBsYXlvdXQuIFRocm93cyBlcnJvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgbGF5b3V0ICAgICAgICBBcnJheSBvZiBsYXlvdXQgaXRlbXMuXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gW2NvbnRleHROYW1lXSBDb250ZXh0IG5hbWUgZm9yIGVycm9ycy5cclxuICogQHRocm93ICB7RXJyb3J9ICAgICAgICAgICAgICAgIFZhbGlkYXRpb24gZXJyb3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXQobGF5b3V0OiBMYXlvdXQsIGNvbnRleHROYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICBjb250ZXh0TmFtZSA9IGNvbnRleHROYW1lIHx8IFwiTGF5b3V0XCI7XHJcbiAgY29uc3Qgc3ViUHJvcHMgPSBbJ3gnLCAneScsICd3JywgJ2gnXTtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkobGF5b3V0KSkgdGhyb3cgbmV3IEVycm9yKGNvbnRleHROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheSFcIik7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgY29uc3QgaXRlbSA9IGxheW91dFtpXTtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViUHJvcHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgaWYgKHR5cGVvZiBpdGVtW3N1YlByb3BzW2pdXSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Z1ZUdyaWRMYXlvdXQ6ICcgKyBjb250ZXh0TmFtZSArICdbJyArIGkgKyAnXS4nICsgc3ViUHJvcHNbal0gKyAnIG11c3QgYmUgYSBudW1iZXIhJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpdGVtLmkgJiYgdHlwZW9mIGl0ZW0uaSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWdWVHcmlkTGF5b3V0OiAnICsgY29udGV4dE5hbWUgKyAnWycgKyBpICsgJ10uaSBtdXN0IGJlIGEgc3RyaW5nIScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0uc3RhdGljICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGl0ZW0uc3RhdGljICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWdWVHcmlkTGF5b3V0OiAnICsgY29udGV4dE5hbWUgKyAnWycgKyBpICsgJ10uc3RhdGljIG11c3QgYmUgYSBib29sZWFuIScpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRmxvdyBjYW4ndCByZWFsbHkgZmlndXJlIHRoaXMgb3V0LCBzbyB3ZSBqdXN0IHVzZSBPYmplY3RcclxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9CaW5kSGFuZGxlcnMoZWw6IE9iamVjdCwgZm5zOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgZm5zLmZvckVhY2goKGtleSkgPT4gZWxba2V5XSA9IGVsW2tleV0uYmluZChlbCkpO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgSlMgb2JqZWN0IHRvIENTUyBzdHJpbmcuIFNpbWlsYXIgdG8gUmVhY3QncyBvdXRwdXQgb2YgQ1NTLlxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFya3VwKG9iaikge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkgcmV0dXJuICcnO1xyXG4gICAgdmFyIGksIGxlbiA9IGtleXMubGVuZ3RoO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcclxuICAgICAgICByZXN1bHQgKz0gaHlwaGVuYXRlKGtleSkgKyAnOicgKyBhZGRQeChrZXksIHZhbCkgKyAnOyc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbi8qIFRoZSBmb2xsb3dpbmcgbGlzdCBpcyBkZWZpbmVkIGluIFJlYWN0J3MgY29yZSAqL1xyXG5leHBvcnQgdmFyIElTX1VOSVRMRVNTID0ge1xyXG4gICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXHJcbiAgICBib3hGbGV4OiB0cnVlLFxyXG4gICAgYm94RmxleEdyb3VwOiB0cnVlLFxyXG4gICAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxyXG4gICAgY29sdW1uQ291bnQ6IHRydWUsXHJcbiAgICBmbGV4OiB0cnVlLFxyXG4gICAgZmxleEdyb3c6IHRydWUsXHJcbiAgICBmbGV4UG9zaXRpdmU6IHRydWUsXHJcbiAgICBmbGV4U2hyaW5rOiB0cnVlLFxyXG4gICAgZmxleE5lZ2F0aXZlOiB0cnVlLFxyXG4gICAgZmxleE9yZGVyOiB0cnVlLFxyXG4gICAgZ3JpZFJvdzogdHJ1ZSxcclxuICAgIGdyaWRDb2x1bW46IHRydWUsXHJcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxyXG4gICAgbGluZUNsYW1wOiB0cnVlLFxyXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcclxuICAgIG9wYWNpdHk6IHRydWUsXHJcbiAgICBvcmRlcjogdHJ1ZSxcclxuICAgIG9ycGhhbnM6IHRydWUsXHJcbiAgICB0YWJTaXplOiB0cnVlLFxyXG4gICAgd2lkb3dzOiB0cnVlLFxyXG4gICAgekluZGV4OiB0cnVlLFxyXG4gICAgem9vbTogdHJ1ZSxcclxuXHJcbiAgICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXHJcbiAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcclxuICAgIHN0b3BPcGFjaXR5OiB0cnVlLFxyXG4gICAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcclxuICAgIHN0cm9rZU9wYWNpdHk6IHRydWUsXHJcbiAgICBzdHJva2VXaWR0aDogdHJ1ZVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBXaWxsIGFkZCBweCB0byB0aGUgZW5kIG9mIHN0eWxlIHZhbHVlcyB3aGljaCBhcmUgTnVtYmVycy5cclxuICogQHBhcmFtIG5hbWVcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFB4KG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZih0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFJU19VTklUTEVTU1sgbmFtZSBdKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZEl0ZW1JbkFycmF5KGFycmF5LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgIGZvciAodmFyIGk9MDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlmIChhcnJheVtpXVtwcm9wZXJ0eV0gPT0gdmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBbmRSZW1vdmUoYXJyYXksIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xyXG4gICAgICAgIGlmIChyZXN1bHRbcHJvcGVydHldID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvL1JlbW92ZSBmcm9tIGFycmF5XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = module.exports = {};\n\n/**\n * Loops through the collection and calls the callback for each element. if the callback returns truthy, the loop is broken and returns the same value.\n * @public\n * @param {*} collection The collection to loop through. Needs to have a length property set and have indices set from 0 to length - 1.\n * @param {function} callback The callback to be called for each element. The element will be given as a parameter to the callback. If this callback returns truthy, the loop is broken and the same value is returned.\n * @returns {*} The value that a callback has returned (if truthy). Otherwise nothing.\n */\nutils.forEach = function(collection, callback) {\n    for(var i = 0; i < collection.length; i++) {\n        var result = callback(collection[i]);\n        if(result) {\n            return result;\n        }\n    }\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2NvbGxlY3Rpb24tdXRpbHMuanM/NzViMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLFNBQVM7QUFDcEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggZWxlbWVudC4gaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5LCB0aGUgbG9vcCBpcyBicm9rZW4gYW5kIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gbG9vcCB0aHJvdWdoLiBOZWVkcyB0byBoYXZlIGEgbGVuZ3RoIHByb3BlcnR5IHNldCBhbmQgaGF2ZSBpbmRpY2VzIHNldCBmcm9tIDAgdG8gbGVuZ3RoIC0gMS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudC4gVGhlIGVsZW1lbnQgd2lsbCBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUgY2FsbGJhY2suIElmIHRoaXMgY2FsbGJhY2sgcmV0dXJucyB0cnV0aHksIHRoZSBsb29wIGlzIGJyb2tlbiBhbmQgdGhlIHNhbWUgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgYSBjYWxsYmFjayBoYXMgcmV0dXJuZWQgKGlmIHRydXRoeSkuIE90aGVyd2lzZSBub3RoaW5nLlxuICovXG51dGlscy5mb3JFYWNoID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpXSk7XG4gICAgICAgIGlmKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvY29sbGVjdGlvbi11dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar detector = module.exports = {};\n\ndetector.isIE = function(version) {\n    function isAnyIeVersion() {\n        var agent = navigator.userAgent.toLowerCase();\n        return agent.indexOf(\"msie\") !== -1 || agent.indexOf(\"trident\") !== -1 || agent.indexOf(\" edge/\") !== -1;\n    }\n\n    if(!isAnyIeVersion()) {\n        return false;\n    }\n\n    if(!version) {\n        return true;\n    }\n\n    //Shamelessly stolen from https://gist.github.com/padolsey/527683\n    var ieVersion = (function(){\n        var undef,\n            v = 3,\n            div = document.createElement(\"div\"),\n            all = div.getElementsByTagName(\"i\");\n\n        do {\n            div.innerHTML = \"<!--[if gt IE \" + (++v) + \"]><i></i><![endif]-->\";\n        }\n        while (all[0]);\n\n        return v > 4 ? v : undef;\n    }());\n\n    return version === ieVersion;\n};\n\ndetector.isLegacyOpera = function() {\n    return !!window.opera;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2Jyb3dzZXItZGV0ZWN0b3IuanM/NDlhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZXRlY3RvciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmRldGVjdG9yLmlzSUUgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICAgZnVuY3Rpb24gaXNBbnlJZVZlcnNpb24oKSB7XG4gICAgICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGFnZW50LmluZGV4T2YoXCJtc2llXCIpICE9PSAtMSB8fCBhZ2VudC5pbmRleE9mKFwidHJpZGVudFwiKSAhPT0gLTEgfHwgYWdlbnQuaW5kZXhPZihcIiBlZGdlL1wiKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgaWYoIWlzQW55SWVWZXJzaW9uKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vU2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGFkb2xzZXkvNTI3NjgzXG4gICAgdmFyIGllVmVyc2lvbiA9IChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdW5kZWYsXG4gICAgICAgICAgICB2ID0gMyxcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpXCIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjwhLS1baWYgZ3QgSUUgXCIgKyAoKyt2KSArIFwiXT48aT48L2k+PCFbZW5kaWZdLS0+XCI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFsbFswXSk7XG5cbiAgICAgICAgcmV0dXJuIHYgPiA0ID8gdiA6IHVuZGVmO1xuICAgIH0oKSk7XG5cbiAgICByZXR1cm4gdmVyc2lvbiA9PT0gaWVWZXJzaW9uO1xufTtcblxuZGV0ZWN0b3IuaXNMZWdhY3lPcGVyYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5vcGVyYTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvYnJvd3Nlci1kZXRlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _vue = __webpack_require__(4);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _App = __webpack_require__(13);\n\nvar _App2 = _interopRequireDefault(_App);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nnew _vue2.default({\n  el: '#app',\n  render: function render(h) {\n    return h(_App2.default);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbImVsIiwicmVuZGVyIiwiaCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQSxrQkFBUTtBQUNOQSxNQUFJLE1BREU7QUFFTkMsVUFBUTtBQUFBLFdBQUtDLGdCQUFMO0FBQUE7QUFGRixDQUFSIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJ1xyXG5cclxubmV3IFZ1ZSh7XHJcbiAgZWw6ICcjYXBwJyxcclxuICByZW5kZXI6IGggPT4gaChBcHApXHJcbn0pXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(12);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9kN2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(3)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(14)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(17),\n  /* template */\n  __webpack_require__(50),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT85ZTA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBLHNCQUFtTTs7QUFFbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/bWluaW1pemUhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNmI1MGNjNzNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNmI1MGNjNzNcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(15);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1)(\"42c0b3c2\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9kMmYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0Esb0NBQW9NO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21pbmltaXplIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTZiNTBjYzczXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9BcHAudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI0MmMwYjNjMlwiLCBjb250ZW50LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/bWluaW1pemUhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02YjUwY2M3M1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)();\n// imports\n\n\n// module\nexports.push([module.i, \"\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8yYTZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP21pbmltaXplIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNmI1MGNjNzNcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQXBwLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzNiNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _GridItem = __webpack_require__(6);\n\nvar _GridItem2 = _interopRequireDefault(_GridItem);\n\nvar _GridLayout = __webpack_require__(24);\n\nvar _GridLayout2 = _interopRequireDefault(_GridLayout);\n\nvar _TestElement = __webpack_require__(40);\n\nvar _TestElement2 = _interopRequireDefault(_TestElement);\n\nvar _CustomDragElement = __webpack_require__(45);\n\nvar _CustomDragElement2 = _interopRequireDefault(_CustomDragElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//var eventBus = require('./eventBus');\n\n//import ResponsiveGridLayout from './ResponsiveGridLayout.vue';\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar testLayout = [{ \"x\": 0, \"y\": 0, \"w\": 2, \"h\": 2, \"i\": \"0\", resizable: true, draggable: true }, { \"x\": 2, \"y\": 0, \"w\": 2, \"h\": 4, \"i\": \"1\", resizable: null, draggable: null }, { \"x\": 4, \"y\": 0, \"w\": 2, \"h\": 5, \"i\": \"2\", resizable: false, draggable: false }, { \"x\": 6, \"y\": 0, \"w\": 2, \"h\": 3, \"i\": \"3\", resizable: false, draggable: false }, { \"x\": 8, \"y\": 0, \"w\": 2, \"h\": 3, \"i\": \"4\", resizable: false, draggable: false }, { \"x\": 10, \"y\": 0, \"w\": 2, \"h\": 3, \"i\": \"5\", resizable: false, draggable: false }, { \"x\": 0, \"y\": 5, \"w\": 2, \"h\": 5, \"i\": \"6\", resizable: false, draggable: false }, { \"x\": 2, \"y\": 5, \"w\": 2, \"h\": 5, \"i\": \"7\", resizable: false, draggable: false }, { \"x\": 4, \"y\": 5, \"w\": 2, \"h\": 5, \"i\": \"8\", resizable: false, draggable: false }, { \"x\": 6, \"y\": 4, \"w\": 2, \"h\": 4, \"i\": \"9\", resizable: false, draggable: false }, { \"x\": 8, \"y\": 4, \"w\": 2, \"h\": 4, \"i\": \"10\", resizable: false, draggable: false }, { \"x\": 10, \"y\": 4, \"w\": 2, \"h\": 4, \"i\": \"11\", resizable: false, draggable: false }, { \"x\": 0, \"y\": 10, \"w\": 2, \"h\": 5, \"i\": \"12\", resizable: false, draggable: false }, { \"x\": 2, \"y\": 10, \"w\": 2, \"h\": 5, \"i\": \"13\", resizable: false, draggable: false }, { \"x\": 4, \"y\": 8, \"w\": 2, \"h\": 4, \"i\": \"14\", resizable: false, draggable: false }, { \"x\": 6, \"y\": 8, \"w\": 2, \"h\": 4, \"i\": \"15\", resizable: false, draggable: false }, { \"x\": 8, \"y\": 10, \"w\": 2, \"h\": 5, \"i\": \"16\", resizable: false, draggable: false }, { \"x\": 10, \"y\": 4, \"w\": 2, \"h\": 2, \"i\": \"17\", resizable: false, draggable: false }, { \"x\": 0, \"y\": 9, \"w\": 2, \"h\": 3, \"i\": \"18\", resizable: false, draggable: false }, { \"x\": 2, \"y\": 6, \"w\": 2, \"h\": 2, \"i\": \"19\", resizable: false, draggable: false }];\n\nexports.default = {\n    name: 'app',\n    components: {\n        //ResponsiveGridLayout,\n        GridLayout: _GridLayout2.default,\n        GridItem: _GridItem2.default,\n        TestElement: _TestElement2.default,\n        CustomDragElement: _CustomDragElement2.default\n    },\n    data: function data() {\n        return {\n            layout: JSON.parse(JSON.stringify(testLayout)),\n            layout2: JSON.parse(JSON.stringify(testLayout)),\n            draggable: true,\n            resizable: true,\n            mirrored: false,\n            rowHeight: 30,\n            colNum: 0,\n            index: 0\n        };\n    },\n\n    mounted: function mounted() {\n        this.index = this.layout.length;\n    },\n    methods: {\n        clicked: function clicked() {\n            window.alert(\"CLICK!\");\n        },\n        increaseWidth: function increaseWidth(item) {\n            var width = document.getElementById(\"content\").offsetWidth;\n            width += 20;\n            document.getElementById(\"content\").style.width = width + \"px\";\n        },\n        decreaseWidth: function decreaseWidth(item) {\n\n            var width = document.getElementById(\"content\").offsetWidth;\n            width -= 20;\n            document.getElementById(\"content\").style.width = width + \"px\";\n        },\n        removeItem: function removeItem(item) {\n            //console.log(\"### REMOVE \" + item.i);\n            this.layout.splice(this.layout.indexOf(item), 1);\n        },\n        addItem: function addItem() {\n            var self = this;\n            //console.log(\"### LENGTH: \" + this.layout.length);\n            var item = { \"x\": 0, \"y\": 0, \"w\": 2, \"h\": 2, \"i\": this.index + \"\", whatever: \"bbb\" };\n            this.index++;\n            this.layout.push(item);\n        },\n        move: function move(i, newX, newY) {\n            console.log(\"MOVE i=\" + i + \", X=\" + newX + \", Y=\" + newY);\n        },\n        resize: function resize(i, newH, newW) {\n            console.log(\"RESIZE i=\" + i + \", H=\" + newH + \", W=\" + newW);\n        },\n        moved: function moved(i, newX, newY) {\n            console.log(\"### MOVED i=\" + i + \", X=\" + newX + \", Y=\" + newY);\n        },\n        resized: function resized(i, newH, newW, newHPx, newWPx) {\n            console.log(\"### RESIZED i=\" + i + \", H=\" + newH + \", W=\" + newW + \", H(px)=\" + newHPx + \", W(px)=\" + newWPx);\n        },\n        /**\n         * Add change direction button\n         */\n        changeDirection: function changeDirection() {\n            var documentDirection = document.dir != undefined ? document.dir : document.getElementsByTagName(\"html\")[0].getAttribute(\"dir\");\n            var toggle = \"\";\n            if (documentDirection == \"rtl\") {\n                toggle = \"ltr\";\n            } else {\n                toggle = \"rtl\";\n            }\n            var html = document.getElementsByTagName(\"html\")[0];\n            html.setAttribute(\"dir\", toggle);\n            //eventBus.$emit('directionchange');\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQXBwLnZ1ZT9lZmMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUEyRkE7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUNBOztBQUhBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLGlCQUNBLHlFQUNBLGdGQUNBLGlGQUNBLGtGQUNBLGtGQUNBLG1GQUNBLGtGQUNBLGtGQUNBLGtGQUNBLGtGQUNBLG1GQUNBLG9GQUNBLG9GQUNBLG9GQUNBLG1GQUNBLG1GQUNBLG9GQUNBLG9GQUNBLG1GQUNBLG1GQUdBOzs7VUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTkE7MEJBT0E7OzhDQUVBOytDQUNBO3VCQUNBO3VCQUNBO3NCQUNBO3VCQUNBO29CQUNBO21CQUVBO0FBVEE7QUFVQTs7Z0NBQ0E7aUNBQ0E7QUFDQTs7b0NBRUE7eUJBQ0E7QUFDQTtvREFDQTsyREFDQTtxQkFDQTtxRUFDQTtBQUNBO29EQUVBOzsyREFDQTtxQkFDQTtxRUFDQTtBQUNBOzhDQUNBO0FBQ0E7MERBQ0E7QUFDQTtvQ0FDQTt1QkFDQTtBQUNBO3lGQUNBO2lCQUNBOzZCQUNBO0FBQ0E7MkNBQ0E7aUVBQ0E7QUFDQTsrQ0FDQTttRUFDQTtBQUNBOzZDQUNBO3NFQUNBO0FBQ0E7aUVBQ0E7a0hBQ0E7QUFDQTtBQUdBOzs7b0RBQ0E7b0RBQ0EscUJBQ0EsNERBQ0E7eUJBQ0E7NENBQ0E7eUJBQ0E7bUJBQ0E7eUJBQ0E7QUFDQTs2REFDQTtxQ0FDQTtBQUNBO0FBRUE7QUF2REE7QUF4QkEiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGlkPVwiYXBwXCI+XHJcbiAgICAgICAgPGgxPlZ1ZSBHcmlkIExheW91dDwvaDE+XHJcbiAgICAgICAgPCEtLTxwcmU+e3sgbGF5b3V0IHwganNvbiB9fTwvcHJlPi0tPlxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsYXlvdXRKU09OXCI+XHJcbiAgICAgICAgICAgICAgICBEaXNwbGF5ZWQgYXMgPGNvZGU+W3gsIHksIHcsIGhdPC9jb2RlPjpcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxheW91dEl0ZW1cIiB2LWZvcj1cIml0ZW0gaW4gbGF5b3V0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxiPnt7aXRlbS5pfX08L2I+OiBbe3tpdGVtLnh9fSwge3tpdGVtLnl9fSwge3tpdGVtLnd9fSwge3tpdGVtLmh9fV1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxheW91dEpTT05cIj5cclxuICAgICAgICAgICAgICAgIERpc3BsYXllZCBhcyA8Y29kZT5beCwgeSwgdywgaF08L2NvZGU+OlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGF5b3V0SXRlbVwiIHYtZm9yPVwiaXRlbSBpbiBsYXlvdXQyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxiPnt7aXRlbS5pfX08L2I+OiBbe3tpdGVtLnh9fSwge3tpdGVtLnl9fSwge3tpdGVtLnd9fSwge3tpdGVtLmh9fV1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwiY29udGVudFwiPlxyXG4gICAgICAgICAgICA8YnV0dG9uIEBjbGljaz1cImRlY3JlYXNlV2lkdGhcIj5EZWNyZWFzZSBXaWR0aDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIEBjbGljaz1cImluY3JlYXNlV2lkdGhcIj5JbmNyZWFzZSBXaWR0aDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIEBjbGljaz1cImFkZEl0ZW1cIj5BZGQgYW4gaXRlbTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8IS0tIEFkZCB0byBzaG93IHJ0bCBzdXBwb3J0IC0tPlxyXG4gICAgICAgICAgICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZURpcmVjdGlvblwiPkNoYW5nZSBEaXJlY3Rpb248L2J1dHRvbj5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkcmFnZ2FibGVcIi8+IERyYWdnYWJsZVxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cInJlc2l6YWJsZVwiLz4gUmVzaXphYmxlXHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2LW1vZGVsPVwibWlycm9yZWRcIi8+IE1pcnJvcmVkXHJcbiAgICAgICAgICAgIDxici8+XHJcbiAgICAgICAgICAgIFJvdyBIZWlnaHQ6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdi1tb2RlbD1cInJvd0hlaWdodFwiLz5cclxuICAgICAgICAgICAgPGJyLz5cclxuICAgICAgICAgICAgPGdyaWQtbGF5b3V0XHJcbiAgICAgICAgICAgICAgICAgICAgOmxheW91dD1cImxheW91dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgOmNvbC1udW09XCIxMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgOnJvdy1oZWlnaHQ9XCJyb3dIZWlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgIDppcy1kcmFnZ2FibGU9XCJkcmFnZ2FibGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDppcy1yZXNpemFibGU9XCJyZXNpemFibGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDppcy1taXJyb3JlZD1cIm1pcnJvcmVkXCJcclxuICAgICAgICAgICAgICAgICAgICA6dmVydGljYWwtY29tcGFjdD1cInRydWVcIlxyXG4gICAgICAgICAgICAgICAgICAgIDp1c2UtY3NzLXRyYW5zZm9ybXM9XCJ0cnVlXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGdyaWQtaXRlbSB2LWZvcj1cIml0ZW0gaW4gbGF5b3V0XCIgOmtleT1cIml0ZW0uaVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDp4PVwiaXRlbS54XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOnk9XCJpdGVtLnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6dz1cIml0ZW0ud1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDpoPVwiaXRlbS5oXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOm1pbi13PVwiMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDptaW4taD1cIjJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6aT1cIml0ZW0uaVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEByZXNpemU9XCJyZXNpemVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAbW92ZT1cIm1vdmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAcmVzaXplZD1cInJlc2l6ZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAbW92ZWQ9XCJtb3ZlZFwiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLTxjdXN0b20tZHJhZy1lbGVtZW50IDp0ZXh0PVwiaXRlbS5pXCI+PC9jdXN0b20tZHJhZy1lbGVtZW50Pi0tPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXN0LWVsZW1lbnQgOnRleHQ9XCJpdGVtLmlcIj48L3Rlc3QtZWxlbWVudD5cclxuICAgICAgICAgICAgICAgICAgICA8IS0tPGJ1dHRvbiBAY2xpY2s9XCJjbGlja2VkXCI+Q0xJQ0sgTUUhPC9idXR0b24+LS0+XHJcbiAgICAgICAgICAgICAgICA8L2dyaWQtaXRlbT5cclxuICAgICAgICAgICAgPC9ncmlkLWxheW91dD5cclxuICAgICAgICAgICAgPGhyLz5cclxuICAgICAgICAgICAgPCEtLTxncmlkLWxheW91dFxyXG4gICAgICAgICAgICAgICAgICAgIDpsYXlvdXQ9XCJsYXlvdXQyXCJcclxuICAgICAgICAgICAgICAgICAgICA6Y29sLW51bT1cIjEyXCJcclxuICAgICAgICAgICAgICAgICAgICA6cm93LWhlaWdodD1cInJvd0hlaWdodFwiXHJcbiAgICAgICAgICAgICAgICAgICAgOmlzLWRyYWdnYWJsZT1cImRyYWdnYWJsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOmlzLXJlc2l6YWJsZT1cInJlc2l6YWJsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOnZlcnRpY2FsLWNvbXBhY3Q9XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgICAgICA6dXNlLWNzcy10cmFuc2Zvcm1zPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxncmlkLWl0ZW0gdi1mb3I9XCJpdGVtIGluIGxheW91dDJcIiA6a2V5PVwiaXRlbS5pXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOng9XCJpdGVtLnhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6eT1cIml0ZW0ueVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDp3PVwiaXRlbS53XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOmg9XCJpdGVtLmhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6bWluLXc9XCIyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOm1pbi1oPVwiMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDppPVwiaXRlbS5pXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOmlzLWRyYWdnYWJsZT1cIml0ZW0uZHJhZ2dhYmxlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOmlzLXJlc2l6YWJsZT1cIml0ZW0ucmVzaXphYmxlXCJcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8dGVzdC1lbGVtZW50IDp0ZXh0PVwiaXRlbS5pXCI+PC90ZXN0LWVsZW1lbnQ+XHJcbiAgICAgICAgICAgICAgICA8L2dyaWQtaXRlbT5cclxuICAgICAgICAgICAgPC9ncmlkLWxheW91dD4tLT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuICAgIGltcG9ydCBHcmlkSXRlbSBmcm9tICcuL0dyaWRJdGVtLnZ1ZSc7XHJcbiAgICBpbXBvcnQgR3JpZExheW91dCBmcm9tICcuL0dyaWRMYXlvdXQudnVlJztcclxuICAgIC8vaW1wb3J0IFJlc3BvbnNpdmVHcmlkTGF5b3V0IGZyb20gJy4vUmVzcG9uc2l2ZUdyaWRMYXlvdXQudnVlJztcclxuICAgIGltcG9ydCBUZXN0RWxlbWVudCBmcm9tICcuL1Rlc3RFbGVtZW50LnZ1ZSc7XHJcbiAgICBpbXBvcnQgQ3VzdG9tRHJhZ0VsZW1lbnQgZnJvbSAnLi9DdXN0b21EcmFnRWxlbWVudC52dWUnO1xyXG4gICAgLy92YXIgZXZlbnRCdXMgPSByZXF1aXJlKCcuL2V2ZW50QnVzJyk7XHJcblxyXG4gICAgdmFyIHRlc3RMYXlvdXQgPSBbXHJcbiAgICAgICAge1wieFwiOjAsXCJ5XCI6MCxcIndcIjoyLFwiaFwiOjIsXCJpXCI6XCIwXCIsIHJlc2l6YWJsZTogdHJ1ZSwgZHJhZ2dhYmxlOiB0cnVlfSxcclxuICAgICAgICB7XCJ4XCI6MixcInlcIjowLFwid1wiOjIsXCJoXCI6NCxcImlcIjpcIjFcIiwgcmVzaXphYmxlOiBudWxsLCBkcmFnZ2FibGU6IG51bGx9LFxyXG4gICAgICAgIHtcInhcIjo0LFwieVwiOjAsXCJ3XCI6MixcImhcIjo1LFwiaVwiOlwiMlwiLCByZXNpemFibGU6IGZhbHNlLCBkcmFnZ2FibGU6IGZhbHNlfSxcclxuICAgICAgICB7XCJ4XCI6NixcInlcIjowLFwid1wiOjIsXCJoXCI6MyxcImlcIjpcIjNcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjgsXCJ5XCI6MCxcIndcIjoyLFwiaFwiOjMsXCJpXCI6XCI0XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjoxMCxcInlcIjowLFwid1wiOjIsXCJoXCI6MyxcImlcIjpcIjVcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjAsXCJ5XCI6NSxcIndcIjoyLFwiaFwiOjUsXCJpXCI6XCI2XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjoyLFwieVwiOjUsXCJ3XCI6MixcImhcIjo1LFwiaVwiOlwiN1wiLCByZXNpemFibGU6IGZhbHNlLCBkcmFnZ2FibGU6IGZhbHNlfSxcclxuICAgICAgICB7XCJ4XCI6NCxcInlcIjo1LFwid1wiOjIsXCJoXCI6NSxcImlcIjpcIjhcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjYsXCJ5XCI6NCxcIndcIjoyLFwiaFwiOjQsXCJpXCI6XCI5XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjo4LFwieVwiOjQsXCJ3XCI6MixcImhcIjo0LFwiaVwiOlwiMTBcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjEwLFwieVwiOjQsXCJ3XCI6MixcImhcIjo0LFwiaVwiOlwiMTFcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjAsXCJ5XCI6MTAsXCJ3XCI6MixcImhcIjo1LFwiaVwiOlwiMTJcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjIsXCJ5XCI6MTAsXCJ3XCI6MixcImhcIjo1LFwiaVwiOlwiMTNcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjQsXCJ5XCI6OCxcIndcIjoyLFwiaFwiOjQsXCJpXCI6XCIxNFwiLCByZXNpemFibGU6IGZhbHNlLCBkcmFnZ2FibGU6IGZhbHNlfSxcclxuICAgICAgICB7XCJ4XCI6NixcInlcIjo4LFwid1wiOjIsXCJoXCI6NCxcImlcIjpcIjE1XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjo4LFwieVwiOjEwLFwid1wiOjIsXCJoXCI6NSxcImlcIjpcIjE2XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjoxMCxcInlcIjo0LFwid1wiOjIsXCJoXCI6MixcImlcIjpcIjE3XCIsIHJlc2l6YWJsZTogZmFsc2UsIGRyYWdnYWJsZTogZmFsc2V9LFxyXG4gICAgICAgIHtcInhcIjowLFwieVwiOjksXCJ3XCI6MixcImhcIjozLFwiaVwiOlwiMThcIiwgcmVzaXphYmxlOiBmYWxzZSwgZHJhZ2dhYmxlOiBmYWxzZX0sXHJcbiAgICAgICAge1wieFwiOjIsXCJ5XCI6NixcIndcIjoyLFwiaFwiOjIsXCJpXCI6XCIxOVwiLCByZXNpemFibGU6IGZhbHNlLCBkcmFnZ2FibGU6IGZhbHNlfVxyXG4gICAgXTtcclxuXHJcbiAgICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICAgICAgbmFtZTogJ2FwcCcsXHJcbiAgICAgICAgY29tcG9uZW50czoge1xyXG4gICAgICAgICAgICAvL1Jlc3BvbnNpdmVHcmlkTGF5b3V0LFxyXG4gICAgICAgICAgICBHcmlkTGF5b3V0LFxyXG4gICAgICAgICAgICBHcmlkSXRlbSxcclxuICAgICAgICAgICAgVGVzdEVsZW1lbnQsXHJcbiAgICAgICAgICAgIEN1c3RvbURyYWdFbGVtZW50LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGVzdExheW91dCkpLFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0MjogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0ZXN0TGF5b3V0KSksXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICByZXNpemFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtaXJyb3JlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IDMwLFxyXG4gICAgICAgICAgICAgICAgY29sTnVtOiAwLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5sYXlvdXQubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgICBjbGlja2VkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChcIkNMSUNLIVwiKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5jcmVhc2VXaWR0aDogZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250ZW50XCIpLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgd2lkdGggKz0gMjA7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRlbnRcIikuc3R5bGUud2lkdGggPSB3aWR0aCtcInB4XCI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlY3JlYXNlV2lkdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRlbnRcIikub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtPSAyMDtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udGVudFwiKS5zdHlsZS53aWR0aCA9IHdpZHRoK1wicHhcIjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIiMjIyBSRU1PVkUgXCIgKyBpdGVtLmkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc3BsaWNlKHRoaXMubGF5b3V0LmluZGV4T2YoaXRlbSksIDEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRJdGVtOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIjIyMgTEVOR1RIOiBcIiArIHRoaXMubGF5b3V0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcInhcIjowLFwieVwiOjAsXCJ3XCI6MixcImhcIjoyLFwiaVwiOnRoaXMuaW5kZXgrXCJcIiwgd2hhdGV2ZXI6IFwiYmJiXCJ9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW92ZTogZnVuY3Rpb24oaSwgbmV3WCwgbmV3WSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1PVkUgaT1cIiArIGkgKyBcIiwgWD1cIiArIG5ld1ggKyBcIiwgWT1cIiArIG5ld1kpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uKGksIG5ld0gsIG5ld1cpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSRVNJWkUgaT1cIiArIGkgKyBcIiwgSD1cIiArIG5ld0ggKyBcIiwgVz1cIiArIG5ld1cpO1xyXG4gICAgICAgICAgICB9LCAgICAgICAgIFxyXG4gICAgICAgICAgICBtb3ZlZDogZnVuY3Rpb24oaSwgbmV3WCwgbmV3WSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiMjIyBNT1ZFRCBpPVwiICsgaSArIFwiLCBYPVwiICsgbmV3WCArIFwiLCBZPVwiICsgbmV3WSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKGksIG5ld0gsIG5ld1csIG5ld0hQeCwgbmV3V1B4KXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIFJFU0laRUQgaT1cIiArIGkgKyBcIiwgSD1cIiArIG5ld0ggKyBcIiwgVz1cIiArIG5ld1cgKyBcIiwgSChweCk9XCIgKyBuZXdIUHggKyBcIiwgVyhweCk9XCIgKyBuZXdXUHgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkIGNoYW5nZSBkaXJlY3Rpb24gYnV0dG9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjaGFuZ2VEaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnREaXJlY3Rpb24gPSAoZG9jdW1lbnQuZGlyICE9dW5kZWZpbmVkKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlyIDpcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF0uZ2V0QXR0cmlidXRlKFwiZGlyXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRvZ2dsZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnREaXJlY3Rpb24gPT0gXCJydGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZSA9IFwibHRyXCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlID0gXCJydGxcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF07XHJcbiAgICAgICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRpclwiLCB0b2dnbGUpO1xyXG4gICAgICAgICAgICAgICAgLy9ldmVudEJ1cy4kZW1pdCgnZGlyZWN0aW9uY2hhbmdlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuLyogICAgI2FwcCB7XHJcbiAgICAgICAgZm9udC1mYW1pbHk6ICdBdmVuaXInLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xyXG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xyXG4gICAgICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XHJcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIGNvbG9yOiAjMmMzZTUwO1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDYwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgaDEsIGgyIHtcclxuICAgICAgICBmb250LXdlaWdodDogbm9ybWFsO1xyXG4gICAgfVxyXG5cclxuICAgIHVsIHtcclxuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XHJcbiAgICAgICAgcGFkZGluZzogMDtcclxuICAgIH1cclxuXHJcbiAgICBsaSB7XHJcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgICAgIG1hcmdpbjogMCAxMHB4O1xyXG4gICAgfVxyXG5cclxuICAgIGEge1xyXG4gICAgICAgIGNvbG9yOiAjNDJiOTgzO1xyXG4gICAgfSovXHJcbjwvc3R5bGU+XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBBcHAudnVlPzM3ZDIwYTk4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(19);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1)(\"d96c4fce\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZEl0ZW0udnVlPzEwOTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBb007QUFDcE07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bWluaW1pemUhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZjJlZjljZDJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0dyaWRJdGVtLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiZDk2YzRmY2VcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP21pbmltaXplIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZjJlZjljZDJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvR3JpZEl0ZW0udnVlXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)();\n// imports\n\n\n// module\nexports.push([module.i, \".vue-grid-item{transition:all .2s ease;transition-property:left,top,right}.vue-grid-item.cssTransforms{transition-property:transform;left:0;right:auto}.vue-grid-item.cssTransforms.render-rtl{left:auto;right:0}.vue-grid-item.resizing{opacity:.6;z-index:3}.vue-grid-item.vue-draggable-dragging{transition:none;z-index:3}.vue-grid-item.vue-grid-placeholder{background:red;opacity:.2;transition-duration:.1s;z-index:2;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.vue-grid-item>.vue-resizable-handle{position:absolute;width:20px;height:20px;bottom:0;right:0;background:url(\\\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pg08IS0tIEdlbmVyYXRvcjogQWRvYmUgRmlyZXdvcmtzIENTNiwgRXhwb3J0IFNWRyBFeHRlbnNpb24gYnkgQWFyb24gQmVhbGwgKGh0dHA6Ly9maXJld29ya3MuYWJlYWxsLmNvbSkgLiBWZXJzaW9uOiAwLjYuMSAgLS0+DTwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DTxzdmcgaWQ9IlVudGl0bGVkLVBhZ2UlMjAxIiB2aWV3Qm94PSIwIDAgNiA2IiBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHZlcnNpb249IjEuMSINCXhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiDQl4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjZweCIgaGVpZ2h0PSI2cHgiDT4NCTxnIG9wYWNpdHk9IjAuMzAyIj4NCQk8cGF0aCBkPSJNIDYgNiBMIDAgNiBMIDAgNC4yIEwgNCA0LjIgTCA0LjIgNC4yIEwgNC4yIDAgTCA2IDAgTCA2IDYgTCA2IDYgWiIgZmlsbD0iIzAwMDAwMCIvPg0JPC9nPg08L3N2Zz4=\\\");background-position:100% 100%;padding:0 3px 3px 0;background-repeat:no-repeat;background-origin:content-box;box-sizing:border-box;cursor:se-resize}.vue-grid-item>.vue-rtl-resizable-handle{bottom:0;left:0;background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAuMDAwMDAwMDAwMDAwMDAyIiBoZWlnaHQ9IjEwLjAwMDAwMDAwMDAwMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDwhLS0gQ3JlYXRlZCB3aXRoIE1ldGhvZCBEcmF3IC0gaHR0cDovL2dpdGh1Yi5jb20vZHVvcGl4ZWwvTWV0aG9kLURyYXcvIC0tPgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSIxMiIgd2lkdGg9IjEyIiB5PSItMSIgeD0iLTEiLz4KICA8ZyBkaXNwbGF5PSJub25lIiBvdmVyZmxvdz0idmlzaWJsZSIgeT0iMCIgeD0iMCIgaGVpZ2h0PSIxMDAlIiB3aWR0aD0iMTAwJSIgaWQ9ImNhbnZhc0dyaWQiPgogICA8cmVjdCBmaWxsPSJ1cmwoI2dyaWRwYXR0ZXJuKSIgc3Ryb2tlLXdpZHRoPSIwIiB5PSIwIiB4PSIwIiBoZWlnaHQ9IjEwMCUiIHdpZHRoPSIxMDAlIi8+CiAgPC9nPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxsaW5lIGNhbnZhcz0iI2ZmZmZmZiIgY2FudmFzLW9wYWNpdHk9IjEiIHN0cm9rZS1saW5lY2FwPSJ1bmRlZmluZWQiIHN0cm9rZS1saW5lam9pbj0idW5kZWZpbmVkIiBpZD0ic3ZnXzEiIHkyPSItNzAuMTc4NDA3IiB4Mj0iMTI0LjQ2NDE3NSIgeTE9Ii0zOC4zOTI3MzciIHgxPSIxNDQuODIxMjg5IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJub25lIi8+CiAgPGxpbmUgc3Ryb2tlPSIjNjY2NjY2IiBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z181IiB5Mj0iOS4xMDY5NTciIHgyPSIwLjk0NzI0NyIgeTE9Ii0wLjAxODEyOCIgeDE9IjAuOTQ3MjQ3IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz4KICA8bGluZSBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z183IiB5Mj0iOSIgeDI9IjEwLjA3MzUyOSIgeTE9IjkiIHgxPSItMC42NTU2NCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2U9IiM2NjY2NjYiIGZpbGw9Im5vbmUiLz4KIDwvZz4KPC9zdmc+);background-position:0 100%;padding-left:3px;background-repeat:no-repeat;background-origin:content-box;cursor:sw-resize;right:auto}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZEl0ZW0udnVlPzhhZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSx3Q0FBeUMsd0JBQXdCLG1DQUFtQyw2QkFBNkIsOEJBQThCLE9BQU8sV0FBVyx3Q0FBd0MsVUFBVSxRQUFRLHdCQUF3QixXQUFXLFVBQVUsc0NBQXNDLGdCQUFnQixVQUFVLG9DQUFvQyxlQUFlLFdBQVcsd0JBQXdCLFVBQVUseUJBQXlCLHNCQUFzQixxQkFBcUIsb0JBQW9CLGlCQUFpQixxQ0FBcUMsa0JBQWtCLFdBQVcsWUFBWSxTQUFTLFFBQVEsb0NBQW9DLG0xQkFBbTFCLDhCQUE4QixvQkFBb0IsNEJBQTRCLDhCQUE4QixzQkFBc0IsaUJBQWlCLHlDQUF5QyxTQUFTLE9BQU8sa0NBQWtDLDY3Q0FBNjdDLDJCQUEyQixpQkFBaUIsNEJBQTRCLDhCQUE4QixpQkFBaUIsV0FBVzs7QUFFcHlHIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnZ1ZS1ncmlkLWl0ZW17dHJhbnNpdGlvbjphbGwgLjJzIGVhc2U7dHJhbnNpdGlvbi1wcm9wZXJ0eTpsZWZ0LHRvcCxyaWdodH0udnVlLWdyaWQtaXRlbS5jc3NUcmFuc2Zvcm1ze3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtO2xlZnQ6MDtyaWdodDphdXRvfS52dWUtZ3JpZC1pdGVtLmNzc1RyYW5zZm9ybXMucmVuZGVyLXJ0bHtsZWZ0OmF1dG87cmlnaHQ6MH0udnVlLWdyaWQtaXRlbS5yZXNpemluZ3tvcGFjaXR5Oi42O3otaW5kZXg6M30udnVlLWdyaWQtaXRlbS52dWUtZHJhZ2dhYmxlLWRyYWdnaW5ne3RyYW5zaXRpb246bm9uZTt6LWluZGV4OjN9LnZ1ZS1ncmlkLWl0ZW0udnVlLWdyaWQtcGxhY2Vob2xkZXJ7YmFja2dyb3VuZDpyZWQ7b3BhY2l0eTouMjt0cmFuc2l0aW9uLWR1cmF0aW9uOi4xczt6LWluZGV4OjI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTstby11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnZ1ZS1ncmlkLWl0ZW0+LnZ1ZS1yZXNpemFibGUtaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7Ym90dG9tOjA7cmlnaHQ6MDtiYWNrZ3JvdW5kOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QZzA4SVMwdElFZGxibVZ5WVhSdmNqb2dRV1J2WW1VZ1JtbHlaWGR2Y210eklFTlROaXdnUlhod2IzSjBJRk5XUnlCRmVIUmxibk5wYjI0Z1lua2dRV0Z5YjI0Z1FtVmhiR3dnS0doMGRIQTZMeTltYVhKbGQyOXlhM011WVdKbFlXeHNMbU52YlNrZ0xpQldaWEp6YVc5dU9pQXdMall1TVNBZ0xTMCtEVHdoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStEVHh6ZG1jZ2FXUTlJbFZ1ZEdsMGJHVmtMVkJoWjJVbE1qQXhJaUIyYVdWM1FtOTRQU0l3SURBZ05pQTJJaUJ6ZEhsc1pUMGlZbUZqYTJkeWIzVnVaQzFqYjJ4dmNqb2pabVptWm1abU1EQWlJSFpsY25OcGIyNDlJakV1TVNJTkNYaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhodGJEcHpjR0ZqWlQwaWNISmxjMlZ5ZG1VaURRbDRQU0l3Y0hnaUlIazlJakJ3ZUNJZ2QybGtkR2c5SWpad2VDSWdhR1ZwWjJoMFBTSTJjSGdpRFQ0TkNUeG5JRzl3WVdOcGRIazlJakF1TXpBeUlqNE5DUWs4Y0dGMGFDQmtQU0pOSURZZ05pQk1JREFnTmlCTUlEQWdOQzR5SUV3Z05DQTBMaklnVENBMExqSWdOQzR5SUV3Z05DNHlJREFnVENBMklEQWdUQ0EySURZZ1RDQTJJRFlnV2lJZ1ptbHNiRDBpSXpBd01EQXdNQ0l2UGcwSlBDOW5QZzA4TDNOMlp6ND1cXFwiKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjEwMCUgMTAwJTtwYWRkaW5nOjAgM3B4IDNweCAwO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y3Vyc29yOnNlLXJlc2l6ZX0udnVlLWdyaWQtaXRlbT4udnVlLXJ0bC1yZXNpemFibGUtaGFuZGxle2JvdHRvbTowO2xlZnQ6MDtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEF1TURBd01EQXdNREF3TURBd01EQXlJaUJvWldsbmFIUTlJakV3TGpBd01EQXdNREF3TURBd01EQXdNaUlnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLSUR3aExTMGdRM0psWVhSbFpDQjNhWFJvSUUxbGRHaHZaQ0JFY21GM0lDMGdhSFIwY0RvdkwyZHBkR2gxWWk1amIyMHZaSFZ2Y0dsNFpXd3ZUV1YwYUc5a0xVUnlZWGN2SUMwdFBnb2dQR2MrQ2lBZ1BIUnBkR3hsUG1KaFkydG5jbTkxYm1ROEwzUnBkR3hsUGdvZ0lEeHlaV04wSUdacGJHdzlJbTV2Ym1VaUlHbGtQU0pqWVc1MllYTmZZbUZqYTJkeWIzVnVaQ0lnYUdWcFoyaDBQU0l4TWlJZ2QybGtkR2c5SWpFeUlpQjVQU0l0TVNJZ2VEMGlMVEVpTHo0S0lDQThaeUJrYVhOd2JHRjVQU0p1YjI1bElpQnZkbVZ5Wm14dmR6MGlkbWx6YVdKc1pTSWdlVDBpTUNJZ2VEMGlNQ0lnYUdWcFoyaDBQU0l4TURBbElpQjNhV1IwYUQwaU1UQXdKU0lnYVdROUltTmhiblpoYzBkeWFXUWlQZ29nSUNBOGNtVmpkQ0JtYVd4c1BTSjFjbXdvSTJkeWFXUndZWFIwWlhKdUtTSWdjM1J5YjJ0bExYZHBaSFJvUFNJd0lpQjVQU0l3SWlCNFBTSXdJaUJvWldsbmFIUTlJakV3TUNVaUlIZHBaSFJvUFNJeE1EQWxJaTgrQ2lBZ1BDOW5QZ29nUEM5blBnb2dQR2MrQ2lBZ1BIUnBkR3hsUGt4aGVXVnlJREU4TDNScGRHeGxQZ29nSUR4c2FXNWxJR05oYm5aaGN6MGlJMlptWm1abVppSWdZMkZ1ZG1GekxXOXdZV05wZEhrOUlqRWlJSE4wY205clpTMXNhVzVsWTJGd1BTSjFibVJsWm1sdVpXUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGlkVzVrWldacGJtVmtJaUJwWkQwaWMzWm5YekVpSUhreVBTSXROekF1TVRjNE5EQTNJaUI0TWowaU1USTBMalEyTkRFM05TSWdlVEU5SWkwek9DNHpPVEkzTXpjaUlIZ3hQU0l4TkRRdU9ESXhNamc1SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJZ2MzUnliMnRsUFNJak1EQXdJaUJtYVd4c1BTSnViMjVsSWk4K0NpQWdQR3hwYm1VZ2MzUnliMnRsUFNJak5qWTJOalkySWlCemRISnZhMlV0YkdsdVpXTmhjRDBpZFc1a1pXWnBibVZrSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW5WdVpHVm1hVzVsWkNJZ2FXUTlJbk4yWjE4MUlpQjVNajBpT1M0eE1EWTVOVGNpSUhneVBTSXdMamswTnpJME55SWdlVEU5SWkwd0xqQXhPREV5T0NJZ2VERTlJakF1T1RRM01qUTNJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqSWlJR1pwYkd3OUltNXZibVVpTHo0S0lDQThiR2x1WlNCemRISnZhMlV0YkdsdVpXTmhjRDBpZFc1a1pXWnBibVZrSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW5WdVpHVm1hVzVsWkNJZ2FXUTlJbk4yWjE4M0lpQjVNajBpT1NJZ2VESTlJakV3TGpBM016VXlPU0lnZVRFOUlqa2lJSGd4UFNJdE1DNDJOVFUyTkNJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlU5SWlNMk5qWTJOallpSUdacGJHdzlJbTV2Ym1VaUx6NEtJRHd2Wno0S1BDOXpkbWMrKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMTAwJTtwYWRkaW5nLWxlZnQ6M3B4O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtjdXJzb3I6c3ctcmVzaXplO3JpZ2h0OmF1dG99XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9taW5pbWl6ZSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWYyZWY5Y2QyXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0dyaWRJdGVtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _utils = __webpack_require__(7);\n\nvar _draggableUtils = __webpack_require__(21);\n\n//    var eventBus = require('./eventBus');\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar interact = __webpack_require__(22);\n\nexports.default = {\n    name: \"GridItem\",\n    props: {\n        /*cols: {\n         type: Number,\n         required: true\n         },*/\n        /*containerWidth: {\n         type: Number,\n         required: true\n          },\n         rowHeight: {\n         type: Number,\n         required: true\n         },\n         margin: {\n         type: Array,\n         required: true\n         },\n         maxRows: {\n         type: Number,\n         required: true\n         },*/\n        isDraggable: {\n            type: Boolean,\n            required: false,\n            default: null\n        },\n        isResizable: {\n            type: Boolean,\n            required: false,\n            default: null\n        },\n        /*useCssTransforms: {\n         type: Boolean,\n         required: true\n         },\n         static: {\n         type: Boolean,\n         required: false,\n         default: false\n         },\n         */\n        minH: {\n            type: Number,\n            required: false,\n            default: 1\n        },\n        minW: {\n            type: Number,\n            required: false,\n            default: 1\n        },\n        maxH: {\n            type: Number,\n            required: false,\n            default: Infinity\n        },\n        maxW: {\n            type: Number,\n            required: false,\n            default: Infinity\n        },\n        x: {\n            type: Number,\n            required: true\n        },\n        y: {\n            type: Number,\n            required: true\n        },\n        w: {\n            type: Number,\n            required: true\n        },\n        h: {\n            type: Number,\n            required: true\n        },\n        i: {\n            required: true\n        },\n        dragIgnoreFrom: {\n            type: String,\n            required: false,\n            default: 'a, button'\n        },\n        dragAllowFrom: {\n            type: String,\n            required: false,\n            default: null\n        },\n        resizeIgnoreFrom: {\n            type: String,\n            required: false,\n            default: 'a, button'\n        }\n    },\n    inject: [\"eventBus\"],\n    data: function data() {\n        return {\n            cols: 1,\n            containerWidth: 100,\n            rowHeight: 30,\n            margin: [10, 10],\n            maxRows: Infinity,\n            draggable: null,\n            resizable: null,\n            useCssTransforms: true,\n\n            isDragging: false,\n            dragging: null,\n            isResizing: false,\n            resizing: null,\n            lastX: NaN,\n            lastY: NaN,\n            lastW: NaN,\n            lastH: NaN,\n            style: {},\n            rtl: false,\n\n            dragEventSet: false,\n            resizeEventSet: false,\n\n            previousW: null,\n            previousH: null,\n            previousX: null,\n            previousY: null\n        };\n    },\n    created: function created() {\n        var _this = this;\n\n        var self = this;\n\n        // Accessible refernces of functions for removing in beforeDestroy\n        self.updateWidthHandler = function (width) {\n            self.updateWidth(width);\n        };\n\n        self.compactHandler = function (layout) {\n            self.compact(layout);\n        };\n\n        self.setDraggableHandler = function (isDraggable) {\n            if (self.isDraggable === null) {\n                self.draggable = isDraggable;\n            }\n        };\n\n        self.setResizableHandler = function (isResizable) {\n            if (self.isResizable === null) {\n                self.resizable = isResizable;\n            }\n        };\n\n        self.setRowHeightHandler = function (rowHeight) {\n            self.rowHeight = rowHeight;\n        };\n\n        self.directionchangeHandler = function (direction) {\n            var direction = document.dir !== undefined ? document.dir : document.getElementsByTagName(\"html\")[0].getAttribute(\"dir\");\n            _this.rtl = direction === \"rtl\";\n            _this.compact();\n        };\n\n        this.eventBus.$on('updateWidth', self.updateWidthHandler);\n        this.eventBus.$on('compact', self.compactHandler);\n        this.eventBus.$on('setDraggable', self.setDraggableHandler);\n        this.eventBus.$on('setResizable', self.setResizableHandler);\n        this.eventBus.$on('setRowHeight', self.setRowHeightHandler);\n        this.eventBus.$on('directionchange', self.directionchangeHandler);\n\n        /*this.eventBus.$on('setColNum', function(colNum) {\n         self.cols = colNum;\n         });*/\n        var direction = document.dir !== undefined ? document.dir : document.getElementsByTagName(\"html\")[0].getAttribute(\"dir\");\n        this.rtl = direction === \"rtl\";\n    },\n\n    beforeDestroy: function beforeDestroy() {\n        var self = this;\n        //Remove listeners\n        this.eventBus.$off('updateWidth', self.updateWidthHandler);\n        this.eventBus.$off('compact', self.compactHandler);\n        this.eventBus.$off('setDraggable', self.setDraggableHandler);\n        this.eventBus.$off('setResizable', self.setResizableHandler);\n        this.eventBus.$off('setRowHeight', self.setRowHeightHandler);\n        this.eventBus.$off('directionchange', self.directionchangeHandler);\n    },\n    mounted: function mounted() {\n        this.cols = this.$parent.colNum;\n        this.rowHeight = this.$parent.rowHeight;\n        this.containerWidth = this.$parent.width !== null ? this.$parent.width : 100;\n        this.margin = this.$parent.margin !== undefined ? this.$parent.margin : [10, 10];\n        this.maxRows = this.$parent.maxRows;\n        if (this.isDraggable === null) {\n            this.draggable = this.$parent.isDraggable;\n        } else {\n            this.draggable = this.isDraggable;\n        }\n        if (this.isResizable === null) {\n            this.resizable = this.$parent.isResizable;\n        } else {\n            this.resizable = this.isResizable;\n        }\n        this.useCssTransforms = this.$parent.useCssTransforms;\n        this.createStyle();\n    },\n    watch: {\n        isDraggable: function isDraggable() {\n            this.draggable = this.isDraggable;\n        },\n        draggable: function draggable() {\n            var self = this;\n            if (this.interactObj === null || this.interactObj === undefined) {\n                this.interactObj = interact(this.$refs.item);\n            }\n            if (this.draggable) {\n                var opts = {\n                    ignoreFrom: this.dragIgnoreFrom,\n                    allowFrom: this.dragAllowFrom\n                };\n                this.interactObj.draggable(opts);\n                /*this.interactObj.draggable({allowFrom: '.vue-draggable-handle'});*/\n                if (!this.dragEventSet) {\n                    this.dragEventSet = true;\n                    this.interactObj.on('dragstart dragmove dragend', function (event) {\n                        self.handleDrag(event);\n                    });\n                }\n            } else {\n                this.interactObj.draggable({\n                    enabled: false\n                });\n            }\n        },\n        isResizable: function isResizable() {\n            this.resizable = this.isResizable;\n        },\n        resizable: function resizable() {\n            var self = this;\n            if (this.interactObj === null || this.interactObj === undefined) {\n                this.interactObj = interact(this.$refs.item);\n            }\n            if (this.resizable) {\n                var opts = {\n                    preserveAspectRatio: false,\n                    edges: { left: false, right: true, bottom: true, top: false },\n                    ignoreFrom: this.resizeIgnoreFrom\n                };\n\n                this.interactObj.resizable(opts);\n                if (!this.resizeEventSet) {\n                    this.resizeEventSet = true;\n                    this.interactObj.on('resizestart resizemove resizeend', function (event) {\n                        self.handleResize(event);\n                    });\n                }\n            } else {\n                this.interactObj.resizable({\n                    enabled: false\n                });\n            }\n        },\n        rowHeight: function rowHeight() {\n            this.createStyle();\n        },\n        cols: function cols() {\n            this.createStyle();\n        },\n        containerWidth: function containerWidth() {\n            this.createStyle();\n        },\n        x: function x() {\n            this.createStyle();\n        },\n        y: function y() {\n            this.createStyle();\n        },\n        h: function h() {\n            this.createStyle();\n        },\n        w: function w() {\n            this.createStyle();\n        },\n        renderRtl: function renderRtl() {\n            this.createStyle();\n        }\n    },\n    computed: {\n        renderRtl: function renderRtl() {\n            return this.$parent.isMirrored ? !this.rtl : this.rtl;\n        },\n        resizableHandleClass: function resizableHandleClass() {\n            if (this.renderRtl) {\n                return 'vue-resizable-handle vue-rtl-resizable-handle';\n            } else {\n                return 'vue-resizable-handle';\n            }\n        }\n    },\n    methods: {\n        createStyle: function createStyle() {\n            if (this.x + this.w > this.cols) {\n                this.x = 0;\n                this.w = this.cols;\n            }\n\n            var pos = this.calcPosition(this.x, this.y, this.w, this.h);\n\n            if (this.isDragging) {\n                pos.top = this.dragging.top;\n                //                    Add rtl support\n                if (this.renderRtl) {\n                    pos.right = this.dragging.left;\n                } else {\n                    pos.left = this.dragging.left;\n                }\n            }\n            if (this.isResizing) {\n                pos.width = this.resizing.width;\n                pos.height = this.resizing.height;\n            }\n\n            var style = void 0;\n            // CSS Transforms support (default)\n            if (this.useCssTransforms) {\n                //                    Add rtl support\n                if (this.renderRtl) {\n                    style = (0, _utils.setTransformRtl)(pos.top, pos.right, pos.width, pos.height);\n                } else {\n                    style = (0, _utils.setTransform)(pos.top, pos.left, pos.width, pos.height);\n                }\n            } else {\n                // top,left (slow)\n                //                    Add rtl support\n                if (this.renderRtl) {\n                    style = (0, _utils.setTopRight)(pos.top, pos.right, pos.width, pos.height);\n                } else {\n                    style = (0, _utils.setTopLeft)(pos.top, pos.left, pos.width, pos.height);\n                }\n            }\n            this.style = style;\n        },\n        handleResize: function handleResize(event) {\n            var position = (0, _draggableUtils.getControlPosition)(event);\n            // Get the current drag point from the event. This is used as the offset.\n            if (position == null) return; // not possible but satisfies flow\n            var x = position.x,\n                y = position.y;\n\n\n            var newSize = { width: 0, height: 0 };\n            switch (event.type) {\n                case \"resizestart\":\n                    this.previousW = this.w;\n                    this.previousH = this.h;\n                    var pos = this.calcPosition(this.x, this.y, this.w, this.h);\n                    newSize.width = pos.width;\n                    newSize.height = pos.height;\n                    this.resizing = newSize;\n                    this.isResizing = true;\n                    break;\n                case \"resizemove\":\n                    //                        console.log(\"### resize => \" + event.type + \", lastW=\" + this.lastW + \", lastH=\" + this.lastH);\n                    var coreEvent = (0, _draggableUtils.createCoreData)(this.lastW, this.lastH, x, y);\n                    if (this.renderRtl) {\n                        newSize.width = this.resizing.width - coreEvent.deltaX;\n                    } else {\n                        newSize.width = this.resizing.width + coreEvent.deltaX;\n                    }\n                    newSize.height = this.resizing.height + coreEvent.deltaY;\n\n                    ///console.log(\"### resize => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\n                    this.resizing = newSize;\n                    break;\n                case \"resizeend\":\n                    //console.log(\"### resize end => x=\" +this.x + \" y=\" + this.y + \" w=\" + this.w + \" h=\" + this.h);\n                    var pos = this.calcPosition(this.x, this.y, this.w, this.h);\n                    newSize.width = pos.width;\n                    newSize.height = pos.height;\n                    //                        console.log(\"### resize end => \" + JSON.stringify(newSize));\n                    this.resizing = null;\n                    this.isResizing = false;\n                    break;\n            }\n\n            // Get new WH\n            var pos = this.calcWH(newSize.height, newSize.width);\n            if (pos.w < this.minW) {\n                pos.w = this.minW;\n            }\n            if (pos.w > this.maxW) {\n                pos.w = this.maxW;\n            }\n            if (pos.h < this.minH) {\n                pos.h = this.minH;\n            }\n            if (pos.h > this.maxH) {\n                pos.h = this.maxH;\n            }\n\n            if (pos.h < 1) {\n                pos.h = 1;\n            }\n            if (pos.w < 1) {\n                pos.w = 1;\n            }\n\n            this.lastW = x;\n            this.lastH = y;\n\n            if (this.w !== pos.w || this.h !== pos.h) {\n                this.$emit(\"resize\", this.i, pos.h, pos.w);\n            }\n            if (event.type === \"resizeend\" && (this.previousW !== this.w || this.previousH !== this.h)) {\n                this.$emit(\"resized\", this.i, pos.h, pos.w, newSize.height, newSize.width);\n            }\n            this.eventBus.$emit(\"resizeEvent\", event.type, this.i, this.x, this.y, pos.h, pos.w);\n        },\n        handleDrag: function handleDrag(event) {\n            if (this.isResizing) return;\n\n            var position = (0, _draggableUtils.getControlPosition)(event);\n\n            // Get the current drag point from the event. This is used as the offset.\n            if (position === null) return; // not possible but satisfies flow\n            var x = position.x,\n                y = position.y;\n\n\n            var shouldUpdate = false;\n            var newPosition = { top: 0, left: 0 };\n            switch (event.type) {\n                case \"dragstart\":\n                    this.previousX = this.x;\n                    this.previousY = this.y;\n\n                    var parentRect = event.target.offsetParent.getBoundingClientRect();\n                    var clientRect = event.target.getBoundingClientRect();\n                    if (this.renderRtl) {\n                        newPosition.left = (clientRect.right - parentRect.right) * -1;\n                    } else {\n                        newPosition.left = clientRect.left - parentRect.left;\n                    }\n                    newPosition.top = clientRect.top - parentRect.top;\n                    this.dragging = newPosition;\n                    this.isDragging = true;\n                    break;\n                case \"dragend\":\n                    if (!this.isDragging) return;\n                    parentRect = event.target.offsetParent.getBoundingClientRect();\n                    clientRect = event.target.getBoundingClientRect();\n                    //                        Add rtl support\n                    if (this.renderRtl) {\n                        newPosition.left = (clientRect.right - parentRect.right) * -1;\n                    } else {\n                        newPosition.left = clientRect.left - parentRect.left;\n                    }\n                    newPosition.top = clientRect.top - parentRect.top;\n                    //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\n                    //                        console.log(\"### DROP: \" + JSON.stringify(newPosition));\n                    this.dragging = null;\n                    this.isDragging = false;\n                    shouldUpdate = true;\n                    break;\n                case \"dragmove\":\n                    var coreEvent = (0, _draggableUtils.createCoreData)(this.lastX, this.lastY, x, y);\n                    //                        Add rtl support\n                    if (this.renderRtl) {\n                        newPosition.left = this.dragging.left - coreEvent.deltaX;\n                    } else {\n                        newPosition.left = this.dragging.left + coreEvent.deltaX;\n                    }\n                    newPosition.top = this.dragging.top + coreEvent.deltaY;\n                    //                        console.log(\"### drag => \" + event.type + \", x=\" + x + \", y=\" + y);\n                    //                        console.log(\"### drag => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\n                    //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\n                    this.dragging = newPosition;\n                    break;\n            }\n\n            // Get new XY\n            if (this.renderRtl) {\n                var pos = this.calcXY(newPosition.top, newPosition.left);\n            } else {\n                var pos = this.calcXY(newPosition.top, newPosition.left);\n            }\n\n            this.lastX = x;\n            this.lastY = y;\n\n            if (this.x !== pos.x || this.y !== pos.y) {\n                this.$emit(\"move\", this.i, pos.x, pos.y);\n            }\n            if (event.type === \"dragend\" && (this.previousX !== this.x || this.previousY !== this.y)) {\n                this.$emit(\"moved\", this.i, pos.x, pos.y);\n            }\n            this.eventBus.$emit(\"dragEvent\", event.type, this.i, pos.x, pos.y, this.h, this.w);\n        },\n\n        calcPosition: function calcPosition(x, y, w, h) {\n            var colWidth = this.calcColWidth();\n            // add rtl support\n            if (this.renderRtl) {\n                var out = {\n                    right: Math.round(colWidth * x + (x + 1) * this.margin[0]),\n                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\n                    // 0 * Infinity === NaN, which causes problems with resize constriants;\n                    // Fix this if it occurs.\n                    // Note we do it here rather than later because Math.round(Infinity) causes deopt\n                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\n                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])\n                };\n            } else {\n                var out = {\n                    left: Math.round(colWidth * x + (x + 1) * this.margin[0]),\n                    top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\n                    // 0 * Infinity === NaN, which causes problems with resize constriants;\n                    // Fix this if it occurs.\n                    // Note we do it here rather than later because Math.round(Infinity) causes deopt\n                    width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\n                    height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])\n                };\n            }\n\n            return out;\n        },\n        /**\n         * Translate x and y coordinates from pixels to grid units.\n         * @param  {Number} top  Top position (relative to parent) in pixels.\n         * @param  {Number} left Left position (relative to parent) in pixels.\n         * @return {Object} x and y in grid units.\n         */\n        // TODO check if this function needs change in order to support rtl.\n        calcXY: function calcXY(top, left) {\n            var colWidth = this.calcColWidth();\n\n            // left = colWidth * x + margin * (x + 1)\n            // l = cx + m(x+1)\n            // l = cx + mx + m\n            // l - m = cx + mx\n            // l - m = x(c + m)\n            // (l - m) / (c + m) = x\n            // x = (left - margin) / (coldWidth + margin)\n            var x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));\n            var y = Math.round((top - this.margin[1]) / (this.rowHeight + this.margin[1]));\n\n            // Capping\n            x = Math.max(Math.min(x, this.cols - this.w), 0);\n            y = Math.max(Math.min(y, this.maxRows - this.h), 0);\n\n            return { x: x, y: y };\n        },\n\n        // Helper for generating column width\n        calcColWidth: function calcColWidth() {\n            var colWidth = (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;\n            //                console.log(\"### COLS=\" + this.cols + \" COL WIDTH=\" + colWidth);\n            return colWidth;\n        },\n\n\n        /**\n         * Given a height and width in pixel values, calculate grid units.\n         * @param  {Number} height Height in pixels.\n         * @param  {Number} width  Width in pixels.\n         * @return {Object} w, h as grid units.\n         */\n        calcWH: function calcWH(height, width) {\n            var colWidth = this.calcColWidth();\n\n            // width = colWidth * w - (margin * (w - 1))\n            // ...\n            // w = (width + margin) / (colWidth + margin)\n            var w = Math.round((width + this.margin[0]) / (colWidth + this.margin[0]));\n            var h = Math.round((height + this.margin[1]) / (this.rowHeight + this.margin[1]));\n\n            // Capping\n            w = Math.max(Math.min(w, this.cols - this.x), 0);\n            h = Math.max(Math.min(h, this.maxRows - this.y), 0);\n            return { w: w, h: h };\n        },\n\n        updateWidth: function updateWidth(width, colNum) {\n            this.containerWidth = width;\n            if (colNum !== undefined && colNum !== null) {\n                this.cols = colNum;\n            }\n        },\n        compact: function compact() {\n            this.createStyle();\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vR3JpZEl0ZW0udnVlPzdhMTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQWdGQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUpBOzttQ0FNQTs7O1VBRUE7O0FBS0E7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQUVBO3NCQUNBO3FCQUVBO0FBSkE7O2tCQU1BO3NCQUNBO3FCQUVBO0FBSkE7QUFjQTs7Ozs7Ozs7Ozs7a0JBRUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBRUE7QUFIQTs7a0JBS0E7c0JBRUE7QUFIQTs7a0JBS0E7c0JBRUE7QUFIQTs7a0JBS0E7c0JBRUE7QUFIQTs7c0JBTUE7QUFGQTs7a0JBSUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBQ0E7cUJBRUE7QUFKQTs7a0JBTUE7c0JBQ0E7cUJBR0E7QUFMQTtBQTNGQTthQWlHQTswQkFDQTs7a0JBRUE7NEJBQ0E7dUJBQ0E7eUJBQ0E7cUJBQ0E7dUJBQ0E7dUJBQ0E7OEJBRUE7O3dCQUNBO3NCQUNBO3dCQUNBO3NCQUNBO21CQUNBO21CQUNBO21CQUNBO21CQUNBO21CQUNBO2lCQUVBOzswQkFDQTs0QkFFQTs7dUJBQ0E7dUJBQ0E7dUJBQ0E7dUJBRUE7QUE1QkE7QUE2QkE7O0FBQ0E7O21CQUVBOztBQUNBO21EQUNBOzZCQUNBO0FBRUE7O2dEQUNBO3lCQUNBO0FBRUE7OzBEQUNBOzJDQUNBO2lDQUNBO0FBQ0E7QUFFQTs7MERBQ0E7MkNBQ0E7aUNBQ0E7QUFDQTtBQUVBOzt3REFDQTs2QkFDQTtBQUVBOzsyREFDQTs2Q0FDQSxxQkFDQSw0REFDQTtzQ0FDQTtrQkFDQTtBQUVBOzs4Q0FDQTsw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O0FBQ0E7QUFDQTtBQUNBOzJHQUNBO2tIQUVBO0FBUkE7QUFXQTs7bUJBQ0E7QUFDQTtBQU1BOzs7Ozs7QUFDQTsyQ0FDQTtnQ0FFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtpRkFDQTtzRkFFQTs7QUFDQTswREFDQTs2REFFQTs7MkJBQ0E7QUFDQTs7QUFDQTs4Q0FDQTs7QUFFQTttQkFDQTtBQUVBOzs7QUFNQTs7Ozs7OytDQUNBO2dDQUVBOztBQUNBO0FBQ0E7QUFDQTtrRkFDQTt5RkFFQTs7QUFDQTswREFDQTs2REFDQTsyQkFDQTtBQUNBOzt5REFDQTtrQ0FDQTt5REFDQTs0QkFDQTtBQUNBO0FBQ0E7b0NBQ0E7aUJBQ0E7QUFFQTtBQTlSQTtBQWpUQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxkaXYgcmVmPVwiaXRlbVwiXHJcbiAgICAgICAgIGNsYXNzPVwidnVlLWdyaWQtaXRlbVwiXHJcbiAgICAgICAgIDpjbGFzcz1cInsgJ3Z1ZS1yZXNpemFibGUnIDogcmVzaXphYmxlLCAncmVzaXppbmcnIDogaXNSZXNpemluZywgJ3Z1ZS1kcmFnZ2FibGUtZHJhZ2dpbmcnIDogaXNEcmFnZ2luZywgJ2Nzc1RyYW5zZm9ybXMnIDogdXNlQ3NzVHJhbnNmb3JtcywgJ3JlbmRlci1ydGwnIDogcmVuZGVyUnRsIH1cIlxyXG4gICAgICAgICA6c3R5bGU9XCJzdHlsZVwiXHJcbiAgICA+XHJcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgICAgIDxzcGFuIHYtaWY9XCJyZXNpemFibGVcIiByZWY9XCJoYW5kbGVcIiA6Y2xhc3M9XCJyZXNpemFibGVIYW5kbGVDbGFzc1wiPjwvc3Bhbj5cclxuICAgICAgICA8IS0tPHNwYW4gdi1pZj1cImRyYWdnYWJsZVwiIHJlZj1cImRyYWdIYW5kbGVcIiBjbGFzcz1cInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCI+PC9zcGFuPi0tPlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzdHlsZT5cclxuICAgIC52dWUtZ3JpZC1pdGVtIHtcclxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMjAwbXMgZWFzZTtcclxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBsZWZ0LCB0b3AsIHJpZ2h0O1xyXG4gICAgICAgIC8qIGFkZCByaWdodCBmb3IgcnRsICovXHJcbiAgICB9XHJcblxyXG4gICAgLnZ1ZS1ncmlkLWl0ZW0uY3NzVHJhbnNmb3JtcyB7XHJcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xyXG4gICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgcmlnaHQ6IGF1dG87XHJcbiAgICB9XHJcblxyXG4gICAgLnZ1ZS1ncmlkLWl0ZW0uY3NzVHJhbnNmb3Jtcy5yZW5kZXItcnRsIHtcclxuICAgICAgICBsZWZ0OiBhdXRvO1xyXG4gICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC52dWUtZ3JpZC1pdGVtLnJlc2l6aW5nIHtcclxuICAgICAgICBvcGFjaXR5OiAwLjY7XHJcbiAgICAgICAgei1pbmRleDogMztcclxuICAgIH1cclxuXHJcbiAgICAudnVlLWdyaWQtaXRlbS52dWUtZHJhZ2dhYmxlLWRyYWdnaW5nIHtcclxuICAgICAgICB0cmFuc2l0aW9uOm5vbmU7XHJcbiAgICAgICAgei1pbmRleDogMztcclxuICAgIH1cclxuXHJcbiAgICAudnVlLWdyaWQtaXRlbS52dWUtZ3JpZC1wbGFjZWhvbGRlciB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xyXG4gICAgICAgIG9wYWNpdHk6IDAuMjtcclxuICAgICAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxMDBtcztcclxuICAgICAgICB6LWluZGV4OiAyO1xyXG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgLW8tdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLnZ1ZS1ncmlkLWl0ZW0gPiAudnVlLXJlc2l6YWJsZS1oYW5kbGUge1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB3aWR0aDogMjBweDtcclxuICAgICAgICBoZWlnaHQ6IDIwcHg7XHJcbiAgICAgICAgYm90dG9tOiAwO1xyXG4gICAgICAgIHJpZ2h0OiAwO1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHVybCgnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJ6ZEdGdVpHRnNiMjVsUFNKdWJ5SS9QZzA4SVMwdElFZGxibVZ5WVhSdmNqb2dRV1J2WW1VZ1JtbHlaWGR2Y210eklFTlROaXdnUlhod2IzSjBJRk5XUnlCRmVIUmxibk5wYjI0Z1lua2dRV0Z5YjI0Z1FtVmhiR3dnS0doMGRIQTZMeTltYVhKbGQyOXlhM011WVdKbFlXeHNMbU52YlNrZ0xpQldaWEp6YVc5dU9pQXdMall1TVNBZ0xTMCtEVHdoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStEVHh6ZG1jZ2FXUTlJbFZ1ZEdsMGJHVmtMVkJoWjJVbE1qQXhJaUIyYVdWM1FtOTRQU0l3SURBZ05pQTJJaUJ6ZEhsc1pUMGlZbUZqYTJkeWIzVnVaQzFqYjJ4dmNqb2pabVptWm1abU1EQWlJSFpsY25OcGIyNDlJakV1TVNJTkNYaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhodGJEcHpjR0ZqWlQwaWNISmxjMlZ5ZG1VaURRbDRQU0l3Y0hnaUlIazlJakJ3ZUNJZ2QybGtkR2c5SWpad2VDSWdhR1ZwWjJoMFBTSTJjSGdpRFQ0TkNUeG5JRzl3WVdOcGRIazlJakF1TXpBeUlqNE5DUWs4Y0dGMGFDQmtQU0pOSURZZ05pQk1JREFnTmlCTUlEQWdOQzR5SUV3Z05DQTBMaklnVENBMExqSWdOQzR5SUV3Z05DNHlJREFnVENBMklEQWdUQ0EySURZZ1RDQTJJRFlnV2lJZ1ptbHNiRDBpSXpBd01EQXdNQ0l2UGcwSlBDOW5QZzA4TDNOMlp6ND0nKTtcclxuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gcmlnaHQ7XHJcbiAgICAgICAgcGFkZGluZzogMCAzcHggM3B4IDA7XHJcbiAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcclxuICAgICAgICBiYWNrZ3JvdW5kLW9yaWdpbjogY29udGVudC1ib3g7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBjdXJzb3I6IHNlLXJlc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAudnVlLWdyaWQtaXRlbSA+IC52dWUtcnRsLXJlc2l6YWJsZS1oYW5kbGUge1xyXG4gICAgICAgIGJvdHRvbTogMDtcclxuICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEF1TURBd01EQXdNREF3TURBd01EQXlJaUJvWldsbmFIUTlJakV3TGpBd01EQXdNREF3TURBd01EQXdNaUlnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLSUR3aExTMGdRM0psWVhSbFpDQjNhWFJvSUUxbGRHaHZaQ0JFY21GM0lDMGdhSFIwY0RvdkwyZHBkR2gxWWk1amIyMHZaSFZ2Y0dsNFpXd3ZUV1YwYUc5a0xVUnlZWGN2SUMwdFBnb2dQR2MrQ2lBZ1BIUnBkR3hsUG1KaFkydG5jbTkxYm1ROEwzUnBkR3hsUGdvZ0lEeHlaV04wSUdacGJHdzlJbTV2Ym1VaUlHbGtQU0pqWVc1MllYTmZZbUZqYTJkeWIzVnVaQ0lnYUdWcFoyaDBQU0l4TWlJZ2QybGtkR2c5SWpFeUlpQjVQU0l0TVNJZ2VEMGlMVEVpTHo0S0lDQThaeUJrYVhOd2JHRjVQU0p1YjI1bElpQnZkbVZ5Wm14dmR6MGlkbWx6YVdKc1pTSWdlVDBpTUNJZ2VEMGlNQ0lnYUdWcFoyaDBQU0l4TURBbElpQjNhV1IwYUQwaU1UQXdKU0lnYVdROUltTmhiblpoYzBkeWFXUWlQZ29nSUNBOGNtVmpkQ0JtYVd4c1BTSjFjbXdvSTJkeWFXUndZWFIwWlhKdUtTSWdjM1J5YjJ0bExYZHBaSFJvUFNJd0lpQjVQU0l3SWlCNFBTSXdJaUJvWldsbmFIUTlJakV3TUNVaUlIZHBaSFJvUFNJeE1EQWxJaTgrQ2lBZ1BDOW5QZ29nUEM5blBnb2dQR2MrQ2lBZ1BIUnBkR3hsUGt4aGVXVnlJREU4TDNScGRHeGxQZ29nSUR4c2FXNWxJR05oYm5aaGN6MGlJMlptWm1abVppSWdZMkZ1ZG1GekxXOXdZV05wZEhrOUlqRWlJSE4wY205clpTMXNhVzVsWTJGd1BTSjFibVJsWm1sdVpXUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGlkVzVrWldacGJtVmtJaUJwWkQwaWMzWm5YekVpSUhreVBTSXROekF1TVRjNE5EQTNJaUI0TWowaU1USTBMalEyTkRFM05TSWdlVEU5SWkwek9DNHpPVEkzTXpjaUlIZ3hQU0l4TkRRdU9ESXhNamc1SWlCemRISnZhMlV0ZDJsa2RHZzlJakV1TlNJZ2MzUnliMnRsUFNJak1EQXdJaUJtYVd4c1BTSnViMjVsSWk4K0NpQWdQR3hwYm1VZ2MzUnliMnRsUFNJak5qWTJOalkySWlCemRISnZhMlV0YkdsdVpXTmhjRDBpZFc1a1pXWnBibVZrSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW5WdVpHVm1hVzVsWkNJZ2FXUTlJbk4yWjE4MUlpQjVNajBpT1M0eE1EWTVOVGNpSUhneVBTSXdMamswTnpJME55SWdlVEU5SWkwd0xqQXhPREV5T0NJZ2VERTlJakF1T1RRM01qUTNJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqSWlJR1pwYkd3OUltNXZibVVpTHo0S0lDQThiR2x1WlNCemRISnZhMlV0YkdsdVpXTmhjRDBpZFc1a1pXWnBibVZrSWlCemRISnZhMlV0YkdsdVpXcHZhVzQ5SW5WdVpHVm1hVzVsWkNJZ2FXUTlJbk4yWjE4M0lpQjVNajBpT1NJZ2VESTlJakV3TGpBM016VXlPU0lnZVRFOUlqa2lJSGd4UFNJdE1DNDJOVFUyTkNJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlU5SWlNMk5qWTJOallpSUdacGJHdzlJbTV2Ym1VaUx6NEtJRHd2Wno0S1BDOXpkbWMrKTtcclxuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gbGVmdDtcclxuICAgICAgICBwYWRkaW5nLWxlZnQ6IDNweDtcclxuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xyXG4gICAgICAgIGJhY2tncm91bmQtb3JpZ2luOiBjb250ZW50LWJveDtcclxuICAgICAgICBjdXJzb3I6IHN3LXJlc2l6ZTtcclxuICAgICAgICByaWdodDogYXV0bztcclxuICAgIH1cclxuPC9zdHlsZT5cclxuPHNjcmlwdD5cclxuICAgIGltcG9ydCB7c2V0VG9wTGVmdCwgc2V0VG9wUmlnaHQsIHNldFRyYW5zZm9ybVJ0bCwgc2V0VHJhbnNmb3JtLCBjcmVhdGVNYXJrdXAsIGdldExheW91dEl0ZW19IGZyb20gJy4vdXRpbHMnO1xyXG4gICAgaW1wb3J0IHtnZXRDb250cm9sUG9zaXRpb24sIG9mZnNldFhZRnJvbVBhcmVudE9mLCBjcmVhdGVDb3JlRGF0YX0gZnJvbSAnLi9kcmFnZ2FibGVVdGlscyc7XHJcbiAgICAvLyAgICB2YXIgZXZlbnRCdXMgPSByZXF1aXJlKCcuL2V2ZW50QnVzJyk7XHJcblxyXG4gICAgdmFyIGludGVyYWN0ID0gcmVxdWlyZShcImludGVyYWN0anNcIik7XHJcblxyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICAgIG5hbWU6IFwiR3JpZEl0ZW1cIixcclxuICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAvKmNvbHM6IHtcclxuICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICB9LCovXHJcbiAgICAgICAgICAgIC8qY29udGFpbmVyV2lkdGg6IHtcclxuICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcblxyXG4gICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgIHJvd0hlaWdodDoge1xyXG4gICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICBtYXJnaW46IHtcclxuICAgICAgICAgICAgIHR5cGU6IEFycmF5LFxyXG4gICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICBtYXhSb3dzOiB7XHJcbiAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgfSwqL1xyXG4gICAgICAgICAgICBpc0RyYWdnYWJsZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNSZXNpemFibGU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qdXNlQ3NzVHJhbnNmb3Jtczoge1xyXG4gICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgc3RhdGljOiB7XHJcbiAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBtaW5IOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1pblc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF4SDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogSW5maW5pdHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF4Vzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogSW5maW5pdHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaToge1xyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ0lnbm9yZUZyb206IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdhLCBidXR0b24nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdBbGxvd0Zyb206IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzaXplSWdub3JlRnJvbToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogJ2EsIGJ1dHRvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluamVjdDogW1wiZXZlbnRCdXNcIl0sXHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY29sczogMSxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiAxMDAsXHJcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IDMwLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiBbMTAsIDEwXSxcclxuICAgICAgICAgICAgICAgIG1heFJvd3M6IEluZmluaXR5LFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVzaXphYmxlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdXNlQ3NzVHJhbnNmb3JtczogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaXNSZXNpemluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXNpemluZzogbnVsbCxcclxuICAgICAgICAgICAgICAgIGxhc3RYOiBOYU4sXHJcbiAgICAgICAgICAgICAgICBsYXN0WTogTmFOLFxyXG4gICAgICAgICAgICAgICAgbGFzdFc6IE5hTixcclxuICAgICAgICAgICAgICAgIGxhc3RIOiBOYU4sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge30sXHJcbiAgICAgICAgICAgICAgICBydGw6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgICAgIGRyYWdFdmVudFNldDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXNpemVFdmVudFNldDogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNXOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNIOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNYOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNZOiBudWxsLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVkICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gQWNjZXNzaWJsZSByZWZlcm5jZXMgb2YgZnVuY3Rpb25zIGZvciByZW1vdmluZyBpbiBiZWZvcmVEZXN0cm95XHJcbiAgICAgICAgICAgIHNlbGYudXBkYXRlV2lkdGhIYW5kbGVyID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVdpZHRoKHdpZHRoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuY29tcGFjdEhhbmRsZXIgPSBmdW5jdGlvbiAobGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBhY3QobGF5b3V0KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuc2V0RHJhZ2dhYmxlSGFuZGxlciA9IGZ1bmN0aW9uIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNEcmFnZ2FibGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRyYWdnYWJsZSA9IGlzRHJhZ2dhYmxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2VsZi5zZXRSZXNpemFibGVIYW5kbGVyID0gZnVuY3Rpb24gKGlzUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc1Jlc2l6YWJsZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVzaXphYmxlID0gaXNSZXNpemFibGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBzZWxmLnNldFJvd0hlaWdodEhhbmRsZXIgPSBmdW5jdGlvbiAocm93SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvd0hlaWdodCA9IHJvd0hlaWdodDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuZGlyZWN0aW9uY2hhbmdlSGFuZGxlciA9IChkaXJlY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSAoZG9jdW1lbnQuZGlyICE9PSB1bmRlZmluZWQpID9cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXIgOlxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXS5nZXRBdHRyaWJ1dGUoXCJkaXJcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ0bCA9IChkaXJlY3Rpb24gPT09IFwicnRsXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYWN0KCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvbigndXBkYXRlV2lkdGgnLCBzZWxmLnVwZGF0ZVdpZHRoSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9uKCdjb21wYWN0Jywgc2VsZi5jb21wYWN0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9uKCdzZXREcmFnZ2FibGUnLCBzZWxmLnNldERyYWdnYWJsZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvbignc2V0UmVzaXphYmxlJywgc2VsZi5zZXRSZXNpemFibGVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kb24oJ3NldFJvd0hlaWdodCcsIHNlbGYuc2V0Um93SGVpZ2h0SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9uKCdkaXJlY3Rpb25jaGFuZ2UnLCBzZWxmLmRpcmVjdGlvbmNoYW5nZUhhbmRsZXIpO1xyXG5cclxuICAgICAgICAgICAgLyp0aGlzLmV2ZW50QnVzLiRvbignc2V0Q29sTnVtJywgZnVuY3Rpb24oY29sTnVtKSB7XHJcbiAgICAgICAgICAgICBzZWxmLmNvbHMgPSBjb2xOdW07XHJcbiAgICAgICAgICAgICB9KTsqL1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gKGRvY3VtZW50LmRpciAhPT0gdW5kZWZpbmVkKSA/XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXIgOlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJodG1sXCIpWzBdLmdldEF0dHJpYnV0ZShcImRpclwiKTtcclxuICAgICAgICAgICAgdGhpcy5ydGwgPSAoZGlyZWN0aW9uID09PSBcInJ0bFwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgLy9SZW1vdmUgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9mZigndXBkYXRlV2lkdGgnLCBzZWxmLnVwZGF0ZVdpZHRoSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9mZignY29tcGFjdCcsIHNlbGYuY29tcGFjdEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ3NldERyYWdnYWJsZScsIHNlbGYuc2V0RHJhZ2dhYmxlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJG9mZignc2V0UmVzaXphYmxlJywgc2VsZi5zZXRSZXNpemFibGVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kb2ZmKCdzZXRSb3dIZWlnaHQnLCBzZWxmLnNldFJvd0hlaWdodEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ2RpcmVjdGlvbmNoYW5nZScsIHNlbGYuZGlyZWN0aW9uY2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29scyA9IHRoaXMuJHBhcmVudC5jb2xOdW07XHJcbiAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0ID0gdGhpcy4kcGFyZW50LnJvd0hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJXaWR0aCA9IHRoaXMuJHBhcmVudC53aWR0aCAhPT0gbnVsbCA/IHRoaXMuJHBhcmVudC53aWR0aCA6IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5tYXJnaW4gPSB0aGlzLiRwYXJlbnQubWFyZ2luICE9PSB1bmRlZmluZWQgPyB0aGlzLiRwYXJlbnQubWFyZ2luIDogWzEwLCAxMF07XHJcbiAgICAgICAgICAgIHRoaXMubWF4Um93cyA9IHRoaXMuJHBhcmVudC5tYXhSb3dzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnYWJsZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0aGlzLiRwYXJlbnQuaXNEcmFnZ2FibGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRoaXMuaXNEcmFnZ2FibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNpemFibGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXphYmxlID0gdGhpcy4kcGFyZW50LmlzUmVzaXphYmxlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemFibGUgPSB0aGlzLmlzUmVzaXphYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXNlQ3NzVHJhbnNmb3JtcyA9IHRoaXMuJHBhcmVudC51c2VDc3NUcmFuc2Zvcm1zO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXRjaDoge1xyXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0aGlzLmlzRHJhZ2dhYmxlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0T2JqID09PSBudWxsIHx8IHRoaXMuaW50ZXJhY3RPYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmogPSBpbnRlcmFjdCh0aGlzLiRyZWZzLml0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZUZyb206IHRoaXMuZHJhZ0lnbm9yZUZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93RnJvbTogdGhpcy5kcmFnQWxsb3dGcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmouZHJhZ2dhYmxlKG9wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qdGhpcy5pbnRlcmFjdE9iai5kcmFnZ2FibGUoe2FsbG93RnJvbTogJy52dWUtZHJhZ2dhYmxlLWhhbmRsZSd9KTsqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kcmFnRXZlbnRTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRXZlbnRTZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0T2JqLm9uKCdkcmFnc3RhcnQgZHJhZ21vdmUgZHJhZ2VuZCcsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVEcmFnKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0T2JqLmRyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzUmVzaXphYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6YWJsZSA9IHRoaXMuaXNSZXNpemFibGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2l6YWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RPYmogPT09IG51bGwgfHwgdGhpcy5pbnRlcmFjdE9iaiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdE9iaiA9IGludGVyYWN0KHRoaXMuJHJlZnMuaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNpemFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzOiB7bGVmdDogZmFsc2UsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIHRvcDogZmFsc2V9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVGcm9tOiB0aGlzLnJlc2l6ZUlnbm9yZUZyb21cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmoucmVzaXphYmxlKG9wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVFdmVudFNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUV2ZW50U2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdE9ialxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdyZXNpemVzdGFydCByZXNpemVtb3ZlIHJlc2l6ZWVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlUmVzaXplKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdE9iai5yZXNpemFibGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByb3dIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29sczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250YWluZXJXaWR0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlbmRlclJ0bDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgICByZW5kZXJSdGwoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuJHBhcmVudC5pc01pcnJvcmVkKSA/ICF0aGlzLnJ0bCA6IHRoaXMucnRsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNpemFibGVIYW5kbGVDbGFzcygpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndnVlLXJlc2l6YWJsZS1oYW5kbGUgdnVlLXJ0bC1yZXNpemFibGUtaGFuZGxlJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd2dWUtcmVzaXphYmxlLWhhbmRsZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgY3JlYXRlU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnggKyB0aGlzLncgPiB0aGlzLmNvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudyA9IHRoaXMuY29scztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5jYWxjUG9zaXRpb24odGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zLnRvcCA9IHRoaXMuZHJhZ2dpbmcudG9wO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgQWRkIHJ0bCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5yaWdodCA9IHRoaXMuZHJhZ2dpbmcubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MubGVmdCA9IHRoaXMuZHJhZ2dpbmcubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1Jlc2l6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zLndpZHRoID0gdGhpcy5yZXNpemluZy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBwb3MuaGVpZ2h0ID0gdGhpcy5yZXNpemluZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlO1xyXG4gICAgICAgICAgICAgICAgLy8gQ1NTIFRyYW5zZm9ybXMgc3VwcG9ydCAoZGVmYXVsdClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZUNzc1RyYW5zZm9ybXMpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgIEFkZCBydGwgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHNldFRyYW5zZm9ybVJ0bChwb3MudG9wLCBwb3MucmlnaHQsIHBvcy53aWR0aCwgcG9zLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBzZXRUcmFuc2Zvcm0ocG9zLnRvcCwgcG9zLmxlZnQsIHBvcy53aWR0aCwgcG9zLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHRvcCxsZWZ0IChzbG93KVxyXG4vLyAgICAgICAgICAgICAgICAgICAgQWRkIHJ0bCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gc2V0VG9wUmlnaHQocG9zLnRvcCwgcG9zLnJpZ2h0LCBwb3Mud2lkdGgsIHBvcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gc2V0VG9wTGVmdChwb3MudG9wLCBwb3MubGVmdCwgcG9zLndpZHRoLCBwb3MuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYW5kbGVSZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRDb250cm9sUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3gsIHl9ID0gcG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNpemVzdGFydFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzVyA9IHRoaXMudztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0ggPSB0aGlzLmg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNhbGNQb3NpdGlvbih0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTaXplLndpZHRoID0gcG9zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTaXplLmhlaWdodCA9IHBvcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSBuZXdTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVzaXplbW92ZVwiOlxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIHJlc2l6ZSA9PiBcIiArIGV2ZW50LnR5cGUgKyBcIiwgbGFzdFc9XCIgKyB0aGlzLmxhc3RXICsgXCIsIGxhc3RIPVwiICsgdGhpcy5sYXN0SCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcmVFdmVudCA9IGNyZWF0ZUNvcmVEYXRhKHRoaXMubGFzdFcsIHRoaXMubGFzdEgsIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJSdGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NpemUud2lkdGggPSB0aGlzLnJlc2l6aW5nLndpZHRoIC0gY29yZUV2ZW50LmRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NpemUud2lkdGggPSB0aGlzLnJlc2l6aW5nLndpZHRoICsgY29yZUV2ZW50LmRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTaXplLmhlaWdodCA9IHRoaXMucmVzaXppbmcuaGVpZ2h0ICsgY29yZUV2ZW50LmRlbHRhWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vL2NvbnNvbGUubG9nKFwiIyMjIHJlc2l6ZSA9PiBcIiArIGV2ZW50LnR5cGUgKyBcIiwgZGVsdGFYPVwiICsgY29yZUV2ZW50LmRlbHRhWCArIFwiLCBkZWx0YVk9XCIgKyBjb3JlRXZlbnQuZGVsdGFZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IG5ld1NpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNpemVlbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIiMjIyByZXNpemUgZW5kID0+IHg9XCIgK3RoaXMueCArIFwiIHk9XCIgKyB0aGlzLnkgKyBcIiB3PVwiICsgdGhpcy53ICsgXCIgaD1cIiArIHRoaXMuaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNhbGNQb3NpdGlvbih0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTaXplLndpZHRoID0gcG9zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTaXplLmhlaWdodCA9IHBvcy5oZWlnaHQ7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgcmVzaXplIGVuZCA9PiBcIiArIEpTT04uc3RyaW5naWZ5KG5ld1NpemUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgbmV3IFdIXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5jYWxjV0gobmV3U2l6ZS5oZWlnaHQsIG5ld1NpemUud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcy53IDwgdGhpcy5taW5XKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zLncgPSB0aGlzLm1pblc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zLncgPiB0aGlzLm1heFcpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3MudyA9IHRoaXMubWF4VztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3MuaCA8IHRoaXMubWluSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcy5oID0gdGhpcy5taW5IO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvcy5oID4gdGhpcy5tYXhIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zLmggPSB0aGlzLm1heEg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvcy5oIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcy5oID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3MudyA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3MudyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VyA9IHg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RIID0geTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53ICE9PSBwb3MudyB8fCB0aGlzLmggIT09IHBvcy5oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdChcInJlc2l6ZVwiLCB0aGlzLmksIHBvcy5oLCBwb3Mudyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJyZXNpemVlbmRcIiAmJiAodGhpcy5wcmV2aW91c1cgIT09IHRoaXMudyB8fCB0aGlzLnByZXZpb3VzSCAhPT0gdGhpcy5oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVkXCIsIHRoaXMuaSwgcG9zLmgsIHBvcy53LCBuZXdTaXplLmhlaWdodCwgbmV3U2l6ZS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRlbWl0KFwicmVzaXplRXZlbnRcIiwgZXZlbnQudHlwZSwgdGhpcy5pLCB0aGlzLngsIHRoaXMueSwgcG9zLmgsIHBvcy53KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlRHJhZyhldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNpemluZykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3gsIHl9ID0gcG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB7dG9wOiAwLCBsZWZ0OiAwfTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1ggPSB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNZID0gdGhpcy55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFJlY3QgPSBldmVudC50YXJnZXQub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gKGNsaWVudFJlY3QucmlnaHQgLSBwYXJlbnRSZWN0LnJpZ2h0KSAqIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zaXRpb24ubGVmdCA9IGNsaWVudFJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbi50b3AgPSBjbGllbnRSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkcmFnZW5kXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlY3QgPSBldmVudC50YXJnZXQub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRSZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIEFkZCBydGwgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJSdGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uLmxlZnQgPSAoY2xpZW50UmVjdC5yaWdodCAtIHBhcmVudFJlY3QucmlnaHQpICogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gY2xpZW50UmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uLnRvcCA9IGNsaWVudFJlY3QudG9wIC0gcGFyZW50UmVjdC50b3A7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgZHJhZyBlbmQgPT4gXCIgKyBKU09OLnN0cmluZ2lmeShuZXdQb3NpdGlvbikpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIERST1A6IFwiICsgSlNPTi5zdHJpbmdpZnkobmV3UG9zaXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZHJhZ21vdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29yZUV2ZW50ID0gY3JlYXRlQ29yZURhdGEodGhpcy5sYXN0WCwgdGhpcy5sYXN0WSwgeCwgeSk7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgQWRkIHJ0bCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zaXRpb24ubGVmdCA9IHRoaXMuZHJhZ2dpbmcubGVmdCAtIGNvcmVFdmVudC5kZWx0YVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gdGhpcy5kcmFnZ2luZy5sZWZ0ICsgY29yZUV2ZW50LmRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbi50b3AgPSB0aGlzLmRyYWdnaW5nLnRvcCArIGNvcmVFdmVudC5kZWx0YVk7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgZHJhZyA9PiBcIiArIGV2ZW50LnR5cGUgKyBcIiwgeD1cIiArIHggKyBcIiwgeT1cIiArIHkpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIGRyYWcgPT4gXCIgKyBldmVudC50eXBlICsgXCIsIGRlbHRhWD1cIiArIGNvcmVFdmVudC5kZWx0YVggKyBcIiwgZGVsdGFZPVwiICsgY29yZUV2ZW50LmRlbHRhWSk7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgZHJhZyBlbmQgPT4gXCIgKyBKU09OLnN0cmluZ2lmeShuZXdQb3NpdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgWFlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNhbGNYWShuZXdQb3NpdGlvbi50b3AsIG5ld1Bvc2l0aW9uLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5jYWxjWFkobmV3UG9zaXRpb24udG9wLCBuZXdQb3NpdGlvbi5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RYID0geDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFkgPSB5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnggIT09IHBvcy54IHx8IHRoaXMueSAhPT0gcG9zLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KFwibW92ZVwiLCB0aGlzLmksIHBvcy54LCBwb3MueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJkcmFnZW5kXCIgJiYgKHRoaXMucHJldmlvdXNYICE9PSB0aGlzLnggfHwgdGhpcy5wcmV2aW91c1kgIT09IHRoaXMueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KFwibW92ZWRcIiwgdGhpcy5pLCBwb3MueCwgcG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcImRyYWdFdmVudFwiLCBldmVudC50eXBlLCB0aGlzLmksIHBvcy54LCBwb3MueSwgdGhpcy5oLCB0aGlzLncpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWxjUG9zaXRpb246IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMuY2FsY0NvbFdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgcnRsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLnJvdW5kKGNvbFdpZHRoICogeCArICh4ICsgMSkgKiB0aGlzLm1hcmdpblswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIHkgKyAoeSArIDEpICogdGhpcy5tYXJnaW5bMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAwICogSW5maW5pdHkgPT09IE5hTiwgd2hpY2ggY2F1c2VzIHByb2JsZW1zIHdpdGggcmVzaXplIGNvbnN0cmlhbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggdGhpcyBpZiBpdCBvY2N1cnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgd2UgZG8gaXQgaGVyZSByYXRoZXIgdGhhbiBsYXRlciBiZWNhdXNlIE1hdGgucm91bmQoSW5maW5pdHkpIGNhdXNlcyBkZW9wdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyA9PT0gSW5maW5pdHkgPyB3IDogTWF0aC5yb3VuZChjb2xXaWR0aCAqIHcgKyBNYXRoLm1heCgwLCB3IC0gMSkgKiB0aGlzLm1hcmdpblswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaCA9PT0gSW5maW5pdHkgPyBoIDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIGggKyBNYXRoLm1heCgwLCBoIC0gMSkgKiB0aGlzLm1hcmdpblsxXSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKGNvbFdpZHRoICogeCArICh4ICsgMSkgKiB0aGlzLm1hcmdpblswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIHkgKyAoeSArIDEpICogdGhpcy5tYXJnaW5bMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAwICogSW5maW5pdHkgPT09IE5hTiwgd2hpY2ggY2F1c2VzIHByb2JsZW1zIHdpdGggcmVzaXplIGNvbnN0cmlhbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggdGhpcyBpZiBpdCBvY2N1cnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgd2UgZG8gaXQgaGVyZSByYXRoZXIgdGhhbiBsYXRlciBiZWNhdXNlIE1hdGgucm91bmQoSW5maW5pdHkpIGNhdXNlcyBkZW9wdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyA9PT0gSW5maW5pdHkgPyB3IDogTWF0aC5yb3VuZChjb2xXaWR0aCAqIHcgKyBNYXRoLm1heCgwLCB3IC0gMSkgKiB0aGlzLm1hcmdpblswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaCA9PT0gSW5maW5pdHkgPyBoIDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIGggKyBNYXRoLm1heCgwLCBoIC0gMSkgKiB0aGlzLm1hcmdpblsxXSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJhbnNsYXRlIHggYW5kIHkgY29vcmRpbmF0ZXMgZnJvbSBwaXhlbHMgdG8gZ3JpZCB1bml0cy5cclxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB0b3AgIFRvcCBwb3NpdGlvbiAocmVsYXRpdmUgdG8gcGFyZW50KSBpbiBwaXhlbHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gbGVmdCBMZWZ0IHBvc2l0aW9uIChyZWxhdGl2ZSB0byBwYXJlbnQpIGluIHBpeGVscy5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB4IGFuZCB5IGluIGdyaWQgdW5pdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGlmIHRoaXMgZnVuY3Rpb24gbmVlZHMgY2hhbmdlIGluIG9yZGVyIHRvIHN1cHBvcnQgcnRsLlxyXG4gICAgICAgICAgICBjYWxjWFkodG9wLCBsZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMuY2FsY0NvbFdpZHRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbGVmdCA9IGNvbFdpZHRoICogeCArIG1hcmdpbiAqICh4ICsgMSlcclxuICAgICAgICAgICAgICAgIC8vIGwgPSBjeCArIG0oeCsxKVxyXG4gICAgICAgICAgICAgICAgLy8gbCA9IGN4ICsgbXggKyBtXHJcbiAgICAgICAgICAgICAgICAvLyBsIC0gbSA9IGN4ICsgbXhcclxuICAgICAgICAgICAgICAgIC8vIGwgLSBtID0geChjICsgbSlcclxuICAgICAgICAgICAgICAgIC8vIChsIC0gbSkgLyAoYyArIG0pID0geFxyXG4gICAgICAgICAgICAgICAgLy8geCA9IChsZWZ0IC0gbWFyZ2luKSAvIChjb2xkV2lkdGggKyBtYXJnaW4pXHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IE1hdGgucm91bmQoKGxlZnQgLSB0aGlzLm1hcmdpblswXSkgLyAoY29sV2lkdGggKyB0aGlzLm1hcmdpblswXSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBNYXRoLnJvdW5kKCh0b3AgLSB0aGlzLm1hcmdpblsxXSkgLyAodGhpcy5yb3dIZWlnaHQgKyB0aGlzLm1hcmdpblsxXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhcHBpbmdcclxuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heChNYXRoLm1pbih4LCB0aGlzLmNvbHMgLSB0aGlzLncpLCAwKTtcclxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heChNYXRoLm1pbih5LCB0aGlzLm1heFJvd3MgLSB0aGlzLmgpLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3gsIHl9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBIZWxwZXIgZm9yIGdlbmVyYXRpbmcgY29sdW1uIHdpZHRoXHJcbiAgICAgICAgICAgIGNhbGNDb2xXaWR0aCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xXaWR0aCA9ICh0aGlzLmNvbnRhaW5lcldpZHRoIC0gKHRoaXMubWFyZ2luWzBdICogKHRoaXMuY29scyArIDEpKSkgLyB0aGlzLmNvbHM7XHJcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIyMjIENPTFM9XCIgKyB0aGlzLmNvbHMgKyBcIiBDT0wgV0lEVEg9XCIgKyBjb2xXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sV2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0IEhlaWdodCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggIFdpZHRoIGluIHBpeGVscy5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB3LCBoIGFzIGdyaWQgdW5pdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjYWxjV0goaGVpZ2h0LCB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sV2lkdGggPSB0aGlzLmNhbGNDb2xXaWR0aCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoID0gY29sV2lkdGggKiB3IC0gKG1hcmdpbiAqICh3IC0gMSkpXHJcbiAgICAgICAgICAgICAgICAvLyAuLi5cclxuICAgICAgICAgICAgICAgIC8vIHcgPSAod2lkdGggKyBtYXJnaW4pIC8gKGNvbFdpZHRoICsgbWFyZ2luKVxyXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBNYXRoLnJvdW5kKCh3aWR0aCArIHRoaXMubWFyZ2luWzBdKSAvIChjb2xXaWR0aCArIHRoaXMubWFyZ2luWzBdKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaCA9IE1hdGgucm91bmQoKGhlaWdodCArIHRoaXMubWFyZ2luWzFdKSAvICh0aGlzLnJvd0hlaWdodCArIHRoaXMubWFyZ2luWzFdKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FwcGluZ1xyXG4gICAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KE1hdGgubWluKHcsIHRoaXMuY29scyAtIHRoaXMueCksIDApO1xyXG4gICAgICAgICAgICAgICAgaCA9IE1hdGgubWF4KE1hdGgubWluKGgsIHRoaXMubWF4Um93cyAtIHRoaXMueSksIDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt3LCBofTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlV2lkdGg6IGZ1bmN0aW9uICh3aWR0aCwgY29sTnVtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sTnVtICE9PSB1bmRlZmluZWQgJiYgY29sTnVtICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xzID0gY29sTnVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wYWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEdyaWRJdGVtLnZ1ZT9iYzNmMTFiNCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getControlPosition = getControlPosition;\nexports.offsetXYFromParentOf = offsetXYFromParentOf;\nexports.createCoreData = createCoreData;\n// Get {x, y} positions from event.\nfunction getControlPosition(e) {\n    return offsetXYFromParentOf(e);\n}\n\n// Get from offsetParent\nfunction offsetXYFromParentOf(evt) {\n    var offsetParent = evt.target.offsetParent || document.body;\n    var offsetParentRect = evt.offsetParent === document.body ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();\n\n    var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;\n    var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;\n\n    /*const x = Math.round(evt.clientX + offsetParent.scrollLeft - offsetParentRect.left);\r\n    const y = Math.round(evt.clientY + offsetParent.scrollTop - offsetParentRect.top);*/\n\n    return { x: x, y: y };\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(lastX, lastY, x, y) {\n    // State changes are often (but not always!) async. We want the latest value.\n    var isStart = !isNum(lastX);\n\n    if (isStart) {\n        // If this is our first move, use the x and y as last coords.\n        return {\n            deltaX: 0, deltaY: 0,\n            lastX: x, lastY: y,\n            x: x, y: y\n        };\n    } else {\n        // Otherwise calculate proper values.\n        return {\n            deltaX: x - lastX, deltaY: y - lastY,\n            lastX: lastX, lastY: lastY,\n            x: x, y: y\n        };\n    }\n}\n\nfunction isNum(num) {\n    return typeof num === 'number' && !isNaN(num);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJhZ2dhYmxlVXRpbHMuanM/YWQ2NyJdLCJuYW1lcyI6WyJnZXRDb250cm9sUG9zaXRpb24iLCJvZmZzZXRYWUZyb21QYXJlbnRPZiIsImNyZWF0ZUNvcmVEYXRhIiwiZSIsImV2dCIsIm9mZnNldFBhcmVudCIsInRhcmdldCIsImRvY3VtZW50IiwiYm9keSIsIm9mZnNldFBhcmVudFJlY3QiLCJsZWZ0IiwidG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwieSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJsYXN0WCIsImxhc3RZIiwiaXNTdGFydCIsImlzTnVtIiwiZGVsdGFYIiwiZGVsdGFZIiwibnVtIiwiaXNOYU4iXSwibWFwcGluZ3MiOiI7Ozs7O1FBQ2dCQSxrQixHQUFBQSxrQjtRQU1BQyxvQixHQUFBQSxvQjtRQWdCQUMsYyxHQUFBQSxjO0FBdkJoQjtBQUNPLFNBQVNGLGtCQUFULENBQTRCRyxDQUE1QixFQUErQjtBQUNsQyxXQUFPRixxQkFBcUJFLENBQXJCLENBQVA7QUFDSDs7QUFHRDtBQUNPLFNBQVNGLG9CQUFULENBQThCRyxHQUE5QixFQUFtQztBQUN0QyxRQUFNQyxlQUFlRCxJQUFJRSxNQUFKLENBQVdELFlBQVgsSUFBMkJFLFNBQVNDLElBQXpEO0FBQ0EsUUFBTUMsbUJBQW1CTCxJQUFJQyxZQUFKLEtBQXFCRSxTQUFTQyxJQUE5QixHQUFxQyxFQUFDRSxNQUFNLENBQVAsRUFBVUMsS0FBSyxDQUFmLEVBQXJDLEdBQXlETixhQUFhTyxxQkFBYixFQUFsRjs7QUFFQSxRQUFNQyxJQUFJVCxJQUFJVSxPQUFKLEdBQWNULGFBQWFVLFVBQTNCLEdBQXdDTixpQkFBaUJDLElBQW5FO0FBQ0EsUUFBTU0sSUFBSVosSUFBSWEsT0FBSixHQUFjWixhQUFhYSxTQUEzQixHQUF1Q1QsaUJBQWlCRSxHQUFsRTs7QUFFQTs7O0FBSUEsV0FBTyxFQUFDRSxJQUFELEVBQUlHLElBQUosRUFBUDtBQUNIOztBQUdEO0FBQ08sU0FBU2QsY0FBVCxDQUF3QmlCLEtBQXhCLEVBQStCQyxLQUEvQixFQUFzQ1AsQ0FBdEMsRUFBeUNHLENBQXpDLEVBQTRDO0FBQy9DO0FBQ0EsUUFBTUssVUFBVSxDQUFDQyxNQUFNSCxLQUFOLENBQWpCOztBQUVBLFFBQUlFLE9BQUosRUFBYTtBQUNUO0FBQ0EsZUFBTztBQUNIRSxvQkFBUSxDQURMLEVBQ1FDLFFBQVEsQ0FEaEI7QUFFSEwsbUJBQU9OLENBRkosRUFFT08sT0FBT0osQ0FGZDtBQUdISCxlQUFHQSxDQUhBLEVBR0dHLEdBQUdBO0FBSE4sU0FBUDtBQUtILEtBUEQsTUFPTztBQUNIO0FBQ0EsZUFBTztBQUNITyxvQkFBUVYsSUFBSU0sS0FEVCxFQUNnQkssUUFBUVIsSUFBSUksS0FENUI7QUFFSEQsbUJBQU9BLEtBRkosRUFFV0MsT0FBT0EsS0FGbEI7QUFHSFAsZUFBR0EsQ0FIQSxFQUdHRyxHQUFHQTtBQUhOLFNBQVA7QUFLSDtBQUNKOztBQUdELFNBQVNNLEtBQVQsQ0FBZUcsR0FBZixFQUFxQjtBQUNqQixXQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUNDLE1BQU1ELEdBQU4sQ0FBbkM7QUFDSCIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cm9sUG9zaXRpb24oZSkge1xyXG4gICAgcmV0dXJuIG9mZnNldFhZRnJvbVBhcmVudE9mKGUpO1xyXG59XHJcblxyXG5cclxuLy8gR2V0IGZyb20gb2Zmc2V0UGFyZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRYWUZyb21QYXJlbnRPZihldnQpIHtcclxuICAgIGNvbnN0IG9mZnNldFBhcmVudCA9IGV2dC50YXJnZXQub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XHJcbiAgICBjb25zdCBvZmZzZXRQYXJlbnRSZWN0ID0gZXZ0Lm9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSA/IHtsZWZ0OiAwLCB0b3A6IDB9IDogb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGNvbnN0IHggPSBldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0O1xyXG4gICAgY29uc3QgeSA9IGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wO1xyXG5cclxuICAgIC8qY29uc3QgeCA9IE1hdGgucm91bmQoZXZ0LmNsaWVudFggKyBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCAtIG9mZnNldFBhcmVudFJlY3QubGVmdCk7XHJcbiAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcCk7Ki9cclxuXHJcblxyXG4gICAgcmV0dXJuIHt4LCB5fTtcclxufVxyXG5cclxuXHJcbi8vIENyZWF0ZSBhbiBkYXRhIG9iamVjdCBleHBvc2VkIGJ5IDxEcmFnZ2FibGVDb3JlPidzIGV2ZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29yZURhdGEobGFzdFgsIGxhc3RZLCB4LCB5KSB7XHJcbiAgICAvLyBTdGF0ZSBjaGFuZ2VzIGFyZSBvZnRlbiAoYnV0IG5vdCBhbHdheXMhKSBhc3luYy4gV2Ugd2FudCB0aGUgbGF0ZXN0IHZhbHVlLlxyXG4gICAgY29uc3QgaXNTdGFydCA9ICFpc051bShsYXN0WCk7XHJcblxyXG4gICAgaWYgKGlzU3RhcnQpIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBtb3ZlLCB1c2UgdGhlIHggYW5kIHkgYXMgbGFzdCBjb29yZHMuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGVsdGFYOiAwLCBkZWx0YVk6IDAsXHJcbiAgICAgICAgICAgIGxhc3RYOiB4LCBsYXN0WTogeSxcclxuICAgICAgICAgICAgeDogeCwgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWx0YVg6IHggLSBsYXN0WCwgZGVsdGFZOiB5IC0gbGFzdFksXHJcbiAgICAgICAgICAgIGxhc3RYOiBsYXN0WCwgbGFzdFk6IGxhc3RZLFxyXG4gICAgICAgICAgICB4OiB4LCB5OiB5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzTnVtKG51bSkgIHtcclxuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtKTtcclxufVxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RyYWdnYWJsZVV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;/**\r\n * interact.js v1.3.0-alpha.4+sha.7970416-dirty\r\n *\r\n * Copyright (c) 2012-2017 Taye Adeyemi <dev@taye.me>\r\n * Open source under the MIT License.\r\n * https://raw.github.com/taye/interact.js/master/LICENSE\r\n */\r\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n'use strict';\r\n\r\n/*\r\n * In a (windowless) server environment this file exports a factory function\r\n * that takes the window to use.\r\n *\r\n *     var interact = require('interact.js')(windowObject);\r\n *\r\n * See https://github.com/taye/interact.js/issues/187\r\n */\r\nif (typeof window === 'undefined') {\r\n  module.exports = function (window) {\r\n    require('./src/utils/window').init(window);\r\n\r\n    return require('./src/index');\r\n  };\r\n} else {\r\n  module.exports = require('./src/index');\r\n}\r\n\r\n},{\"./src/index\":19,\"./src/utils/window\":52}],2:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar _require = require('./utils/arr'),\r\n    indexOf = _require.indexOf;\r\n\r\nvar extend = require('./utils/extend.js');\r\n\r\nfunction fireUntilImmediateStopped(event, listeners) {\r\n  for (var i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\r\n    listeners[i](event);\r\n  }\r\n}\r\n\r\nvar Eventable = function () {\r\n  function Eventable(options) {\r\n    _classCallCheck(this, Eventable);\r\n\r\n    this.options = extend({}, options || {});\r\n  }\r\n\r\n  Eventable.prototype.fire = function fire(event) {\r\n    var listeners = void 0;\r\n    var onEvent = 'on' + event.type;\r\n    var global = this.global;\r\n\r\n    // Interactable#on() listeners\r\n    if (listeners = this[event.type]) {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n\r\n    // interactable.onevent listener\r\n    if (this[onEvent]) {\r\n      this[onEvent](event);\r\n    }\r\n\r\n    // interact.on() listeners\r\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n  };\r\n\r\n  Eventable.prototype.on = function on(eventType, listener) {\r\n    // if this type of event was never bound\r\n    if (this[eventType]) {\r\n      this[eventType].push(listener);\r\n    } else {\r\n      this[eventType] = [listener];\r\n    }\r\n  };\r\n\r\n  Eventable.prototype.off = function off(eventType, listener) {\r\n    // if it is an action event type\r\n    var eventList = this[eventType];\r\n    var index = eventList ? indexOf(eventList, listener) : -1;\r\n\r\n    if (index !== -1) {\r\n      eventList.splice(index, 1);\r\n    }\r\n\r\n    if (eventList && eventList.length === 0 || !listener) {\r\n      this[eventType] = listener;\r\n    }\r\n  };\r\n\r\n  return Eventable;\r\n}();\r\n\r\nmodule.exports = Eventable;\r\n\r\n},{\"./utils/arr\":36,\"./utils/extend.js\":41}],3:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar extend = require('./utils/extend');\r\nvar getOriginXY = require('./utils/getOriginXY');\r\nvar defaults = require('./defaultOptions');\r\nvar signals = require('./utils/Signals').new();\r\n\r\nvar InteractEvent = function () {\r\n  function InteractEvent(interaction, event, action, phase, element, related) {\r\n    var preEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\r\n\r\n    _classCallCheck(this, InteractEvent);\r\n\r\n    var target = interaction.target;\r\n    var deltaSource = (target && target.options || defaults).deltaSource;\r\n    var origin = getOriginXY(target, element, action);\r\n    var starting = phase === 'start';\r\n    var ending = phase === 'end';\r\n    var coords = starting ? interaction.startCoords : interaction.curCoords;\r\n    var prevEvent = interaction.prevEvent;\r\n\r\n    element = element || interaction.element;\r\n\r\n    var page = extend({}, coords.page);\r\n    var client = extend({}, coords.client);\r\n\r\n    page.x -= origin.x;\r\n    page.y -= origin.y;\r\n\r\n    client.x -= origin.x;\r\n    client.y -= origin.y;\r\n\r\n    this.ctrlKey = event.ctrlKey;\r\n    this.altKey = event.altKey;\r\n    this.shiftKey = event.shiftKey;\r\n    this.metaKey = event.metaKey;\r\n    this.button = event.button;\r\n    this.buttons = event.buttons;\r\n    this.target = element;\r\n    this.currentTarget = element;\r\n    this.relatedTarget = related || null;\r\n    this.preEnd = preEnd;\r\n    this.type = action + (phase || '');\r\n    this.interaction = interaction;\r\n    this.interactable = target;\r\n\r\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1] : prevEvent.t0;\r\n\r\n    var signalArg = {\r\n      interaction: interaction,\r\n      event: event,\r\n      action: action,\r\n      phase: phase,\r\n      element: element,\r\n      related: related,\r\n      page: page,\r\n      client: client,\r\n      coords: coords,\r\n      starting: starting,\r\n      ending: ending,\r\n      deltaSource: deltaSource,\r\n      iEvent: this\r\n    };\r\n\r\n    signals.fire('set-xy', signalArg);\r\n\r\n    if (ending) {\r\n      // use previous coords when ending\r\n      this.pageX = prevEvent.pageX;\r\n      this.pageY = prevEvent.pageY;\r\n      this.clientX = prevEvent.clientX;\r\n      this.clientY = prevEvent.clientY;\r\n    } else {\r\n      this.pageX = page.x;\r\n      this.pageY = page.y;\r\n      this.clientX = client.x;\r\n      this.clientY = client.y;\r\n    }\r\n\r\n    this.x0 = interaction.startCoords.page.x - origin.x;\r\n    this.y0 = interaction.startCoords.page.y - origin.y;\r\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\r\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\r\n\r\n    signals.fire('set-delta', signalArg);\r\n\r\n    this.timeStamp = coords.timeStamp;\r\n    this.dt = interaction.pointerDelta.timeStamp;\r\n    this.duration = this.timeStamp - this.t0;\r\n\r\n    // speed and velocity in pixels per second\r\n    this.speed = interaction.pointerDelta[deltaSource].speed;\r\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\r\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\r\n\r\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;\r\n\r\n    signals.fire('new', signalArg);\r\n  }\r\n\r\n  InteractEvent.prototype.getSwipe = function getSwipe() {\r\n    var interaction = this.interaction;\r\n\r\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\r\n      return null;\r\n    }\r\n\r\n    var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\r\n    var overlap = 22.5;\r\n\r\n    if (angle < 0) {\r\n      angle += 360;\r\n    }\r\n\r\n    var left = 135 - overlap <= angle && angle < 225 + overlap;\r\n    var up = 225 - overlap <= angle && angle < 315 + overlap;\r\n\r\n    var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\r\n    var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\r\n\r\n    return {\r\n      up: up,\r\n      down: down,\r\n      left: left,\r\n      right: right,\r\n      angle: angle,\r\n      speed: interaction.prevEvent.speed,\r\n      velocity: {\r\n        x: interaction.prevEvent.velocityX,\r\n        y: interaction.prevEvent.velocityY\r\n      }\r\n    };\r\n  };\r\n\r\n  InteractEvent.prototype.preventDefault = function preventDefault() {};\r\n\r\n  InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\r\n    this.immediatePropagationStopped = this.propagationStopped = true;\r\n  };\r\n\r\n  InteractEvent.prototype.stopPropagation = function stopPropagation() {\r\n    this.propagationStopped = true;\r\n  };\r\n\r\n  return InteractEvent;\r\n}();\r\n\r\nsignals.on('set-delta', function (_ref) {\r\n  var iEvent = _ref.iEvent,\r\n      interaction = _ref.interaction,\r\n      starting = _ref.starting,\r\n      deltaSource = _ref.deltaSource;\r\n\r\n  var prevEvent = starting ? iEvent : interaction.prevEvent;\r\n\r\n  if (deltaSource === 'client') {\r\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\r\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\r\n  } else {\r\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\r\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\r\n  }\r\n});\r\n\r\nInteractEvent.signals = signals;\r\n\r\nmodule.exports = InteractEvent;\r\n\r\n},{\"./defaultOptions\":18,\"./utils/Signals\":35,\"./utils/extend\":41,\"./utils/getOriginXY\":42}],4:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar is = require('./utils/is');\r\nvar events = require('./utils/events');\r\nvar extend = require('./utils/extend');\r\nvar actions = require('./actions/base');\r\nvar scope = require('./scope');\r\nvar Eventable = require('./Eventable');\r\nvar defaults = require('./defaultOptions');\r\nvar signals = require('./utils/Signals').new();\r\n\r\nvar _require = require('./utils/domUtils'),\r\n    getElementRect = _require.getElementRect,\r\n    nodeContains = _require.nodeContains,\r\n    trySelector = _require.trySelector;\r\n\r\nvar _require2 = require('./utils/window'),\r\n    getWindow = _require2.getWindow;\r\n\r\nvar _require3 = require('./utils/arr'),\r\n    indexOf = _require3.indexOf,\r\n    contains = _require3.contains;\r\n\r\nvar _require4 = require('./utils/browser'),\r\n    wheelEvent = _require4.wheelEvent;\r\n\r\n// all set interactables\r\n\r\n\r\nscope.interactables = [];\r\n\r\n/*\\\r\n * Interactable\r\n [ property ]\r\n **\r\n * Object type returned by @interact\r\n\\*/\r\n\r\nvar Interactable = function () {\r\n  function Interactable(target, options) {\r\n    _classCallCheck(this, Interactable);\r\n\r\n    options = options || {};\r\n\r\n    this.target = target;\r\n    this.events = new Eventable();\r\n    this._context = options.context || scope.document;\r\n    this._win = getWindow(trySelector(target) ? this._context : target);\r\n    this._doc = this._win.document;\r\n\r\n    signals.fire('new', {\r\n      target: target,\r\n      options: options,\r\n      interactable: this,\r\n      win: this._win\r\n    });\r\n\r\n    scope.addDocument(this._doc, this._win);\r\n\r\n    scope.interactables.push(this);\r\n\r\n    this.set(options);\r\n  }\r\n\r\n  Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\r\n    var onAction = 'on' + action;\r\n\r\n    if (is.function(phases.onstart)) {\r\n      this.events[onAction + 'start'] = phases.onstart;\r\n    }\r\n    if (is.function(phases.onmove)) {\r\n      this.events[onAction + 'move'] = phases.onmove;\r\n    }\r\n    if (is.function(phases.onend)) {\r\n      this.events[onAction + 'end'] = phases.onend;\r\n    }\r\n    if (is.function(phases.oninertiastart)) {\r\n      this.events[onAction + 'inertiastart'] = phases.oninertiastart;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  Interactable.prototype.setPerAction = function setPerAction(action, options) {\r\n    // for all the default per-action options\r\n    for (var option in options) {\r\n      // if this option exists for this action\r\n      if (option in defaults[action]) {\r\n        // if the option in the options arg is an object value\r\n        if (is.object(options[option])) {\r\n          // duplicate the object\r\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\r\n\r\n          if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\r\n            this.options[action][option].enabled = options[option].enabled === false ? false : true;\r\n          }\r\n        } else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\r\n          this.options[action][option].enabled = options[option];\r\n        } else if (options[option] !== undefined) {\r\n          // or if it's not undefined, do a plain assignment\r\n          this.options[action][option] = options[option];\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.getRect\r\n   [ method ]\r\n   *\r\n   * The default function to get an Interactables bounding rect. Can be\r\n   * overridden using @Interactable.rectChecker.\r\n   *\r\n   - element (Element) #optional The element to measure.\r\n   = (object) The object's bounding rectangle.\r\n   o {\r\n   o     top   : 0,\r\n   o     left  : 0,\r\n   o     bottom: 0,\r\n   o     right : 0,\r\n   o     width : 0,\r\n   o     height: 0\r\n   o }\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.getRect = function getRect(element) {\r\n    element = element || this.target;\r\n\r\n    if (is.string(this.target) && !is.element(element)) {\r\n      element = this._context.querySelector(this.target);\r\n    }\r\n\r\n    return getElementRect(element);\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.rectChecker\r\n   [ method ]\r\n   *\r\n   * Returns or sets the function used to calculate the interactable's\r\n   * element's rectangle\r\n   *\r\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\r\n   = (function | object) The checker function or this Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.rectChecker = function rectChecker(checker) {\r\n    if (is.function(checker)) {\r\n      this.getRect = checker;\r\n\r\n      return this;\r\n    }\r\n\r\n    if (checker === null) {\r\n      delete this.options.getRect;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.getRect;\r\n  };\r\n\r\n  Interactable.prototype._backCompatOption = function _backCompatOption(optionName, newValue) {\r\n    if (trySelector(newValue) || is.object(newValue)) {\r\n      this.options[optionName] = newValue;\r\n\r\n      for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n        var _ref;\r\n\r\n        if (_isArray) {\r\n          if (_i >= _iterator.length) break;\r\n          _ref = _iterator[_i++];\r\n        } else {\r\n          _i = _iterator.next();\r\n          if (_i.done) break;\r\n          _ref = _i.value;\r\n        }\r\n\r\n        var action = _ref;\r\n\r\n        this.options[action][optionName] = newValue;\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.options[optionName];\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.origin\r\n   [ method ]\r\n   *\r\n   * Gets or sets the origin of the Interactable's element.  The x and y\r\n   * of the origin will be subtracted from action event coordinates.\r\n   *\r\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\r\n   * OR\r\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\r\n   **\r\n   = (object) The current origin or this Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.origin = function origin(newValue) {\r\n    return this._backCompatOption('origin', newValue);\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.deltaSource\r\n   [ method ]\r\n   *\r\n   * Returns or sets the mouse coordinate types used to calculate the\r\n   * movement of the pointer.\r\n   *\r\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\r\n   = (string | object) The current deltaSource or this Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.deltaSource = function deltaSource(newValue) {\r\n    if (newValue === 'page' || newValue === 'client') {\r\n      this.options.deltaSource = newValue;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.options.deltaSource;\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.context\r\n   [ method ]\r\n   *\r\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\r\n   *\r\n   = (Node) The context Node of this Interactable\r\n   **\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.context = function context() {\r\n    return this._context;\r\n  };\r\n\r\n  Interactable.prototype.inContext = function inContext(element) {\r\n    return this._context === element.ownerDocument || nodeContains(this._context, element);\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.fire\r\n   [ method ]\r\n   *\r\n   * Calls listeners for the given InteractEvent type bound globally\r\n   * and directly to this Interactable\r\n   *\r\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\r\n   = (Interactable) this Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.fire = function fire(iEvent) {\r\n    this.events.fire(iEvent);\r\n\r\n    return this;\r\n  };\r\n\r\n  Interactable.prototype._onOffMultiple = function _onOffMultiple(method, eventType, listener, options) {\r\n    if (is.string(eventType) && eventType.search(' ') !== -1) {\r\n      eventType = eventType.trim().split(/ +/);\r\n    }\r\n\r\n    if (is.array(eventType)) {\r\n      for (var i = 0; i < eventType.length; i++) {\r\n        this[method](eventType[i], listener, options);\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    if (is.object(eventType)) {\r\n      for (var prop in eventType) {\r\n        this[method](prop, eventType[prop], listener);\r\n      }\r\n\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.on\r\n   [ method ]\r\n   *\r\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\r\n   *\r\n   - eventType  (string | array | object) The types of events to listen for\r\n   - listener   (function) The function event (s)\r\n   - options    (object | boolean) #optional options object or useCapture flag for addEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.on = function on(eventType, listener, options) {\r\n    if (this._onOffMultiple('on', eventType, listener, options)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') {\r\n      eventType = wheelEvent;\r\n    }\r\n\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this.events.on(eventType, listener);\r\n    }\r\n    // delegated event for selector\r\n    else if (is.string(this.target)) {\r\n        events.addDelegate(this.target, this._context, eventType, listener, options);\r\n      } else {\r\n        events.add(this.target, eventType, listener, options);\r\n      }\r\n\r\n    return this;\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.off\r\n   [ method ]\r\n   *\r\n   * Removes an InteractEvent, pointerEvent or DOM event listener\r\n   *\r\n   - eventType  (string | array | object) The types of events that were listened for\r\n   - listener   (function) The listener function to be removed\r\n   - options    (object | boolean) #optional options object or useCapture flag for removeEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.off = function off(eventType, listener, options) {\r\n    if (this._onOffMultiple('off', eventType, listener, options)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') {\r\n      eventType = wheelEvent;\r\n    }\r\n\r\n    // if it is an action event type\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this.events.off(eventType, listener);\r\n    }\r\n    // delegated event\r\n    else if (is.string(this.target)) {\r\n        events.removeDelegate(this.target, this._context, eventType, listener, options);\r\n      }\r\n      // remove listener from this Interatable's element\r\n      else {\r\n          events.remove(this.target, eventType, listener, options);\r\n        }\r\n\r\n    return this;\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.set\r\n   [ method ]\r\n   *\r\n   * Reset the options of this Interactable\r\n   - options (object) The new settings to apply\r\n   = (object) This Interactable\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.set = function set(options) {\r\n    if (!is.object(options)) {\r\n      options = {};\r\n    }\r\n\r\n    this.options = extend({}, defaults.base);\r\n\r\n    var perActions = extend({}, defaults.perAction);\r\n\r\n    for (var actionName in actions.methodDict) {\r\n      var methodName = actions.methodDict[actionName];\r\n\r\n      this.options[actionName] = extend({}, defaults[actionName]);\r\n\r\n      this.setPerAction(actionName, perActions);\r\n\r\n      this[methodName](options[actionName]);\r\n    }\r\n\r\n    for (var _iterator2 = Interactable.settingsMethods, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n      var _ref2;\r\n\r\n      if (_isArray2) {\r\n        if (_i2 >= _iterator2.length) break;\r\n        _ref2 = _iterator2[_i2++];\r\n      } else {\r\n        _i2 = _iterator2.next();\r\n        if (_i2.done) break;\r\n        _ref2 = _i2.value;\r\n      }\r\n\r\n      var setting = _ref2;\r\n\r\n      this.options[setting] = defaults.base[setting];\r\n\r\n      if (setting in options) {\r\n        this[setting](options[setting]);\r\n      }\r\n    }\r\n\r\n    signals.fire('set', {\r\n      options: options,\r\n      interactable: this\r\n    });\r\n\r\n    return this;\r\n  };\r\n\r\n  /*\\\r\n   * Interactable.unset\r\n   [ method ]\r\n   *\r\n   * Remove this interactable from the list of interactables and remove\r\n   * it's action capabilities and event listeners\r\n   *\r\n   = (object) @interact\r\n  \\*/\r\n\r\n\r\n  Interactable.prototype.unset = function unset() {\r\n    events.remove(this.target, 'all');\r\n\r\n    if (is.string(this.target)) {\r\n      // remove delegated events\r\n      for (var type in events.delegatedEvents) {\r\n        var delegated = events.delegatedEvents[type];\r\n\r\n        if (delegated.selectors[0] === this.target && delegated.contexts[0] === this._context) {\r\n\r\n          delegated.selectors.splice(0, 1);\r\n          delegated.contexts.splice(0, 1);\r\n          delegated.listeners.splice(0, 1);\r\n\r\n          // remove the arrays if they are empty\r\n          if (!delegated.selectors.length) {\r\n            delegated[type] = null;\r\n          }\r\n        }\r\n\r\n        events.remove(this._context, type, events.delegateListener);\r\n        events.remove(this._context, type, events.delegateUseCapture, true);\r\n      }\r\n    } else {\r\n      events.remove(this, 'all');\r\n    }\r\n\r\n    signals.fire('unset', { interactable: this });\r\n\r\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\r\n\r\n    // Stop related interactions when an Interactable is unset\r\n    for (var _iterator3 = scope.interactions || [], _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\r\n      var _ref3;\r\n\r\n      if (_isArray3) {\r\n        if (_i3 >= _iterator3.length) break;\r\n        _ref3 = _iterator3[_i3++];\r\n      } else {\r\n        _i3 = _iterator3.next();\r\n        if (_i3.done) break;\r\n        _ref3 = _i3.value;\r\n      }\r\n\r\n      var interaction = _ref3;\r\n\r\n      if (interaction.target === this && interaction.interacting()) {\r\n        interaction.stop();\r\n      }\r\n    }\r\n\r\n    return scope.interact;\r\n  };\r\n\r\n  return Interactable;\r\n}();\r\n\r\nscope.interactables.indexOfElement = function indexOfElement(target, context) {\r\n  context = context || scope.document;\r\n\r\n  for (var i = 0; i < this.length; i++) {\r\n    var interactable = this[i];\r\n\r\n    if (interactable.target === target && interactable._context === context) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nscope.interactables.get = function interactableGet(element, options, dontCheckInContext) {\r\n  var ret = this[this.indexOfElement(element, options && options.context)];\r\n\r\n  return ret && (is.string(element) || dontCheckInContext || ret.inContext(element)) ? ret : null;\r\n};\r\n\r\nscope.interactables.forEachSelector = function (callback, element) {\r\n  for (var i = 0; i < this.length; i++) {\r\n    var interactable = this[i];\r\n\r\n    // skip non CSS selector targets and out of context elements\r\n    if (!is.string(interactable.target) || element && !interactable.inContext(element)) {\r\n      continue;\r\n    }\r\n\r\n    var ret = callback(interactable, interactable.target, interactable._context, i, this);\r\n\r\n    if (ret !== undefined) {\r\n      return ret;\r\n    }\r\n  }\r\n};\r\n\r\n// all interact.js eventTypes\r\nInteractable.eventTypes = scope.eventTypes = [];\r\n\r\nInteractable.signals = signals;\r\n\r\nInteractable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker'];\r\n\r\nmodule.exports = Interactable;\r\n\r\n},{\"./Eventable\":2,\"./actions/base\":6,\"./defaultOptions\":18,\"./scope\":34,\"./utils/Signals\":35,\"./utils/arr\":36,\"./utils/browser\":37,\"./utils/domUtils\":39,\"./utils/events\":40,\"./utils/extend\":41,\"./utils/is\":46,\"./utils/window\":52}],5:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar scope = require('./scope');\r\nvar utils = require('./utils');\r\nvar events = require('./utils/events');\r\nvar browser = require('./utils/browser');\r\nvar domObjects = require('./utils/domObjects');\r\nvar finder = require('./utils/interactionFinder');\r\nvar signals = require('./utils/Signals').new();\r\n\r\nvar listeners = {};\r\nvar methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer'];\r\n\r\n// for ignoring browser's simulated mouse events\r\nvar prevTouchTime = 0;\r\n\r\n// all active and idle interactions\r\nscope.interactions = [];\r\n\r\nvar Interaction = function () {\r\n  function Interaction(_ref) {\r\n    var pointerType = _ref.pointerType;\r\n\r\n    _classCallCheck(this, Interaction);\r\n\r\n    this.target = null; // current interactable being interacted with\r\n    this.element = null; // the target element of the interactable\r\n\r\n    this.prepared = { // action that's ready to be fired on next move event\r\n      name: null,\r\n      axis: null,\r\n      edges: null\r\n    };\r\n\r\n    // keep track of added pointers\r\n    this.pointers = [];\r\n    this.pointerIds = [];\r\n    this.downTargets = [];\r\n    this.downTimes = [];\r\n\r\n    // Previous native pointer move event coordinates\r\n    this.prevCoords = {\r\n      page: { x: 0, y: 0 },\r\n      client: { x: 0, y: 0 },\r\n      timeStamp: 0\r\n    };\r\n    // current native pointer move event coordinates\r\n    this.curCoords = {\r\n      page: { x: 0, y: 0 },\r\n      client: { x: 0, y: 0 },\r\n      timeStamp: 0\r\n    };\r\n\r\n    // Starting InteractEvent pointer coordinates\r\n    this.startCoords = {\r\n      page: { x: 0, y: 0 },\r\n      client: { x: 0, y: 0 },\r\n      timeStamp: 0\r\n    };\r\n\r\n    // Change in coordinates and time of the pointer\r\n    this.pointerDelta = {\r\n      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      timeStamp: 0\r\n    };\r\n\r\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\r\n    this.downPointer = {};\r\n\r\n    this._eventTarget = null;\r\n    this._curEventTarget = null;\r\n\r\n    this.prevEvent = null; // previous action event\r\n\r\n    this.pointerIsDown = false;\r\n    this.pointerWasMoved = false;\r\n    this._interacting = false;\r\n\r\n    this.pointerType = pointerType;\r\n\r\n    signals.fire('new', this);\r\n\r\n    scope.interactions.push(this);\r\n  }\r\n\r\n  Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\r\n    var pointerIndex = this.updatePointer(pointer, event, true);\r\n\r\n    signals.fire('down', {\r\n      pointer: pointer,\r\n      event: event,\r\n      eventTarget: eventTarget,\r\n      pointerIndex: pointerIndex,\r\n      interaction: this\r\n    });\r\n  };\r\n\r\n  /*\\\r\n   * Interaction.start\r\n   [ method ]\r\n   *\r\n   * Start an action with the given Interactable and Element as tartgets. The\r\n   * action must be enabled for the target Interactable and an appropriate number\r\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\r\n   *\r\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\r\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\r\n   *\r\n   - action  (object)  The action to be performed - drag, resize, etc.\r\n   - target  (Interactable) The Interactable to target\r\n   - element (Element) The DOM Element to target\r\n   = (object) interact\r\n   **\r\n   | interact(target)\r\n   |   .draggable({\r\n   |     // disable the default drag start by down->move\r\n   |     manualStart: true\r\n   |   })\r\n   |   // start dragging after the user holds the pointer down\r\n   |   .on('hold', function (event) {\r\n   |     var interaction = event.interaction;\r\n   |\r\n   |     if (!interaction.interacting()) {\r\n   |       interaction.start({ name: 'drag' },\r\n   |                         event.interactable,\r\n   |                         event.currentTarget);\r\n   |     }\r\n   | });\r\n   \\*/\r\n\r\n\r\n  Interaction.prototype.start = function start(action, target, element) {\r\n    if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\r\n      return;\r\n    }\r\n\r\n    // if this interaction had been removed after stopping\r\n    // add it back\r\n    if (utils.indexOf(scope.interactions, this) === -1) {\r\n      scope.interactions.push(this);\r\n    }\r\n\r\n    utils.copyAction(this.prepared, action);\r\n    this.target = target;\r\n    this.element = element;\r\n\r\n    signals.fire('action-start', {\r\n      interaction: this,\r\n      event: this.downEvent\r\n    });\r\n  };\r\n\r\n  Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\r\n    if (!this.simulation) {\r\n      this.updatePointer(pointer);\r\n      utils.setCoords(this.curCoords, this.pointers);\r\n    }\r\n\r\n    var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\r\n\r\n    var dx = void 0;\r\n    var dy = void 0;\r\n\r\n    // register movement greater than pointerMoveTolerance\r\n    if (this.pointerIsDown && !this.pointerWasMoved) {\r\n      dx = this.curCoords.client.x - this.startCoords.client.x;\r\n      dy = this.curCoords.client.y - this.startCoords.client.y;\r\n\r\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\r\n    }\r\n\r\n    var signalArg = {\r\n      pointer: pointer,\r\n      pointerIndex: this.getPointerIndex(pointer),\r\n      event: event,\r\n      eventTarget: eventTarget,\r\n      dx: dx,\r\n      dy: dy,\r\n      duplicate: duplicateMove,\r\n      interaction: this,\r\n      interactingBeforeMove: this.interacting()\r\n    };\r\n\r\n    if (!duplicateMove) {\r\n      // set pointer coordinate, time changes and speeds\r\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n    }\r\n\r\n    signals.fire('move', signalArg);\r\n\r\n    if (!duplicateMove) {\r\n      // if interacting, fire an 'action-move' signal etc\r\n      if (this.interacting()) {\r\n        this.doMove(signalArg);\r\n      }\r\n\r\n      if (this.pointerWasMoved) {\r\n        utils.copyCoords(this.prevCoords, this.curCoords);\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\\\r\n   * Interaction.doMove\r\n   [ method ]\r\n   *\r\n   * Force a move of the current action at the same coordinates. Useful if\r\n   * snap/restrict has been changed and you want a movement with the new\r\n   * settings.\r\n   *\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('dragmove', function (event) {\r\n   |     if (someCondition) {\r\n   |       // change the snap settings\r\n   |       event.interactable.draggable({ snap: { targets: [] }});\r\n   |       // fire another move event with re-calculated snap\r\n   |       event.interaction.doMove();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n\r\n\r\n  Interaction.prototype.doMove = function doMove(signalArg) {\r\n    signalArg = utils.extend({\r\n      pointer: this.pointers[0],\r\n      event: this.prevEvent,\r\n      eventTarget: this._eventTarget,\r\n      interaction: this\r\n    }, signalArg || {});\r\n\r\n    signals.fire('before-action-move', signalArg);\r\n\r\n    if (!this._dontFireMove) {\r\n      signals.fire('action-move', signalArg);\r\n    }\r\n\r\n    this._dontFireMove = false;\r\n  };\r\n\r\n  // End interact move events and stop auto-scroll unless simulation is running\r\n\r\n\r\n  Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\r\n    var pointerIndex = this.getPointerIndex(pointer);\r\n\r\n    signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\r\n      pointer: pointer,\r\n      pointerIndex: pointerIndex,\r\n      event: event,\r\n      eventTarget: eventTarget,\r\n      curEventTarget: curEventTarget,\r\n      interaction: this\r\n    });\r\n\r\n    if (!this.simulation) {\r\n      this.end(event);\r\n    }\r\n\r\n    this.pointerIsDown = false;\r\n    this.removePointer(pointer, event);\r\n  };\r\n\r\n  /*\\\r\n   * Interaction.end\r\n   [ method ]\r\n   *\r\n   * Stop the current action and fire an end event. Inertial movement does\r\n   * not happen.\r\n   *\r\n   - event (PointerEvent) #optional\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('move', function (event) {\r\n   |     if (event.pageX > 1000) {\r\n   |       // end the current action\r\n   |       event.interaction.end();\r\n   |       // stop all further listeners from being called\r\n   |       event.stopImmediatePropagation();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n\r\n\r\n  Interaction.prototype.end = function end(event) {\r\n    event = event || this.prevEvent;\r\n\r\n    if (this.interacting()) {\r\n      signals.fire('action-end', {\r\n        event: event,\r\n        interaction: this\r\n      });\r\n    }\r\n\r\n    this.stop();\r\n  };\r\n\r\n  Interaction.prototype.currentAction = function currentAction() {\r\n    return this._interacting ? this.prepared.name : null;\r\n  };\r\n\r\n  Interaction.prototype.interacting = function interacting() {\r\n    return this._interacting;\r\n  };\r\n\r\n  Interaction.prototype.stop = function stop() {\r\n    signals.fire('stop', { interaction: this });\r\n\r\n    if (this._interacting) {\r\n      signals.fire('stop-active', { interaction: this });\r\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\r\n    }\r\n\r\n    this.target = this.element = null;\r\n\r\n    this._interacting = false;\r\n    this.prepared.name = this.prevEvent = null;\r\n  };\r\n\r\n  Interaction.prototype.getPointerIndex = function getPointerIndex(pointer) {\r\n    // mouse and pen interactions may have only one pointer\r\n    if (this.pointerType === 'mouse' || this.pointerType === 'pen') {\r\n      return 0;\r\n    }\r\n\r\n    return utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\r\n  };\r\n\r\n  Interaction.prototype.updatePointer = function updatePointer(pointer, event) {\r\n    var down = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : event && /(down|start)$/i.test(event.type);\r\n\r\n    var id = utils.getPointerId(pointer);\r\n    var index = this.getPointerIndex(pointer);\r\n\r\n    if (index === -1) {\r\n      index = this.pointerIds.length;\r\n      this.pointerIds[index] = id;\r\n    }\r\n\r\n    if (down) {\r\n      signals.fire('update-pointer-down', {\r\n        pointer: pointer,\r\n        event: event,\r\n        down: down,\r\n        pointerId: id,\r\n        pointerIndex: index,\r\n        interaction: this\r\n      });\r\n    }\r\n\r\n    this.pointers[index] = pointer;\r\n\r\n    return index;\r\n  };\r\n\r\n  Interaction.prototype.removePointer = function removePointer(pointer, event) {\r\n    var index = this.getPointerIndex(pointer);\r\n\r\n    if (index === -1) {\r\n      return;\r\n    }\r\n\r\n    signals.fire('remove-pointer', {\r\n      pointer: pointer,\r\n      event: event,\r\n      pointerIndex: index,\r\n      interaction: this\r\n    });\r\n\r\n    this.pointers.splice(index, 1);\r\n    this.pointerIds.splice(index, 1);\r\n    this.downTargets.splice(index, 1);\r\n    this.downTimes.splice(index, 1);\r\n  };\r\n\r\n  Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\r\n    this._eventTarget = target;\r\n    this._curEventTarget = currentTarget;\r\n  };\r\n\r\n  return Interaction;\r\n}();\r\n\r\nfor (var i = 0, len = methodNames.length; i < len; i++) {\r\n  var method = methodNames[i];\r\n\r\n  listeners[method] = doOnInteractions(method);\r\n}\r\n\r\nfunction doOnInteractions(method) {\r\n  return function (event) {\r\n    var pointerType = utils.getPointerType(event);\r\n\r\n    var _utils$getEventTarget = utils.getEventTargets(event),\r\n        eventTarget = _utils$getEventTarget[0],\r\n        curEventTarget = _utils$getEventTarget[1];\r\n\r\n    var matches = []; // [ [pointer, interaction], ...]\r\n\r\n    if (browser.supportsTouch && /touch/.test(event.type)) {\r\n      prevTouchTime = new Date().getTime();\r\n\r\n      for (var _i = 0; _i < event.changedTouches.length; _i++) {\r\n        var pointer = event.changedTouches[_i];\r\n        var interaction = finder.search(pointer, event.type, eventTarget);\r\n\r\n        matches.push([pointer, interaction || new Interaction({ pointerType: pointerType })]);\r\n      }\r\n    } else {\r\n      var invalidPointer = false;\r\n\r\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\r\n        // ignore mouse events while touch interactions are active\r\n        for (var _i2 = 0; _i2 < scope.interactions.length && !invalidPointer; _i2++) {\r\n          invalidPointer = scope.interactions[_i2].pointerType !== 'mouse' && scope.interactions[_i2].pointerIsDown;\r\n        }\r\n\r\n        // try to ignore mouse events that are simulated by the browser\r\n        // after a touch event\r\n        invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500\r\n        // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\r\n        || event.timeStamp === 0;\r\n      }\r\n\r\n      if (!invalidPointer) {\r\n        var _interaction = finder.search(event, event.type, eventTarget);\r\n\r\n        if (!_interaction) {\r\n          _interaction = new Interaction({ pointerType: pointerType });\r\n        }\r\n\r\n        matches.push([event, _interaction]);\r\n      }\r\n    }\r\n\r\n    for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref2;\r\n\r\n      if (_isArray) {\r\n        if (_i3 >= _iterator.length) break;\r\n        _ref2 = _iterator[_i3++];\r\n      } else {\r\n        _i3 = _iterator.next();\r\n        if (_i3.done) break;\r\n        _ref2 = _i3.value;\r\n      }\r\n\r\n      var _ref3 = _ref2,\r\n          _pointer = _ref3[0],\r\n          _interaction2 = _ref3[1];\r\n\r\n      _interaction2._updateEventTargets(eventTarget, curEventTarget);\r\n      _interaction2[method](_pointer, event, eventTarget, curEventTarget);\r\n    }\r\n  };\r\n}\r\n\r\nfunction endAll(event) {\r\n  for (var _i4 = 0; _i4 < scope.interactions.length; _i4++) {\r\n    var interaction = scope.interactions[_i4];\r\n\r\n    interaction.end(event);\r\n    signals.fire('endall', { event: event, interaction: interaction });\r\n  }\r\n}\r\n\r\nvar docEvents = {/* 'eventType': listenerFunc */};\r\nvar pEventTypes = browser.pEventTypes;\r\n\r\nif (domObjects.PointerEvent) {\r\n  docEvents[pEventTypes.down] = listeners.pointerDown;\r\n  docEvents[pEventTypes.move] = listeners.pointerMove;\r\n  docEvents[pEventTypes.up] = listeners.pointerUp;\r\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\r\n} else {\r\n  docEvents.mousedown = listeners.pointerDown;\r\n  docEvents.mousemove = listeners.pointerMove;\r\n  docEvents.mouseup = listeners.pointerUp;\r\n\r\n  docEvents.touchstart = listeners.pointerDown;\r\n  docEvents.touchmove = listeners.pointerMove;\r\n  docEvents.touchend = listeners.pointerUp;\r\n  docEvents.touchcancel = listeners.pointerUp;\r\n}\r\n\r\ndocEvents.blur = endAll;\r\n\r\nfunction onDocSignal(_ref4, signalName) {\r\n  var doc = _ref4.doc;\r\n\r\n  var eventMethod = signalName.indexOf('add') === 0 ? events.add : events.remove;\r\n\r\n  // delegate event listener\r\n  for (var eventType in scope.delegatedEvents) {\r\n    eventMethod(doc, eventType, events.delegateListener);\r\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\r\n  }\r\n\r\n  for (var _eventType in docEvents) {\r\n    eventMethod(doc, _eventType, docEvents[_eventType]);\r\n  }\r\n}\r\n\r\nsignals.on('update-pointer-down', function (_ref5) {\r\n  var interaction = _ref5.interaction,\r\n      pointer = _ref5.pointer,\r\n      pointerId = _ref5.pointerId,\r\n      pointerIndex = _ref5.pointerIndex,\r\n      event = _ref5.event,\r\n      eventTarget = _ref5.eventTarget,\r\n      down = _ref5.down;\r\n\r\n  interaction.pointerIds[pointerIndex] = pointerId;\r\n  interaction.pointers[pointerIndex] = pointer;\r\n\r\n  if (down) {\r\n    interaction.pointerIsDown = true;\r\n  }\r\n\r\n  if (!interaction.interacting()) {\r\n    utils.setCoords(interaction.startCoords, interaction.pointers);\r\n\r\n    utils.copyCoords(interaction.curCoords, interaction.startCoords);\r\n    utils.copyCoords(interaction.prevCoords, interaction.startCoords);\r\n\r\n    interaction.downEvent = event;\r\n    interaction.downTimes[pointerIndex] = interaction.curCoords.timeStamp;\r\n    interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\r\n    interaction.pointerWasMoved = false;\r\n\r\n    utils.pointerExtend(interaction.downPointer, pointer);\r\n  }\r\n});\r\n\r\nscope.signals.on('add-document', onDocSignal);\r\nscope.signals.on('remove-document', onDocSignal);\r\n\r\nInteraction.pointerMoveTolerance = 1;\r\nInteraction.doOnInteractions = doOnInteractions;\r\nInteraction.endAll = endAll;\r\nInteraction.signals = signals;\r\nInteraction.docEvents = docEvents;\r\n\r\nscope.endAllInteractions = endAll;\r\n\r\nmodule.exports = Interaction;\r\n\r\n},{\"./scope\":34,\"./utils\":44,\"./utils/Signals\":35,\"./utils/browser\":37,\"./utils/domObjects\":38,\"./utils/events\":40,\"./utils/interactionFinder\":45}],6:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar Interaction = require('../Interaction');\r\nvar InteractEvent = require('../InteractEvent');\r\n\r\nvar actions = {\r\n  firePrepared: firePrepared,\r\n  names: [],\r\n  methodDict: {}\r\n};\r\n\r\nInteraction.signals.on('action-start', function (_ref) {\r\n  var interaction = _ref.interaction,\r\n      event = _ref.event;\r\n\r\n  interaction._interacting = true;\r\n  firePrepared(interaction, event, 'start');\r\n});\r\n\r\nInteraction.signals.on('action-move', function (_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      event = _ref2.event,\r\n      preEnd = _ref2.preEnd;\r\n\r\n  firePrepared(interaction, event, 'move', preEnd);\r\n\r\n  // if the action was ended in a listener\r\n  if (!interaction.interacting()) {\r\n    return false;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('action-end', function (_ref3) {\r\n  var interaction = _ref3.interaction,\r\n      event = _ref3.event;\r\n\r\n  firePrepared(interaction, event, 'end');\r\n});\r\n\r\nfunction firePrepared(interaction, event, phase, preEnd) {\r\n  var actionName = interaction.prepared.name;\r\n\r\n  var newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\r\n\r\n  interaction.target.fire(newEvent);\r\n  interaction.prevEvent = newEvent;\r\n}\r\n\r\nmodule.exports = actions;\r\n\r\n},{\"../InteractEvent\":3,\"../Interaction\":5}],7:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar actions = require('./base');\r\nvar utils = require('../utils');\r\nvar InteractEvent = require('../InteractEvent');\r\nvar Interactable = require('../Interactable');\r\nvar Interaction = require('../Interaction');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\nvar drag = {\r\n  defaults: {\r\n    enabled: false,\r\n    mouseButtons: null,\r\n\r\n    origin: null,\r\n    snap: null,\r\n    restrict: null,\r\n    inertia: null,\r\n    autoScroll: null,\r\n\r\n    startAxis: 'xy',\r\n    lockAxis: 'xy'\r\n  },\r\n\r\n  checker: function checker(pointer, event, interactable) {\r\n    var dragOptions = interactable.options.drag;\r\n\r\n    return dragOptions.enabled ? { name: 'drag', axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis } : null;\r\n  },\r\n\r\n  getCursor: function getCursor() {\r\n    return 'move';\r\n  }\r\n};\r\n\r\nInteraction.signals.on('before-action-move', function (_ref) {\r\n  var interaction = _ref.interaction;\r\n\r\n  if (interaction.prepared.name !== 'drag') {\r\n    return;\r\n  }\r\n\r\n  var axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    interaction.curCoords.page.y = interaction.startCoords.page.y;\r\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\r\n\r\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\r\n    interaction.pointerDelta.client.vy = 0;\r\n    interaction.pointerDelta.page.vy = 0;\r\n  } else if (axis === 'y') {\r\n    interaction.curCoords.page.x = interaction.startCoords.page.x;\r\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\r\n\r\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\r\n    interaction.pointerDelta.client.vx = 0;\r\n    interaction.pointerDelta.page.vx = 0;\r\n  }\r\n});\r\n\r\n// dragmove\r\nInteractEvent.signals.on('new', function (_ref2) {\r\n  var iEvent = _ref2.iEvent,\r\n      interaction = _ref2.interaction;\r\n\r\n  if (iEvent.type !== 'dragmove') {\r\n    return;\r\n  }\r\n\r\n  var axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    iEvent.pageY = interaction.startCoords.page.y;\r\n    iEvent.clientY = interaction.startCoords.client.y;\r\n    iEvent.dy = 0;\r\n  } else if (axis === 'y') {\r\n    iEvent.pageX = interaction.startCoords.page.x;\r\n    iEvent.clientX = interaction.startCoords.client.x;\r\n    iEvent.dx = 0;\r\n  }\r\n});\r\n\r\n/*\\\r\n * Interactable.draggable\r\n [ method ]\r\n *\r\n * Gets or sets whether drag actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of drag events\r\n | var isDraggable = interact('ul li').draggable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\r\n = (object) This Interactable\r\n | interact(element).draggable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // the axis in which the first movement must be\r\n |     // for the drag sequence to start\r\n |     // 'xy' by default - any direction\r\n |     startAxis: 'x' || 'y' || 'xy',\r\n |\r\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\r\n |     // 'x' or 'y' to restrict movement to either axis\r\n |     // 'start' to restrict movement to the axis the drag started in\r\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\r\n |\r\n |     // max number of drags that can happen concurrently\r\n |     // with elements of this Interactable. Infinity by default\r\n |     max: Infinity,\r\n |\r\n |     // max number of drags that can target the same element+Interactable\r\n |     // 1 by default\r\n |     maxPerElement: 2\r\n | });\r\n\\*/\r\nInteractable.prototype.draggable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.drag.enabled = options.enabled === false ? false : true;\r\n    this.setPerAction('drag', options);\r\n    this.setOnEvents('drag', options);\r\n\r\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\r\n      this.options.drag.lockAxis = options.lockAxis;\r\n    }\r\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\r\n      this.options.drag.startAxis = options.startAxis;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.drag.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ondragstart = this.ondragstart = this.ondragend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drag;\r\n};\r\n\r\nactions.drag = drag;\r\nactions.names.push('drag');\r\nutils.merge(Interactable.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'draginertiaresume', 'dragend']);\r\nactions.methodDict.drag = 'draggable';\r\n\r\ndefaultOptions.drag = drag.defaults;\r\n\r\nmodule.exports = drag;\r\n\r\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":44,\"./base\":6}],8:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar actions = require('./base');\r\nvar utils = require('../utils');\r\nvar scope = require('../scope');\r\nvar interact = require('../interact');\r\nvar InteractEvent = require('../InteractEvent');\r\nvar Interactable = require('../Interactable');\r\nvar Interaction = require('../Interaction');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\nvar drop = {\r\n  defaults: {\r\n    enabled: false,\r\n    accept: null,\r\n    overlap: 'pointer'\r\n  }\r\n};\r\n\r\nvar dynamicDrop = false;\r\n\r\nInteraction.signals.on('action-start', function (_ref) {\r\n  var interaction = _ref.interaction,\r\n      event = _ref.event;\r\n\r\n  if (interaction.prepared.name !== 'drag') {\r\n    return;\r\n  }\r\n\r\n  // reset active dropzones\r\n  interaction.activeDrops.dropzones = [];\r\n  interaction.activeDrops.elements = [];\r\n  interaction.activeDrops.rects = [];\r\n\r\n  interaction.dropEvents = null;\r\n\r\n  if (!interaction.dynamicDrop) {\r\n    setActiveDrops(interaction, interaction.element);\r\n  }\r\n\r\n  var dragEvent = interaction.prevEvent;\r\n  var dropEvents = getDropEvents(interaction, event, dragEvent);\r\n\r\n  if (dropEvents.activate) {\r\n    fireActiveDrops(interaction, dropEvents.activate);\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('new', function (_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      iEvent = _ref2.iEvent,\r\n      event = _ref2.event;\r\n\r\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\r\n    return;\r\n  }\r\n\r\n  var draggableElement = interaction.element;\r\n  var dragEvent = iEvent;\r\n  var dropResult = getDrop(dragEvent, event, draggableElement);\r\n\r\n  interaction.dropTarget = dropResult.dropzone;\r\n  interaction.dropElement = dropResult.element;\r\n\r\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\r\n});\r\n\r\nInteraction.signals.on('action-move', function (_ref3) {\r\n  var interaction = _ref3.interaction;\r\n\r\n  if (interaction.prepared.name !== 'drag') {\r\n    return;\r\n  }\r\n\r\n  fireDropEvents(interaction, interaction.dropEvents);\r\n});\r\n\r\nInteraction.signals.on('action-end', function (_ref4) {\r\n  var interaction = _ref4.interaction;\r\n\r\n  if (interaction.prepared.name === 'drag') {\r\n    fireDropEvents(interaction, interaction.dropEvents);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-drag', function (_ref5) {\r\n  var interaction = _ref5.interaction;\r\n\r\n  interaction.activeDrops.dropzones = interaction.activeDrops.elements = interaction.activeDrops.rects = interaction.dropEvents = null;\r\n});\r\n\r\nfunction collectDrops(interaction, element) {\r\n  var drops = [];\r\n  var elements = [];\r\n\r\n  element = element || interaction.element;\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (var _iterator = scope.interactables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n    var _ref6;\r\n\r\n    if (_isArray) {\r\n      if (_i >= _iterator.length) break;\r\n      _ref6 = _iterator[_i++];\r\n    } else {\r\n      _i = _iterator.next();\r\n      if (_i.done) break;\r\n      _ref6 = _i.value;\r\n    }\r\n\r\n    var current = _ref6;\r\n\r\n    if (!current.options.drop.enabled) {\r\n      continue;\r\n    }\r\n\r\n    var accept = current.options.drop.accept;\r\n\r\n    // test the draggable element against the dropzone's accept setting\r\n    if (utils.is.element(accept) && accept !== element || utils.is.string(accept) && !utils.matchesSelector(element, accept)) {\r\n\r\n      continue;\r\n    }\r\n\r\n    // query for new elements if necessary\r\n    var dropElements = utils.is.string(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\r\n\r\n    for (var i = 0; i < dropElements.length; i++) {\r\n      var currentElement = dropElements[i];\r\n\r\n      if (currentElement !== element) {\r\n        drops.push(current);\r\n        elements.push(currentElement);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    elements: elements,\r\n    dropzones: drops\r\n  };\r\n}\r\n\r\nfunction fireActiveDrops(interaction, event) {\r\n  var prevElement = void 0;\r\n\r\n  // loop through all active dropzones and trigger event\r\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    var current = interaction.activeDrops.dropzones[i];\r\n    var currentElement = interaction.activeDrops.elements[i];\r\n\r\n    // prevent trigger of duplicate events on same element\r\n    if (currentElement !== prevElement) {\r\n      // set current element as event target\r\n      event.target = currentElement;\r\n      current.fire(event);\r\n    }\r\n    prevElement = currentElement;\r\n  }\r\n}\r\n\r\n// Collect a new set of possible drops and save them in activeDrops.\r\n// setActiveDrops should always be called when a drag has just started or a\r\n// drag event happens while dynamicDrop is true\r\nfunction setActiveDrops(interaction, dragElement) {\r\n  // get dropzones and their elements that could receive the draggable\r\n  var possibleDrops = collectDrops(interaction, dragElement, true);\r\n\r\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\r\n  interaction.activeDrops.elements = possibleDrops.elements;\r\n  interaction.activeDrops.rects = [];\r\n\r\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    interaction.activeDrops.rects[i] = interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\r\n  }\r\n}\r\n\r\nfunction getDrop(dragEvent, event, dragElement) {\r\n  var interaction = dragEvent.interaction;\r\n  var validDrops = [];\r\n\r\n  if (dynamicDrop) {\r\n    setActiveDrops(interaction, dragElement);\r\n  }\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\r\n    var current = interaction.activeDrops.dropzones[j];\r\n    var currentElement = interaction.activeDrops.elements[j];\r\n    var rect = interaction.activeDrops.rects[j];\r\n\r\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\r\n  }\r\n\r\n  // get the most appropriate dropzone based on DOM depth and order\r\n  var dropIndex = utils.indexOfDeepestElement(validDrops);\r\n\r\n  return {\r\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\r\n    element: interaction.activeDrops.elements[dropIndex] || null\r\n  };\r\n}\r\n\r\nfunction getDropEvents(interaction, pointerEvent, dragEvent) {\r\n  var dropEvents = {\r\n    enter: null,\r\n    leave: null,\r\n    activate: null,\r\n    deactivate: null,\r\n    move: null,\r\n    drop: null\r\n  };\r\n\r\n  var tmpl = {\r\n    dragEvent: dragEvent,\r\n    interaction: interaction,\r\n    target: interaction.dropElement,\r\n    dropzone: interaction.dropTarget,\r\n    relatedTarget: dragEvent.target,\r\n    draggable: dragEvent.interactable,\r\n    timeStamp: dragEvent.timeStamp\r\n  };\r\n\r\n  if (interaction.dropElement !== interaction.prevDropElement) {\r\n    // if there was a prevDropTarget, create a dragleave event\r\n    if (interaction.prevDropTarget) {\r\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\r\n\r\n      dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\r\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\r\n    }\r\n    // if the dropTarget is not null, create a dragenter event\r\n    if (interaction.dropTarget) {\r\n      dropEvents.enter = {\r\n        dragEvent: dragEvent,\r\n        interaction: interaction,\r\n        target: interaction.dropElement,\r\n        dropzone: interaction.dropTarget,\r\n        relatedTarget: dragEvent.target,\r\n        draggable: dragEvent.interactable,\r\n        timeStamp: dragEvent.timeStamp,\r\n        type: 'dragenter'\r\n      };\r\n\r\n      dragEvent.dragEnter = interaction.dropElement;\r\n      dragEvent.dropzone = interaction.dropTarget;\r\n    }\r\n  }\r\n\r\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\r\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n    dragEvent.relatedTarget = interaction.dropElement;\r\n  }\r\n  if (dragEvent.type === 'dragstart') {\r\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\r\n\r\n    dropEvents.activate.target = null;\r\n    dropEvents.activate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragend') {\r\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\r\n\r\n    dropEvents.deactivate.target = null;\r\n    dropEvents.deactivate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\r\n    dropEvents.move = utils.extend({\r\n      dragmove: dragEvent,\r\n      type: 'dropmove'\r\n    }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n  }\r\n\r\n  return dropEvents;\r\n}\r\n\r\nfunction fireDropEvents(interaction, dropEvents) {\r\n  if (dropEvents.leave) {\r\n    interaction.prevDropTarget.fire(dropEvents.leave);\r\n  }\r\n  if (dropEvents.move) {\r\n    interaction.dropTarget.fire(dropEvents.move);\r\n  }\r\n  if (dropEvents.enter) {\r\n    interaction.dropTarget.fire(dropEvents.enter);\r\n  }\r\n  if (dropEvents.drop) {\r\n    interaction.dropTarget.fire(dropEvents.drop);\r\n  }\r\n  if (dropEvents.deactivate) {\r\n    fireActiveDrops(interaction, dropEvents.deactivate);\r\n  }\r\n\r\n  interaction.prevDropTarget = interaction.dropTarget;\r\n  interaction.prevDropElement = interaction.dropElement;\r\n}\r\n\r\n/*\\\r\n * Interactable.dropzone\r\n [ method ]\r\n *\r\n * Returns or sets whether elements can be dropped onto this\r\n * Interactable to trigger drop events\r\n *\r\n * Dropzones can receive the following events:\r\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\r\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\r\n *  - `dragmove` when a draggable that has entered the dropzone is moved\r\n *  - `drop` when a draggable is dropped into this dropzone\r\n *\r\n * Use the `accept` option to allow only elements that match the given CSS\r\n * selector or element. The value can be:\r\n *\r\n *  - **an Element** - only that element can be dropped into this dropzone.\r\n *  - **a string**, - the element being dragged must match it as a CSS selector.\r\n *  - **`null`** - accept options is cleared - it accepts any element.\r\n *\r\n * Use the `overlap` option to set how drops are checked for. The allowed\r\n * values are:\r\n *\r\n *   - `'pointer'`, the pointer must be over the dropzone (default)\r\n *   - `'center'`, the draggable element's center must be over the dropzone\r\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\r\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\r\n *   over the dropzone\r\n *\r\n * Use the `checker` option to specify a function to check if a dragged\r\n * element is over this Interactable.\r\n *\r\n | interact(target)\r\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\r\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\r\n |                       dropped,           // bool result of the default checker\r\n |                       dropzone,          // dropzone Interactable\r\n |                       dropElement,       // dropzone elemnt\r\n |                       draggable,         // draggable Interactable\r\n |                       draggableElement) {// draggable element\r\n |\r\n |   return dropped && event.target.hasAttribute('allow-drop');\r\n | }\r\n *\r\n *\r\n - options (boolean | object | null) #optional The new value to be set.\r\n | interact('.drop').dropzone({\r\n |   accept: '.can-drop' || document.getElementById('single-drop'),\r\n |   overlap: 'pointer' || 'center' || zeroToOne\r\n | }\r\n = (boolean | object) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.dropzone = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.drop.enabled = options.enabled === false ? false : true;\r\n\r\n    if (utils.is.function(options.ondrop)) {\r\n      this.events.ondrop = options.ondrop;\r\n    }\r\n    if (utils.is.function(options.ondropactivate)) {\r\n      this.events.ondropactivate = options.ondropactivate;\r\n    }\r\n    if (utils.is.function(options.ondropdeactivate)) {\r\n      this.events.ondropdeactivate = options.ondropdeactivate;\r\n    }\r\n    if (utils.is.function(options.ondragenter)) {\r\n      this.events.ondragenter = options.ondragenter;\r\n    }\r\n    if (utils.is.function(options.ondragleave)) {\r\n      this.events.ondragleave = options.ondragleave;\r\n    }\r\n    if (utils.is.function(options.ondropmove)) {\r\n      this.events.ondropmove = options.ondropmove;\r\n    }\r\n\r\n    if (/^(pointer|center)$/.test(options.overlap)) {\r\n      this.options.drop.overlap = options.overlap;\r\n    } else if (utils.is.number(options.overlap)) {\r\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\r\n    }\r\n    if ('accept' in options) {\r\n      this.options.drop.accept = options.accept;\r\n    }\r\n    if ('checker' in options) {\r\n      this.options.drop.checker = options.checker;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.drop.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ondragenter = this.ondragleave = this.ondrop = this.ondropactivate = this.ondropdeactivate = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drop;\r\n};\r\n\r\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\r\n  var dropped = false;\r\n\r\n  // if the dropzone has no rect (eg. display: none)\r\n  // call the custom dropChecker or just return false\r\n  if (!(rect = rect || this.getRect(dropElement))) {\r\n    return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\r\n  }\r\n\r\n  var dropOverlap = this.options.drop.overlap;\r\n\r\n  if (dropOverlap === 'pointer') {\r\n    var origin = utils.getOriginXY(draggable, draggableElement, 'drag');\r\n    var page = utils.getPageXY(dragEvent);\r\n\r\n    page.x += origin.x;\r\n    page.y += origin.y;\r\n\r\n    var horizontal = page.x > rect.left && page.x < rect.right;\r\n    var vertical = page.y > rect.top && page.y < rect.bottom;\r\n\r\n    dropped = horizontal && vertical;\r\n  }\r\n\r\n  var dragRect = draggable.getRect(draggableElement);\r\n\r\n  if (dragRect && dropOverlap === 'center') {\r\n    var cx = dragRect.left + dragRect.width / 2;\r\n    var cy = dragRect.top + dragRect.height / 2;\r\n\r\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\r\n  }\r\n\r\n  if (dragRect && utils.is.number(dropOverlap)) {\r\n    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\r\n\r\n    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\r\n\r\n    dropped = overlapRatio >= dropOverlap;\r\n  }\r\n\r\n  if (this.options.drop.checker) {\r\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\r\n  }\r\n\r\n  return dropped;\r\n};\r\n\r\nInteractable.signals.on('unset', function (_ref7) {\r\n  var interactable = _ref7.interactable;\r\n\r\n  interactable.dropzone(false);\r\n});\r\n\r\nInteractable.settingsMethods.push('dropChecker');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.dropTarget = null; // the dropzone a drag target might be dropped into\r\n  interaction.dropElement = null; // the element at the time of checking\r\n  interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\r\n  interaction.prevDropElement = null; // the element at the time of checking\r\n  interaction.dropEvents = null; // the dropEvents related to the current drag event\r\n\r\n  interaction.activeDrops = {\r\n    dropzones: [], // the dropzones that are mentioned below\r\n    elements: [], // elements of dropzones that accept the target draggable\r\n    rects: [] // the rects of the elements mentioned above\r\n  };\r\n});\r\n\r\nInteraction.signals.on('stop', function (_ref8) {\r\n  var interaction = _ref8.interaction;\r\n\r\n  interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\r\n});\r\n\r\n/*\\\r\n * interact.dynamicDrop\r\n [ method ]\r\n *\r\n * Returns or sets whether the dimensions of dropzone elements are\r\n * calculated on every dragmove or only on dragstart for the default\r\n * dropChecker\r\n *\r\n - newValue (boolean) #optional True to check on each move. False to check only before start\r\n = (boolean | interact) The current setting or interact\r\n\\*/\r\ninteract.dynamicDrop = function (newValue) {\r\n  if (utils.is.bool(newValue)) {\r\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\r\n    //calcRects(dropzones);\r\n    //}\r\n\r\n    dynamicDrop = newValue;\r\n\r\n    return interact;\r\n  }\r\n  return dynamicDrop;\r\n};\r\n\r\nutils.merge(Interactable.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\r\nactions.methodDict.drop = 'dropzone';\r\n\r\ndefaultOptions.drop = drop.defaults;\r\n\r\nmodule.exports = drop;\r\n\r\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../interact\":21,\"../scope\":34,\"../utils\":44,\"./base\":6}],9:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar actions = require('./base');\r\nvar utils = require('../utils');\r\nvar InteractEvent = require('../InteractEvent');\r\nvar Interactable = require('../Interactable');\r\nvar Interaction = require('../Interaction');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\nvar gesture = {\r\n  defaults: {\r\n    enabled: false,\r\n    origin: null,\r\n    restrict: null\r\n  },\r\n\r\n  checker: function checker(pointer, event, interactable, element, interaction) {\r\n    if (interaction.pointerIds.length >= 2) {\r\n      return { name: 'gesture' };\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  getCursor: function getCursor() {\r\n    return '';\r\n  }\r\n};\r\n\r\nInteractEvent.signals.on('new', function (_ref) {\r\n  var iEvent = _ref.iEvent,\r\n      interaction = _ref.interaction;\r\n\r\n  if (iEvent.type !== 'gesturestart') {\r\n    return;\r\n  }\r\n  iEvent.ds = 0;\r\n\r\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\r\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\r\n  interaction.gesture.scale = 1;\r\n});\r\n\r\nInteractEvent.signals.on('new', function (_ref2) {\r\n  var iEvent = _ref2.iEvent,\r\n      interaction = _ref2.interaction;\r\n\r\n  if (iEvent.type !== 'gesturemove') {\r\n    return;\r\n  }\r\n\r\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\r\n\r\n  interaction.target.fire(iEvent);\r\n\r\n  interaction.gesture.prevAngle = iEvent.angle;\r\n  interaction.gesture.prevDistance = iEvent.distance;\r\n\r\n  if (iEvent.scale !== Infinity && iEvent.scale !== null && iEvent.scale !== undefined && !isNaN(iEvent.scale)) {\r\n\r\n    interaction.gesture.scale = iEvent.scale;\r\n  }\r\n});\r\n\r\n/*\\\r\n * Interactable.gesturable\r\n [ method ]\r\n *\r\n * Gets or sets whether multitouch gestures can be performed on the\r\n * Interactable's element\r\n *\r\n = (boolean) Indicates if this can be the target of gesture events\r\n   | var isGestureable = interact(element).gesturable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\r\n = (object) this Interactable\r\n | interact(element).gesturable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // limit multiple gestures.\r\n |     // See the explanation in @Interactable.draggable example\r\n |     max: Infinity,\r\n |     maxPerElement: 1,\r\n | });\r\n\\*/\r\nInteractable.prototype.gesturable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.gesture.enabled = options.enabled === false ? false : true;\r\n    this.setPerAction('gesture', options);\r\n    this.setOnEvents('gesture', options);\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.gesture.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.gesture;\r\n};\r\n\r\nInteractEvent.signals.on('set-delta', function (_ref3) {\r\n  var interaction = _ref3.interaction,\r\n      iEvent = _ref3.iEvent,\r\n      action = _ref3.action,\r\n      event = _ref3.event,\r\n      starting = _ref3.starting,\r\n      ending = _ref3.ending,\r\n      deltaSource = _ref3.deltaSource;\r\n\r\n  if (action !== 'gesture') {\r\n    return;\r\n  }\r\n\r\n  var pointers = interaction.pointers;\r\n\r\n  iEvent.touches = [pointers[0], pointers[1]];\r\n\r\n  if (starting) {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box = utils.touchBBox(pointers);\r\n    iEvent.scale = 1;\r\n    iEvent.ds = 0;\r\n    iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\r\n    iEvent.da = 0;\r\n  } else if (ending || event instanceof InteractEvent) {\r\n    iEvent.distance = interaction.prevEvent.distance;\r\n    iEvent.box = interaction.prevEvent.box;\r\n    iEvent.scale = interaction.prevEvent.scale;\r\n    iEvent.ds = iEvent.scale - 1;\r\n    iEvent.angle = interaction.prevEvent.angle;\r\n    iEvent.da = iEvent.angle - interaction.gesture.startAngle;\r\n  } else {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box = utils.touchBBox(pointers);\r\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\r\n    iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\r\n\r\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\r\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.gesture = {\r\n    start: { x: 0, y: 0 },\r\n\r\n    startDistance: 0, // distance between two touches of touchStart\r\n    prevDistance: 0,\r\n    distance: 0,\r\n\r\n    scale: 1, // gesture.distance / gesture.startDistance\r\n\r\n    startAngle: 0, // angle of line joining two touches\r\n    prevAngle: 0 // angle of the previous gesture event\r\n  };\r\n});\r\n\r\nactions.gesture = gesture;\r\nactions.names.push('gesture');\r\nutils.merge(Interactable.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);\r\nactions.methodDict.gesture = 'gesturable';\r\n\r\ndefaultOptions.gesture = gesture.defaults;\r\n\r\nmodule.exports = gesture;\r\n\r\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":44,\"./base\":6}],10:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar actions = require('./base');\r\nvar utils = require('../utils');\r\nvar browser = require('../utils/browser');\r\nvar InteractEvent = require('../InteractEvent');\r\nvar Interactable = require('../Interactable');\r\nvar Interaction = require('../Interaction');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\n// Less Precision with touch input\r\nvar defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\r\n\r\nvar resize = {\r\n  defaults: {\r\n    enabled: false,\r\n    mouseButtons: null,\r\n\r\n    origin: null,\r\n    snap: null,\r\n    restrict: null,\r\n    inertia: null,\r\n    autoScroll: null,\r\n\r\n    square: false,\r\n    preserveAspectRatio: false,\r\n    axis: 'xy',\r\n\r\n    // use default margin\r\n    margin: NaN,\r\n\r\n    // object with props left, right, top, bottom which are\r\n    // true/false values to resize when the pointer is over that edge,\r\n    // CSS selectors to match the handles for each direction\r\n    // or the Elements for each handle\r\n    edges: null,\r\n\r\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n    // 'negate' will alow the rect to have negative width/height\r\n    // 'reposition' will keep the width/height positive by swapping\r\n    // the top and bottom edges and/or swapping the left and right edges\r\n    invert: 'none'\r\n  },\r\n\r\n  checker: function checker(pointer, event, interactable, element, interaction, rect) {\r\n    if (!rect) {\r\n      return null;\r\n    }\r\n\r\n    var page = utils.extend({}, interaction.curCoords.page);\r\n    var options = interactable.options;\r\n\r\n    if (options.resize.enabled) {\r\n      var resizeOptions = options.resize;\r\n      var resizeEdges = { left: false, right: false, top: false, bottom: false };\r\n\r\n      // if using resize.edges\r\n      if (utils.is.object(resizeOptions.edges)) {\r\n        for (var edge in resizeEdges) {\r\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || defaultMargin);\r\n        }\r\n\r\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\r\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\r\n\r\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\r\n          return {\r\n            name: 'resize',\r\n            edges: resizeEdges\r\n          };\r\n        }\r\n      } else {\r\n        var right = options.resize.axis !== 'y' && page.x > rect.right - defaultMargin;\r\n        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - defaultMargin;\r\n\r\n        if (right || bottom) {\r\n          return {\r\n            name: 'resize',\r\n            axes: (right ? 'x' : '') + (bottom ? 'y' : '')\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  cursors: browser.isIe9OrOlder ? {\r\n    x: 'e-resize',\r\n    y: 's-resize',\r\n    xy: 'se-resize',\r\n\r\n    top: 'n-resize',\r\n    left: 'w-resize',\r\n    bottom: 's-resize',\r\n    right: 'e-resize',\r\n    topleft: 'se-resize',\r\n    bottomright: 'se-resize',\r\n    topright: 'ne-resize',\r\n    bottomleft: 'ne-resize'\r\n  } : {\r\n    x: 'ew-resize',\r\n    y: 'ns-resize',\r\n    xy: 'nwse-resize',\r\n\r\n    top: 'ns-resize',\r\n    left: 'ew-resize',\r\n    bottom: 'ns-resize',\r\n    right: 'ew-resize',\r\n    topleft: 'nwse-resize',\r\n    bottomright: 'nwse-resize',\r\n    topright: 'nesw-resize',\r\n    bottomleft: 'nesw-resize'\r\n  },\r\n\r\n  getCursor: function getCursor(action) {\r\n    if (action.axis) {\r\n      return resize.cursors[action.name + action.axis];\r\n    } else if (action.edges) {\r\n      var cursorKey = '';\r\n      var edgeNames = ['top', 'bottom', 'left', 'right'];\r\n\r\n      for (var i = 0; i < 4; i++) {\r\n        if (action.edges[edgeNames[i]]) {\r\n          cursorKey += edgeNames[i];\r\n        }\r\n      }\r\n\r\n      return resize.cursors[cursorKey];\r\n    }\r\n  }\r\n};\r\n\r\n// resizestart\r\nInteractEvent.signals.on('new', function (_ref) {\r\n  var iEvent = _ref.iEvent,\r\n      interaction = _ref.interaction;\r\n\r\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\r\n    return;\r\n  }\r\n\r\n  var startRect = interaction.target.getRect(interaction.element);\r\n  var resizeOptions = interaction.target.options.resize;\r\n\r\n  /*\r\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\r\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\r\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\r\n   * on the active edges and the edge being interacted with.\r\n   */\r\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\r\n    var linkedEdges = utils.extend({}, interaction.prepared.edges);\r\n\r\n    linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\r\n    linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\r\n    linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\r\n    linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\r\n\r\n    interaction.prepared._linkedEdges = linkedEdges;\r\n  } else {\r\n    interaction.prepared._linkedEdges = null;\r\n  }\r\n\r\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\r\n  if (resizeOptions.preserveAspectRatio) {\r\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\r\n  }\r\n\r\n  interaction.resizeRects = {\r\n    start: startRect,\r\n    current: utils.extend({}, startRect),\r\n    inverted: utils.extend({}, startRect),\r\n    previous: utils.extend({}, startRect),\r\n    delta: {\r\n      left: 0, right: 0, width: 0,\r\n      top: 0, bottom: 0, height: 0\r\n    }\r\n  };\r\n\r\n  iEvent.rect = interaction.resizeRects.inverted;\r\n  iEvent.deltaRect = interaction.resizeRects.delta;\r\n});\r\n\r\n// resizemove\r\nInteractEvent.signals.on('new', function (_ref2) {\r\n  var iEvent = _ref2.iEvent,\r\n      phase = _ref2.phase,\r\n      interaction = _ref2.interaction;\r\n\r\n  if (phase !== 'move' || !interaction.prepared.edges) {\r\n    return;\r\n  }\r\n\r\n  var resizeOptions = interaction.target.options.resize;\r\n  var invert = resizeOptions.invert;\r\n  var invertible = invert === 'reposition' || invert === 'negate';\r\n\r\n  var edges = interaction.prepared.edges;\r\n\r\n  var start = interaction.resizeRects.start;\r\n  var current = interaction.resizeRects.current;\r\n  var inverted = interaction.resizeRects.inverted;\r\n  var delta = interaction.resizeRects.delta;\r\n  var previous = utils.extend(interaction.resizeRects.previous, inverted);\r\n  var originalEdges = edges;\r\n\r\n  var dx = iEvent.dx;\r\n  var dy = iEvent.dy;\r\n\r\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\r\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\r\n    var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\r\n\r\n    edges = interaction.prepared._linkedEdges;\r\n\r\n    if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\r\n      dy = -dx / startAspectRatio;\r\n    } else if (originalEdges.left || originalEdges.right) {\r\n      dy = dx / startAspectRatio;\r\n    } else if (originalEdges.top || originalEdges.bottom) {\r\n      dx = dy * startAspectRatio;\r\n    }\r\n  }\r\n\r\n  // update the 'current' rect without modifications\r\n  if (edges.top) {\r\n    current.top += dy;\r\n  }\r\n  if (edges.bottom) {\r\n    current.bottom += dy;\r\n  }\r\n  if (edges.left) {\r\n    current.left += dx;\r\n  }\r\n  if (edges.right) {\r\n    current.right += dx;\r\n  }\r\n\r\n  if (invertible) {\r\n    // if invertible, copy the current rect\r\n    utils.extend(inverted, current);\r\n\r\n    if (invert === 'reposition') {\r\n      // swap edge values if necessary to keep width/height positive\r\n      var swap = void 0;\r\n\r\n      if (inverted.top > inverted.bottom) {\r\n        swap = inverted.top;\r\n\r\n        inverted.top = inverted.bottom;\r\n        inverted.bottom = swap;\r\n      }\r\n      if (inverted.left > inverted.right) {\r\n        swap = inverted.left;\r\n\r\n        inverted.left = inverted.right;\r\n        inverted.right = swap;\r\n      }\r\n    }\r\n  } else {\r\n    // if not invertible, restrict to minimum of 0x0 rect\r\n    inverted.top = Math.min(current.top, start.bottom);\r\n    inverted.bottom = Math.max(current.bottom, start.top);\r\n    inverted.left = Math.min(current.left, start.right);\r\n    inverted.right = Math.max(current.right, start.left);\r\n  }\r\n\r\n  inverted.width = inverted.right - inverted.left;\r\n  inverted.height = inverted.bottom - inverted.top;\r\n\r\n  for (var edge in inverted) {\r\n    delta[edge] = inverted[edge] - previous[edge];\r\n  }\r\n\r\n  iEvent.edges = interaction.prepared.edges;\r\n  iEvent.rect = inverted;\r\n  iEvent.deltaRect = delta;\r\n});\r\n\r\n/*\\\r\n * Interactable.resizable\r\n [ method ]\r\n *\r\n * Gets or sets whether resize actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of resize elements\r\n   | var isResizeable = interact('input[type=text]').resizable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\r\n = (object) This Interactable\r\n   | interact(element).resizable({\r\n   |   onstart: function (event) {},\r\n   |   onmove : function (event) {},\r\n   |   onend  : function (event) {},\r\n   |\r\n   |   edges: {\r\n   |     top   : true,       // Use pointer coords to check for resize.\r\n   |     left  : false,      // Disable resizing from left edge.\r\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\r\n   |     right : handleEl    // Resize if pointer target is the given Element\r\n   |   },\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height are adjusted at a 1:1 ratio.\r\n   |     square: false,\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height maintain the aspect ratio they had when resizing started.\r\n   |     preserveAspectRatio: false,\r\n   |\r\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n   |   // 'negate' will allow the rect to have negative width/height\r\n   |   // 'reposition' will keep the width/height positive by swapping\r\n   |   // the top and bottom edges and/or swapping the left and right edges\r\n   |   invert: 'none' || 'negate' || 'reposition'\r\n   |\r\n   |   // limit multiple resizes.\r\n   |   // See the explanation in the @Interactable.draggable example\r\n   |   max: Infinity,\r\n   |   maxPerElement: 1,\r\n   | });\r\n  \\*/\r\nInteractable.prototype.resizable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.resize.enabled = options.enabled === false ? false : true;\r\n    this.setPerAction('resize', options);\r\n    this.setOnEvents('resize', options);\r\n\r\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\r\n      this.options.resize.axis = options.axis;\r\n    } else if (options.axis === null) {\r\n      this.options.resize.axis = defaultOptions.resize.axis;\r\n    }\r\n\r\n    if (utils.is.bool(options.preserveAspectRatio)) {\r\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\r\n    } else if (utils.is.bool(options.square)) {\r\n      this.options.resize.square = options.square;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  if (utils.is.bool(options)) {\r\n    this.options.resize.enabled = options;\r\n\r\n    if (!options) {\r\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  return this.options.resize;\r\n};\r\n\r\nfunction checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\r\n  // false, '', undefined, null\r\n  if (!value) {\r\n    return false;\r\n  }\r\n\r\n  // true value, use pointer coords and element rect\r\n  if (value === true) {\r\n    // if dimensions are negative, \"switch\" edges\r\n    var width = utils.is.number(rect.width) ? rect.width : rect.right - rect.left;\r\n    var height = utils.is.number(rect.height) ? rect.height : rect.bottom - rect.top;\r\n\r\n    if (width < 0) {\r\n      if (name === 'left') {\r\n        name = 'right';\r\n      } else if (name === 'right') {\r\n        name = 'left';\r\n      }\r\n    }\r\n    if (height < 0) {\r\n      if (name === 'top') {\r\n        name = 'bottom';\r\n      } else if (name === 'bottom') {\r\n        name = 'top';\r\n      }\r\n    }\r\n\r\n    if (name === 'left') {\r\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin;\r\n    }\r\n    if (name === 'top') {\r\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\r\n    }\r\n\r\n    if (name === 'right') {\r\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin;\r\n    }\r\n    if (name === 'bottom') {\r\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\r\n    }\r\n  }\r\n\r\n  // the remaining checks require an element\r\n  if (!utils.is.element(element)) {\r\n    return false;\r\n  }\r\n\r\n  return utils.is.element(value)\r\n  // the value is an element to use as a resize handle\r\n  ? value === element\r\n  // otherwise check if element matches value as selector\r\n  : utils.matchesUpTo(element, value, interactableElement);\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.resizeAxes = 'xy';\r\n});\r\n\r\nInteractEvent.signals.on('set-delta', function (_ref3) {\r\n  var interaction = _ref3.interaction,\r\n      iEvent = _ref3.iEvent,\r\n      action = _ref3.action;\r\n\r\n  if (action !== 'resize' || !interaction.resizeAxes) {\r\n    return;\r\n  }\r\n\r\n  var options = interaction.target.options;\r\n\r\n  if (options.resize.square) {\r\n    if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = iEvent.dy;\r\n    } else {\r\n      iEvent.dy = iEvent.dx;\r\n    }\r\n    iEvent.axes = 'xy';\r\n  } else {\r\n    iEvent.axes = interaction.resizeAxes;\r\n\r\n    if (interaction.resizeAxes === 'x') {\r\n      iEvent.dy = 0;\r\n    } else if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = 0;\r\n    }\r\n  }\r\n});\r\n\r\nactions.resize = resize;\r\nactions.names.push('resize');\r\nutils.merge(Interactable.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeinertiaresume', 'resizeend']);\r\nactions.methodDict.resize = 'resizable';\r\n\r\ndefaultOptions.resize = resize.defaults;\r\n\r\nmodule.exports = resize;\r\n\r\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":44,\"../utils/browser\":37,\"./base\":6}],11:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar raf = require('./utils/raf');\r\nvar getWindow = require('./utils/window').getWindow;\r\nvar is = require('./utils/is');\r\nvar domUtils = require('./utils/domUtils');\r\nvar Interaction = require('./Interaction');\r\nvar defaultOptions = require('./defaultOptions');\r\n\r\nvar autoScroll = {\r\n  defaults: {\r\n    enabled: false,\r\n    container: null, // the item that is scrolled (Window or HTMLElement)\r\n    margin: 60,\r\n    speed: 300 // the scroll speed in pixels per second\r\n  },\r\n\r\n  interaction: null,\r\n  i: null, // the handle returned by window.setInterval\r\n  x: 0, y: 0, // Direction each pulse is to scroll in\r\n\r\n  isScrolling: false,\r\n  prevTime: 0,\r\n\r\n  start: function start(interaction) {\r\n    autoScroll.isScrolling = true;\r\n    raf.cancel(autoScroll.i);\r\n\r\n    autoScroll.interaction = interaction;\r\n    autoScroll.prevTime = new Date().getTime();\r\n    autoScroll.i = raf.request(autoScroll.scroll);\r\n  },\r\n\r\n  stop: function stop() {\r\n    autoScroll.isScrolling = false;\r\n    raf.cancel(autoScroll.i);\r\n  },\r\n\r\n  // scroll the window by the values in scroll.x/y\r\n  scroll: function scroll() {\r\n    var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\r\n    var container = options.container || getWindow(autoScroll.interaction.element);\r\n    var now = new Date().getTime();\r\n    // change in time in seconds\r\n    var dt = (now - autoScroll.prevTime) / 1000;\r\n    // displacement\r\n    var s = options.speed * dt;\r\n\r\n    if (s >= 1) {\r\n      if (is.window(container)) {\r\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\r\n      } else if (container) {\r\n        container.scrollLeft += autoScroll.x * s;\r\n        container.scrollTop += autoScroll.y * s;\r\n      }\r\n\r\n      autoScroll.prevTime = now;\r\n    }\r\n\r\n    if (autoScroll.isScrolling) {\r\n      raf.cancel(autoScroll.i);\r\n      autoScroll.i = raf.request(autoScroll.scroll);\r\n    }\r\n  },\r\n  check: function check(interactable, actionName) {\r\n    var options = interactable.options;\r\n\r\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\r\n  },\r\n  onInteractionMove: function onInteractionMove(_ref) {\r\n    var interaction = _ref.interaction,\r\n        pointer = _ref.pointer;\r\n\r\n    if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\r\n      return;\r\n    }\r\n\r\n    if (interaction.simulation) {\r\n      autoScroll.x = autoScroll.y = 0;\r\n      return;\r\n    }\r\n\r\n    var top = void 0;\r\n    var right = void 0;\r\n    var bottom = void 0;\r\n    var left = void 0;\r\n\r\n    var options = interaction.target.options[interaction.prepared.name].autoScroll;\r\n    var container = options.container || getWindow(interaction.element);\r\n\r\n    if (is.window(container)) {\r\n      left = pointer.clientX < autoScroll.margin;\r\n      top = pointer.clientY < autoScroll.margin;\r\n      right = pointer.clientX > container.innerWidth - autoScroll.margin;\r\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\r\n    } else {\r\n      var rect = domUtils.getElementClientRect(container);\r\n\r\n      left = pointer.clientX < rect.left + autoScroll.margin;\r\n      top = pointer.clientY < rect.top + autoScroll.margin;\r\n      right = pointer.clientX > rect.right - autoScroll.margin;\r\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\r\n    }\r\n\r\n    autoScroll.x = right ? 1 : left ? -1 : 0;\r\n    autoScroll.y = bottom ? 1 : top ? -1 : 0;\r\n\r\n    if (!autoScroll.isScrolling) {\r\n      // set the autoScroll properties to those of the target\r\n      autoScroll.margin = options.margin;\r\n      autoScroll.speed = options.speed;\r\n\r\n      autoScroll.start(interaction);\r\n    }\r\n  }\r\n};\r\n\r\nInteraction.signals.on('stop-active', function () {\r\n  autoScroll.stop();\r\n});\r\n\r\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\r\n\r\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\r\n\r\nmodule.exports = autoScroll;\r\n\r\n},{\"./Interaction\":5,\"./defaultOptions\":18,\"./utils/domUtils\":39,\"./utils/is\":46,\"./utils/raf\":50,\"./utils/window\":52}],12:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar Interactable = require('../Interactable');\r\nvar actions = require('../actions/base');\r\nvar is = require('../utils/is');\r\nvar domUtils = require('../utils/domUtils');\r\n\r\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\r\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\r\n\r\n  if (this.options.actionChecker) {\r\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\r\n  }\r\n\r\n  return action;\r\n};\r\n\r\n/*\\\r\n * Interactable.ignoreFrom\r\n [ method ]\r\n *\r\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\r\n * event or any of it's parents match the given CSS selector or\r\n * Element, no drag/resize/gesture is started.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\r\n = (string | Element | object) The current ignoreFrom value or this Interactable\r\n **\r\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\r\n | // or\r\n | interact(element).ignoreFrom('input, textarea, a');\r\n\\*/\r\nInteractable.prototype.ignoreFrom = function (newValue) {\r\n  return this._backCompatOption('ignoreFrom', newValue);\r\n};\r\n\r\n/*\\\r\n * Interactable.allowFrom\r\n [ method ]\r\n *\r\n * A drag/resize/gesture is started only If the target of the\r\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\r\n * parents match the given CSS selector or Element.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\r\n = (string | Element | object) The current allowFrom value or this Interactable\r\n **\r\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\r\n | // or\r\n | interact(element).allowFrom('.handle');\r\n\\*/\r\nInteractable.prototype.allowFrom = function (newValue) {\r\n  return this._backCompatOption('allowFrom', newValue);\r\n};\r\n\r\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\r\n  if (!ignoreFrom || !is.element(element)) {\r\n    return false;\r\n  }\r\n\r\n  if (is.string(ignoreFrom)) {\r\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\r\n  } else if (is.element(ignoreFrom)) {\r\n    return domUtils.nodeContains(ignoreFrom, element);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\r\n  if (!allowFrom) {\r\n    return true;\r\n  }\r\n\r\n  if (!is.element(element)) {\r\n    return false;\r\n  }\r\n\r\n  if (is.string(allowFrom)) {\r\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\r\n  } else if (is.element(allowFrom)) {\r\n    return domUtils.nodeContains(allowFrom, element);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\r\n  return !this.testIgnore(options.ignoreFrom, interactableElement, eventTarget) && this.testAllow(options.allowFrom, interactableElement, eventTarget);\r\n};\r\n\r\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\r\nInteractable.prototype.actionChecker = function (checker) {\r\n  if (is.function(checker)) {\r\n    this.options.actionChecker = checker;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (checker === null) {\r\n    delete this.options.actionChecker;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.actionChecker;\r\n};\r\n\r\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.styleCursor = function (newValue) {\r\n  if (is.bool(newValue)) {\r\n    this.options.styleCursor = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (newValue === null) {\r\n    delete this.options.styleCursor;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.styleCursor;\r\n};\r\n\r\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\r\n  var rect = this.getRect(element);\r\n  var action = null;\r\n\r\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n    var _ref;\r\n\r\n    if (_isArray) {\r\n      if (_i >= _iterator.length) break;\r\n      _ref = _iterator[_i++];\r\n    } else {\r\n      _i = _iterator.next();\r\n      if (_i.done) break;\r\n      _ref = _i.value;\r\n    }\r\n\r\n    var actionName = _ref;\r\n\r\n    // check mouseButton setting if the pointer is down\r\n    if (interaction.pointerIsDown && interaction.mouse && (event.buttons & this.options[actionName].mouseButtons) === 0) {\r\n      continue;\r\n    }\r\n\r\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\r\n\r\n    if (action) {\r\n      return action;\r\n    }\r\n  }\r\n};\r\n\r\n},{\"../Interactable\":4,\"../actions/base\":6,\"../utils/domUtils\":39,\"../utils/is\":46}],13:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar interact = require('../interact');\r\nvar Interactable = require('../Interactable');\r\nvar Interaction = require('../Interaction');\r\nvar actions = require('../actions/base');\r\nvar defaultOptions = require('../defaultOptions');\r\nvar browser = require('../utils/browser');\r\nvar scope = require('../scope');\r\nvar utils = require('../utils');\r\nvar signals = require('../utils/Signals').new();\r\n\r\nrequire('./InteractableMethods');\r\n\r\nvar autoStart = {\r\n  signals: signals,\r\n  withinInteractionLimit: withinInteractionLimit,\r\n  // Allow this many interactions to happen simultaneously\r\n  maxInteractions: Infinity,\r\n  defaults: {\r\n    perAction: {\r\n      manualStart: false,\r\n      max: Infinity,\r\n      maxPerElement: 1,\r\n      allowFrom: null,\r\n      ignoreFrom: null\r\n    }\r\n  },\r\n  setActionDefaults: function setActionDefaults(action) {\r\n    utils.extend(action.defaults, autoStart.defaults.perAction);\r\n  }\r\n};\r\n\r\n// set cursor style on mousedown\r\nInteraction.signals.on('down', function (_ref) {\r\n  var interaction = _ref.interaction,\r\n      pointer = _ref.pointer,\r\n      event = _ref.event,\r\n      eventTarget = _ref.eventTarget;\r\n\r\n  if (interaction.interacting()) {\r\n    return;\r\n  }\r\n\r\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\n// set cursor style on mousemove\r\nInteraction.signals.on('move', function (_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      pointer = _ref2.pointer,\r\n      event = _ref2.event,\r\n      eventTarget = _ref2.eventTarget;\r\n\r\n  if (!interaction.mouse || interaction.pointerIsDown || interaction.interacting()) {\r\n    return;\r\n  }\r\n\r\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\nInteraction.signals.on('move', function (arg) {\r\n  var interaction = arg.interaction,\r\n      event = arg.event;\r\n\r\n\r\n  if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {\r\n    return;\r\n  }\r\n\r\n  signals.fire('before-start', arg);\r\n\r\n  var target = interaction.target;\r\n\r\n  if (interaction.prepared.name && target) {\r\n    // check manualStart and interaction limit\r\n    if (target.options[interaction.prepared.name].manualStart || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\r\n      interaction.stop(event);\r\n    } else {\r\n      interaction.start(interaction.prepared, target, interaction.element);\r\n    }\r\n  }\r\n});\r\n\r\n// Check if the current target supports the action.\r\n// If so, return the validated action. Otherwise, return null\r\nfunction validateAction(action, interactable, element, eventTarget) {\r\n  if (utils.is.object(action) && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action)) {\r\n    return action;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction validateSelector(interaction, pointer, event, matches, matchElements, eventTarget) {\r\n  for (var i = 0, len = matches.length; i < len; i++) {\r\n    var match = matches[i];\r\n    var matchElement = matchElements[i];\r\n    var action = validateAction(match.getAction(pointer, event, interaction, matchElement), match, matchElement, eventTarget);\r\n\r\n    if (action) {\r\n      return {\r\n        action: action,\r\n        target: match,\r\n        element: matchElement\r\n      };\r\n    }\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction getActionInfo(interaction, pointer, event, eventTarget) {\r\n  var matches = [];\r\n  var matchElements = [];\r\n\r\n  var element = eventTarget;\r\n  var action = null;\r\n\r\n  function pushMatches(interactable, selector, context) {\r\n    var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\r\n\r\n    if (utils.matchesSelector(element, selector, elements)) {\r\n\r\n      matches.push(interactable);\r\n      matchElements.push(element);\r\n    }\r\n  }\r\n\r\n  while (utils.is.element(element)) {\r\n    matches = [];\r\n    matchElements = [];\r\n\r\n    var elementInteractable = scope.interactables.get(element);\r\n\r\n    if (elementInteractable && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element, eventTarget), elementInteractable, element, eventTarget)) && !elementInteractable.options[action.name].manualStart) {\r\n      return {\r\n        element: element,\r\n        action: action,\r\n        target: elementInteractable\r\n      };\r\n    } else {\r\n      scope.interactables.forEachSelector(pushMatches, element);\r\n\r\n      var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\r\n\r\n      if (actionInfo.action && !actionInfo.target.options[actionInfo.action.name].manualStart) {\r\n        return actionInfo;\r\n      }\r\n    }\r\n\r\n    element = utils.parentNode(element);\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction prepare(interaction, _ref3) {\r\n  var action = _ref3.action,\r\n      target = _ref3.target,\r\n      element = _ref3.element;\r\n\r\n  action = action || {};\r\n\r\n  if (interaction.target && interaction.target.options.styleCursor) {\r\n    interaction.target._doc.documentElement.style.cursor = '';\r\n  }\r\n\r\n  interaction.target = target;\r\n  interaction.element = element;\r\n  utils.copyAction(interaction.prepared, action);\r\n\r\n  if (target && target.options.styleCursor) {\r\n    var cursor = action ? actions[action.name].getCursor(action) : '';\r\n    interaction.target._doc.documentElement.style.cursor = cursor;\r\n  }\r\n\r\n  signals.fire('prepared', { interaction: interaction });\r\n}\r\n\r\nInteraction.signals.on('stop', function (_ref4) {\r\n  var interaction = _ref4.interaction;\r\n\r\n  var target = interaction.target;\r\n\r\n  if (target && target.options.styleCursor) {\r\n    target._doc.documentElement.style.cursor = '';\r\n  }\r\n});\r\n\r\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\r\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\r\n\r\n  if (this.options.actionChecker) {\r\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\r\n  }\r\n\r\n  return action;\r\n};\r\n\r\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\r\nInteractable.prototype.actionChecker = function (checker) {\r\n  if (utils.is.function(checker)) {\r\n    this.options.actionChecker = checker;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (checker === null) {\r\n    delete this.options.actionChecker;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.actionChecker;\r\n};\r\n\r\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.styleCursor = function (newValue) {\r\n  if (utils.is.bool(newValue)) {\r\n    this.options.styleCursor = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (newValue === null) {\r\n    delete this.options.styleCursor;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.styleCursor;\r\n};\r\n\r\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\r\n  var rect = this.getRect(element);\r\n  var buttons = event.buttons || {\r\n    0: 1,\r\n    1: 4,\r\n    3: 8,\r\n    4: 16\r\n  }[event.button];\r\n  var action = null;\r\n\r\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n    var _ref5;\r\n\r\n    if (_isArray) {\r\n      if (_i >= _iterator.length) break;\r\n      _ref5 = _iterator[_i++];\r\n    } else {\r\n      _i = _iterator.next();\r\n      if (_i.done) break;\r\n      _ref5 = _i.value;\r\n    }\r\n\r\n    var actionName = _ref5;\r\n\r\n    // check mouseButton setting if the pointer is down\r\n    if (interaction.pointerIsDown && interaction.mouse && (buttons & this.options[actionName].mouseButtons) === 0) {\r\n      continue;\r\n    }\r\n\r\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\r\n\r\n    if (action) {\r\n      return action;\r\n    }\r\n  }\r\n};\r\n\r\nfunction withinInteractionLimit(interactable, element, action) {\r\n  var options = interactable.options;\r\n  var maxActions = options[action.name].max;\r\n  var maxPerElement = options[action.name].maxPerElement;\r\n  var activeInteractions = 0;\r\n  var targetCount = 0;\r\n  var targetElementCount = 0;\r\n\r\n  // no actions if any of these values == 0\r\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) {\r\n    return;\r\n  }\r\n\r\n  for (var i = 0, len = scope.interactions.length; i < len; i++) {\r\n    var interaction = scope.interactions[i];\r\n    var otherAction = interaction.prepared.name;\r\n\r\n    if (!interaction.interacting()) {\r\n      continue;\r\n    }\r\n\r\n    activeInteractions++;\r\n\r\n    if (activeInteractions >= autoStart.maxInteractions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.target !== interactable) {\r\n      continue;\r\n    }\r\n\r\n    targetCount += otherAction === action.name | 0;\r\n\r\n    if (targetCount >= maxActions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.element === element) {\r\n      targetElementCount++;\r\n\r\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return autoStart.maxInteractions > 0;\r\n}\r\n\r\n/*\\\r\n * interact.maxInteractions\r\n [ method ]\r\n **\r\n * Returns or sets the maximum number of concurrent interactions allowed.\r\n * By default only 1 interaction is allowed at a time (for backwards\r\n * compatibility). To allow multiple interactions on the same Interactables\r\n * and elements, you need to enable it in the draggable, resizable and\r\n * gesturable `'max'` and `'maxPerElement'` options.\r\n **\r\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\r\n\\*/\r\ninteract.maxInteractions = function (newValue) {\r\n  if (utils.is.number(newValue)) {\r\n    autoStart.maxInteractions = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return autoStart.maxInteractions;\r\n};\r\n\r\nInteractable.settingsMethods.push('styleCursor');\r\nInteractable.settingsMethods.push('actionChecker');\r\nInteractable.settingsMethods.push('ignoreFrom');\r\nInteractable.settingsMethods.push('allowFrom');\r\n\r\ndefaultOptions.base.actionChecker = null;\r\ndefaultOptions.base.styleCursor = true;\r\n\r\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\r\n\r\nmodule.exports = autoStart;\r\n\r\n},{\"../Interactable\":4,\"../Interaction\":5,\"../actions/base\":6,\"../defaultOptions\":18,\"../interact\":21,\"../scope\":34,\"../utils\":44,\"../utils/Signals\":35,\"../utils/browser\":37,\"./InteractableMethods\":12}],14:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar autoStart = require('./base');\r\nvar Interaction = require('../Interaction');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.delayTimer = null;\r\n});\r\n\r\nautoStart.signals.on('prepared', function (_ref) {\r\n  var interaction = _ref.interaction;\r\n\r\n  var actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) {\r\n    return;\r\n  }\r\n\r\n  var delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.delayTimer = setTimeout(function () {\r\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\r\n    }, delay);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('move', function (_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      duplicate = _ref2.duplicate;\r\n\r\n  if (interaction.pointerWasMoved && !duplicate) {\r\n    clearTimeout(interaction.delayTimer);\r\n  }\r\n});\r\n\r\n// prevent regular down->move autoStart\r\nautoStart.signals.on('before-start', function (_ref3) {\r\n  var interaction = _ref3.interaction;\r\n\r\n  var actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) {\r\n    return;\r\n  }\r\n\r\n  var delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.prepared.name = null;\r\n  }\r\n});\r\n\r\n},{\"../Interaction\":5,\"./base\":13}],15:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar autoStart = require('./base');\r\nvar scope = require('../scope');\r\nvar browser = require('../utils/browser');\r\nvar is = require('../utils/is');\r\n\r\nvar _require = require('../utils/domUtils'),\r\n    matchesSelector = _require.matchesSelector,\r\n    parentNode = _require.parentNode;\r\n\r\nautoStart.setActionDefaults(require('../actions/drag'));\r\n\r\nautoStart.signals.on('before-start', function (_ref) {\r\n  var interaction = _ref.interaction,\r\n      eventTarget = _ref.eventTarget,\r\n      dx = _ref.dx,\r\n      dy = _ref.dy;\r\n\r\n  if (interaction.prepared.name !== 'drag') {\r\n    return;\r\n  }\r\n\r\n  // check if a drag is in the correct axis\r\n  var absX = Math.abs(dx);\r\n  var absY = Math.abs(dy);\r\n  var options = interaction.target.options.drag;\r\n  var startAxis = options.startAxis;\r\n  var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\r\n\r\n  interaction.prepared.axis = options.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\r\n  : options.lockAxis;\r\n\r\n  // if the movement isn't in the startAxis of the interactable\r\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\r\n    // cancel the prepared action\r\n    interaction.prepared.name = null;\r\n\r\n    // then try to get a drag from another ineractable\r\n\r\n    if (!interaction.prepared.name) {\r\n\r\n      var element = eventTarget;\r\n\r\n      var getDraggable = function getDraggable(interactable, selector, context) {\r\n        var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\r\n\r\n        if (interactable === interaction.target) {\r\n          return;\r\n        }\r\n\r\n        if (!options.manualStart && !interactable.testIgnoreAllow(options, element, eventTarget) && matchesSelector(element, selector, elements)) {\r\n\r\n          var _action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\r\n\r\n          if (_action && _action.name === 'drag' && checkStartAxis(currentAxis, interactable) && autoStart.validateAction(_action, interactable, element, eventTarget)) {\r\n\r\n            return interactable;\r\n          }\r\n        }\r\n      };\r\n\r\n      var action = null;\r\n\r\n      // check all interactables\r\n      while (is.element(element)) {\r\n        var elementInteractable = scope.interactables.get(element);\r\n\r\n        if (elementInteractable && elementInteractable !== interaction.target && !elementInteractable.options.drag.manualStart) {\r\n\r\n          action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\r\n        }\r\n        if (action && action.name === 'drag' && checkStartAxis(currentAxis, elementInteractable)) {\r\n\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = elementInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        var selectorInteractable = scope.interactables.forEachSelector(getDraggable, element);\r\n\r\n        if (selectorInteractable) {\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = selectorInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        element = parentNode(element);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nfunction checkStartAxis(startAxis, interactable) {\r\n  if (!interactable) {\r\n    return false;\r\n  }\r\n\r\n  var thisAxis = interactable.options.drag.startAxis;\r\n\r\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\r\n}\r\n\r\n},{\"../actions/drag\":7,\"../scope\":34,\"../utils/browser\":37,\"../utils/domUtils\":39,\"../utils/is\":46,\"./base\":13}],16:[function(require,module,exports){\r\n'use strict';\r\n\r\nrequire('./base').setActionDefaults(require('../actions/gesture'));\r\n\r\n},{\"../actions/gesture\":9,\"./base\":13}],17:[function(require,module,exports){\r\n'use strict';\r\n\r\nrequire('./base').setActionDefaults(require('../actions/resize'));\r\n\r\n},{\"../actions/resize\":10,\"./base\":13}],18:[function(require,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = {\r\n  base: {\r\n    accept: null,\r\n    preventDefault: 'auto',\r\n    deltaSource: 'page'\r\n  },\r\n\r\n  perAction: {\r\n    origin: { x: 0, y: 0 },\r\n\r\n    // only allow left button by default\r\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\r\n    mouseButtons: 1,\r\n\r\n    inertia: {\r\n      enabled: false,\r\n      resistance: 10, // the lambda in exponential decay\r\n      minSpeed: 100, // target speed must be above this for inertia to start\r\n      endSpeed: 10, // the speed at which inertia is slow enough to stop\r\n      allowResume: true, // allow resuming an action in inertia phase\r\n      smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\r\n    }\r\n  }\r\n};\r\n\r\n},{}],19:[function(require,module,exports){\r\n'use strict';\r\n\r\n/* browser entry point */\r\n\r\n// Legacy browser support\r\nrequire('./legacyBrowsers');\r\n\r\n// inertia\r\nrequire('./inertia');\r\n\r\n// modifiers\r\nrequire('./modifiers/snap');\r\nrequire('./modifiers/restrict');\r\n\r\n// pointerEvents\r\nrequire('./pointerEvents/base');\r\nrequire('./pointerEvents/holdRepeat');\r\nrequire('./pointerEvents/interactableTargets');\r\n\r\n// delay\r\nrequire('./autoStart/delay');\r\n\r\n// actions\r\nrequire('./actions/gesture');\r\nrequire('./actions/resize');\r\nrequire('./actions/drag');\r\nrequire('./actions/drop');\r\n\r\n// load these modifiers after resize is loaded\r\nrequire('./modifiers/snapSize');\r\nrequire('./modifiers/restrictEdges');\r\nrequire('./modifiers/restrictSize');\r\n\r\n// autoStart actions\r\nrequire('./autoStart/gesture');\r\nrequire('./autoStart/resize');\r\nrequire('./autoStart/drag');\r\n\r\n// Interactable preventDefault setting\r\nrequire('./interactablePreventDefault.js');\r\n\r\n// autoScroll\r\nrequire('./autoScroll');\r\n\r\n// export interact\r\nmodule.exports = require('./interact');\r\n\r\n},{\"./actions/drag\":7,\"./actions/drop\":8,\"./actions/gesture\":9,\"./actions/resize\":10,\"./autoScroll\":11,\"./autoStart/delay\":14,\"./autoStart/drag\":15,\"./autoStart/gesture\":16,\"./autoStart/resize\":17,\"./inertia\":20,\"./interact\":21,\"./interactablePreventDefault.js\":22,\"./legacyBrowsers\":23,\"./modifiers/restrict\":25,\"./modifiers/restrictEdges\":26,\"./modifiers/restrictSize\":27,\"./modifiers/snap\":28,\"./modifiers/snapSize\":29,\"./pointerEvents/base\":31,\"./pointerEvents/holdRepeat\":32,\"./pointerEvents/interactableTargets\":33}],20:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar InteractEvent = require('./InteractEvent');\r\nvar Interaction = require('./Interaction');\r\nvar modifiers = require('./modifiers');\r\nvar utils = require('./utils');\r\nvar animationFrame = require('./utils/raf');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.inertiaStatus = {\r\n    active: false,\r\n    smoothEnd: false,\r\n    allowResume: false,\r\n\r\n    startEvent: null,\r\n    upCoords: {},\r\n\r\n    xe: 0, ye: 0,\r\n    sx: 0, sy: 0,\r\n\r\n    t0: 0,\r\n    vx0: 0, vys: 0,\r\n    duration: 0,\r\n\r\n    lambda_v0: 0,\r\n    one_ve_v0: 0,\r\n    i: null\r\n  };\r\n\r\n  interaction.boundInertiaFrame = function () {\r\n    return inertiaFrame.apply(interaction);\r\n  };\r\n  interaction.boundSmoothEndFrame = function () {\r\n    return smoothEndFrame.apply(interaction);\r\n  };\r\n});\r\n\r\nInteraction.signals.on('down', function (_ref) {\r\n  var interaction = _ref.interaction,\r\n      event = _ref.event,\r\n      pointer = _ref.pointer,\r\n      eventTarget = _ref.eventTarget;\r\n\r\n  var status = interaction.inertiaStatus;\r\n\r\n  // Check if the down event hits the current inertia target\r\n  if (status.active) {\r\n    var element = eventTarget;\r\n\r\n    // climb up the DOM tree from the event target\r\n    while (utils.is.element(element)) {\r\n\r\n      // if interaction element is the current inertia target element\r\n      if (element === interaction.element) {\r\n        // stop inertia\r\n        animationFrame.cancel(status.i);\r\n        status.active = false;\r\n        interaction.simulation = null;\r\n\r\n        // update pointers to the down event's coordinates\r\n        interaction.updatePointer(pointer);\r\n        utils.setCoords(interaction.curCoords, interaction.pointers);\r\n\r\n        // fire appropriate signals\r\n        var signalArg = { interaction: interaction };\r\n        Interaction.signals.fire('before-action-move', signalArg);\r\n        Interaction.signals.fire('action-resume', signalArg);\r\n\r\n        // fire a reume event\r\n        var resumeEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiaresume', interaction.element);\r\n\r\n        interaction.target.fire(resumeEvent);\r\n        interaction.prevEvent = resumeEvent;\r\n        modifiers.resetStatuses(interaction.modifierStatuses);\r\n\r\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\r\n        break;\r\n      }\r\n\r\n      element = utils.parentNode(element);\r\n    }\r\n  }\r\n});\r\n\r\nInteraction.signals.on('up', function (_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      event = _ref2.event;\r\n\r\n  var status = interaction.inertiaStatus;\r\n\r\n  if (!interaction.interacting() || status.active) {\r\n    return;\r\n  }\r\n\r\n  var target = interaction.target;\r\n  var options = target && target.options;\r\n  var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\r\n\r\n  var now = new Date().getTime();\r\n  var statuses = {};\r\n  var page = utils.extend({}, interaction.curCoords.page);\r\n  var pointerSpeed = interaction.pointerDelta.client.speed;\r\n\r\n  var smoothEnd = false;\r\n  var modifierResult = void 0;\r\n\r\n  // check if inertia should be started\r\n  var inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\r\n\r\n  var inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\r\n\r\n  var modifierArg = {\r\n    interaction: interaction,\r\n    pageCoords: page,\r\n    statuses: statuses,\r\n    preEnd: true,\r\n    requireEndOnly: true\r\n  };\r\n\r\n  // smoothEnd\r\n  if (inertiaPossible && !inertia) {\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(modifierArg);\r\n\r\n    if (modifierResult.shouldMove && modifierResult.locked) {\r\n      smoothEnd = true;\r\n    }\r\n  }\r\n\r\n  if (!(inertia || smoothEnd)) {\r\n    return;\r\n  }\r\n\r\n  utils.copyCoords(status.upCoords, interaction.curCoords);\r\n\r\n  interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\r\n\r\n  status.t0 = now;\r\n\r\n  status.active = true;\r\n  status.allowResume = inertiaOptions.allowResume;\r\n  interaction.simulation = status;\r\n\r\n  target.fire(status.startEvent);\r\n\r\n  if (inertia) {\r\n    status.vx0 = interaction.pointerDelta.client.vx;\r\n    status.vy0 = interaction.pointerDelta.client.vy;\r\n    status.v0 = pointerSpeed;\r\n\r\n    calcInertia(interaction, status);\r\n\r\n    utils.extend(page, interaction.curCoords.page);\r\n\r\n    page.x += status.xe;\r\n    page.y += status.ye;\r\n\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(modifierArg);\r\n\r\n    status.modifiedXe += modifierResult.dx;\r\n    status.modifiedYe += modifierResult.dy;\r\n\r\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\r\n  } else {\r\n    status.smoothEnd = true;\r\n    status.xe = modifierResult.dx;\r\n    status.ye = modifierResult.dy;\r\n\r\n    status.sx = status.sy = 0;\r\n\r\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-active', function (_ref3) {\r\n  var interaction = _ref3.interaction;\r\n\r\n  var status = interaction.inertiaStatus;\r\n\r\n  if (status.active) {\r\n    animationFrame.cancel(status.i);\r\n    status.active = false;\r\n    interaction.simulation = null;\r\n  }\r\n});\r\n\r\nfunction calcInertia(interaction, status) {\r\n  var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\r\n  var lambda = inertiaOptions.resistance;\r\n  var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\r\n\r\n  status.x0 = interaction.prevEvent.pageX;\r\n  status.y0 = interaction.prevEvent.pageY;\r\n  status.t0 = status.startEvent.timeStamp / 1000;\r\n  status.sx = status.sy = 0;\r\n\r\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\r\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\r\n  status.te = inertiaDur;\r\n\r\n  status.lambda_v0 = lambda / status.v0;\r\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\r\n}\r\n\r\nfunction inertiaFrame() {\r\n  updateInertiaCoords(this);\r\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n\r\n  var status = this.inertiaStatus;\r\n  var options = this.target.options[this.prepared.name].inertia;\r\n  var lambda = options.resistance;\r\n  var t = new Date().getTime() / 1000 - status.t0;\r\n\r\n  if (t < status.te) {\r\n\r\n    var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\r\n\r\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\r\n      status.sx = status.xe * progress;\r\n      status.sy = status.ye * progress;\r\n    } else {\r\n      var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\r\n\r\n      status.sx = quadPoint.x;\r\n      status.sy = quadPoint.y;\r\n    }\r\n\r\n    this.doMove();\r\n\r\n    status.i = animationFrame.request(this.boundInertiaFrame);\r\n  } else {\r\n    status.sx = status.modifiedXe;\r\n    status.sy = status.modifiedYe;\r\n\r\n    this.doMove();\r\n    this.end(status.startEvent);\r\n    status.active = false;\r\n    this.simulation = null;\r\n  }\r\n\r\n  utils.copyCoords(this.prevCoords, this.curCoords);\r\n}\r\n\r\nfunction smoothEndFrame() {\r\n  updateInertiaCoords(this);\r\n\r\n  var status = this.inertiaStatus;\r\n  var t = new Date().getTime() - status.t0;\r\n  var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\r\n\r\n  if (t < duration) {\r\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\r\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n\r\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\r\n  } else {\r\n    status.sx = status.xe;\r\n    status.sy = status.ye;\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n    this.end(status.startEvent);\r\n\r\n    status.smoothEnd = status.active = false;\r\n    this.simulation = null;\r\n  }\r\n}\r\n\r\nfunction updateInertiaCoords(interaction) {\r\n  var status = interaction.inertiaStatus;\r\n\r\n  // return if inertia isn't running\r\n  if (!status.active) {\r\n    return;\r\n  }\r\n\r\n  var pageUp = status.upCoords.page;\r\n  var clientUp = status.upCoords.client;\r\n\r\n  utils.setCoords(interaction.curCoords, [{\r\n    pageX: pageUp.x + status.sx,\r\n    pageY: pageUp.y + status.sy,\r\n    clientX: clientUp.x + status.sx,\r\n    clientY: clientUp.y + status.sy\r\n  }]);\r\n}\r\n\r\n},{\"./InteractEvent\":3,\"./Interaction\":5,\"./modifiers\":24,\"./utils\":44,\"./utils/raf\":50}],21:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar browser = require('./utils/browser');\r\nvar events = require('./utils/events');\r\nvar utils = require('./utils');\r\nvar scope = require('./scope');\r\nvar Interactable = require('./Interactable');\r\nvar Interaction = require('./Interaction');\r\n\r\nvar globalEvents = {};\r\n\r\n/*\\\r\n * interact\r\n [ method ]\r\n *\r\n * The methods of this variable can be used to set elements as\r\n * interactables and also to change various default settings.\r\n *\r\n * Calling it as a function and passing an element or a valid CSS selector\r\n * string returns an Interactable object which has various methods to\r\n * configure it.\r\n *\r\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\r\n = (object) An @Interactable\r\n *\r\n > Usage\r\n | interact('#draggable').draggable(true);\r\n |\r\n | var rectables = interact('rect');\r\n | rectables\r\n |     .gesturable(true)\r\n |     .on('gesturemove', function (event) {\r\n |         // ...\r\n |     });\r\n\\*/\r\nfunction interact(element, options) {\r\n  var interactable = scope.interactables.get(element, options);\r\n\r\n  if (!interactable) {\r\n    interactable = new Interactable(element, options);\r\n    interactable.events.global = globalEvents;\r\n  }\r\n\r\n  return interactable;\r\n}\r\n\r\n/*\\\r\n * interact.isSet\r\n [ method ]\r\n *\r\n * Check if an element has been set\r\n - element (Element) The Element being searched for\r\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\r\n\\*/\r\ninteract.isSet = function (element, options) {\r\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\r\n};\r\n\r\n/*\\\r\n * interact.on\r\n [ method ]\r\n *\r\n * Adds a global listener for an InteractEvent or adds a DOM event to\r\n * `document`\r\n *\r\n - type       (string | array | object) The types of events to listen for\r\n - listener   (function) The function event (s)\r\n - options    (object | boolean) #optional options object or useCapture flag for addEventListener\r\n = (object) interact\r\n\\*/\r\ninteract.on = function (type, listener, options) {\r\n  if (utils.is.string(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.is.array(type)) {\r\n    for (var _iterator = type, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var eventType = _ref;\r\n\r\n      interact.on(eventType, listener, options);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.is.object(type)) {\r\n    for (var prop in type) {\r\n      interact.on(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  // if it is an InteractEvent type, add listener to globalEvents\r\n  if (utils.contains(Interactable.eventTypes, type)) {\r\n    // if this type of event was never bound\r\n    if (!globalEvents[type]) {\r\n      globalEvents[type] = [listener];\r\n    } else {\r\n      globalEvents[type].push(listener);\r\n    }\r\n  }\r\n  // If non InteractEvent type, addEventListener to document\r\n  else {\r\n      events.add(scope.document, type, listener, { options: options });\r\n    }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.off\r\n [ method ]\r\n *\r\n * Removes a global InteractEvent listener or DOM event from `document`\r\n *\r\n - type       (string | array | object) The types of events that were listened for\r\n - listener   (function) The listener function to be removed\r\n - options    (object | boolean) #optional options object or useCapture flag for removeEventListener\r\n = (object) interact\r\n \\*/\r\ninteract.off = function (type, listener, options) {\r\n  if (utils.is.string(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.is.array(type)) {\r\n    for (var _iterator2 = type, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n      var _ref2;\r\n\r\n      if (_isArray2) {\r\n        if (_i2 >= _iterator2.length) break;\r\n        _ref2 = _iterator2[_i2++];\r\n      } else {\r\n        _i2 = _iterator2.next();\r\n        if (_i2.done) break;\r\n        _ref2 = _i2.value;\r\n      }\r\n\r\n      var eventType = _ref2;\r\n\r\n      interact.off(eventType, listener, options);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.is.object(type)) {\r\n    for (var prop in type) {\r\n      interact.off(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (!utils.contains(Interactable.eventTypes, type)) {\r\n    events.remove(scope.document, type, listener, options);\r\n  } else {\r\n    var index = void 0;\r\n\r\n    if (type in globalEvents && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\r\n      globalEvents[type].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.debug\r\n [ method ]\r\n *\r\n * Returns an object which exposes internal data\r\n = (object) An object with properties that outline the current state and expose internal functions and variables\r\n\\*/\r\ninteract.debug = function () {\r\n  return scope;\r\n};\r\n\r\n// expose the functions used to calculate multi-touch properties\r\ninteract.getPointerAverage = utils.pointerAverage;\r\ninteract.getTouchBBox = utils.touchBBox;\r\ninteract.getTouchDistance = utils.touchDistance;\r\ninteract.getTouchAngle = utils.touchAngle;\r\n\r\ninteract.getElementRect = utils.getElementRect;\r\ninteract.getElementClientRect = utils.getElementClientRect;\r\ninteract.matchesSelector = utils.matchesSelector;\r\ninteract.closest = utils.closest;\r\n\r\n/*\\\r\n * interact.supportsTouch\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports touch input\r\n\\*/\r\ninteract.supportsTouch = function () {\r\n  return browser.supportsTouch;\r\n};\r\n\r\n/*\\\r\n * interact.supportsPointerEvent\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports PointerEvents\r\n\\*/\r\ninteract.supportsPointerEvent = function () {\r\n  return browser.supportsPointerEvent;\r\n};\r\n\r\n/*\\\r\n * interact.stop\r\n [ method ]\r\n *\r\n * Cancels all interactions (end events are not fired)\r\n *\r\n - event (Event) An event on which to call preventDefault()\r\n = (object) interact\r\n\\*/\r\ninteract.stop = function (event) {\r\n  for (var i = scope.interactions.length - 1; i >= 0; i--) {\r\n    scope.interactions[i].stop(event);\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.pointerMoveTolerance\r\n [ method ]\r\n * Returns or sets the distance the pointer must be moved before an action\r\n * sequence occurs. This also affects tolerance for tap events.\r\n *\r\n - newValue (number) #optional The movement from the start position must be greater than this value\r\n = (number | Interactable) The current setting or interact\r\n\\*/\r\ninteract.pointerMoveTolerance = function (newValue) {\r\n  if (utils.is.number(newValue)) {\r\n    Interaction.pointerMoveTolerance = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return Interaction.pointerMoveTolerance;\r\n};\r\n\r\ninteract.addDocument = scope.addDocument;\r\ninteract.removeDocument = scope.removeDocument;\r\n\r\nscope.interact = interact;\r\n\r\nmodule.exports = interact;\r\n\r\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":34,\"./utils\":44,\"./utils/browser\":37,\"./utils/events\":40}],22:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar Interactable = require('./Interactable');\r\nvar Interaction = require('./Interaction');\r\nvar scope = require('./scope');\r\nvar is = require('./utils/is');\r\nvar events = require('./utils/events');\r\n\r\nvar _require = require('./utils/domUtils'),\r\n    nodeContains = _require.nodeContains,\r\n    matchesSelector = _require.matchesSelector;\r\n\r\n/*\\\r\n * Interactable.preventDefault\r\n [ method ]\r\n *\r\n * Returns or sets whether to prevent the browser's default behaviour\r\n * in response to pointer events. Can be set to:\r\n *  - `'always'` to always prevent\r\n *  - `'never'` to never prevent\r\n *  - `'auto'` to let interact.js try to determine what would be best\r\n *\r\n - newValue (string) #optional `true`, `false` or `'auto'`\r\n = (string | Interactable) The current setting or this Interactable\r\n\\*/\r\n\r\n\r\nInteractable.prototype.preventDefault = function (newValue) {\r\n  if (/^(always|never|auto)$/.test(newValue)) {\r\n    this.options.preventDefault = newValue;\r\n    return this;\r\n  }\r\n\r\n  if (is.bool(newValue)) {\r\n    this.options.preventDefault = newValue ? 'always' : 'never';\r\n    return this;\r\n  }\r\n\r\n  return this.options.preventDefault;\r\n};\r\n\r\nInteractable.prototype.checkAndPreventDefault = function (event) {\r\n  var setting = this.options.preventDefault;\r\n\r\n  if (setting === 'never') {\r\n    return;\r\n  }\r\n\r\n  if (setting === 'always') {\r\n    event.preventDefault();\r\n    return;\r\n  }\r\n\r\n  // setting === 'auto'\r\n\r\n  // don't preventDefault if the browser supports passiveEvents\r\n  // CSS touch-action and user-selecct should be used instead\r\n  if (events.supportsOptions) {\r\n    return;\r\n  }\r\n\r\n  // don't preventDefault of pointerdown events\r\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\r\n    return;\r\n  }\r\n\r\n  // don't preventDefault on editable elements\r\n  if (is.element(event.target) && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\r\n    return;\r\n  }\r\n\r\n  event.preventDefault();\r\n};\r\n\r\nfunction onInteractionEvent(_ref) {\r\n  var interaction = _ref.interaction,\r\n      event = _ref.event;\r\n\r\n  if (interaction.target) {\r\n    interaction.target.checkAndPreventDefault(event);\r\n  }\r\n}\r\n\r\nvar _arr = ['down', 'move', 'up', 'cancel'];\r\nfor (var _i = 0; _i < _arr.length; _i++) {\r\n  var eventSignal = _arr[_i];\r\n  Interaction.signals.on(eventSignal, onInteractionEvent);\r\n}\r\n\r\n// prevent native HTML5 drag on interact.js target elements\r\nInteraction.docEvents.dragstart = function preventNativeDrag(event) {\r\n  for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n    var _ref2;\r\n\r\n    if (_isArray) {\r\n      if (_i2 >= _iterator.length) break;\r\n      _ref2 = _iterator[_i2++];\r\n    } else {\r\n      _i2 = _iterator.next();\r\n      if (_i2.done) break;\r\n      _ref2 = _i2.value;\r\n    }\r\n\r\n    var interaction = _ref2;\r\n\r\n\r\n    if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\r\n\r\n      interaction.target.checkAndPreventDefault(event);\r\n      return;\r\n    }\r\n  }\r\n};\r\n\r\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":34,\"./utils/domUtils\":39,\"./utils/events\":40,\"./utils/is\":46}],23:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar scope = require('./scope');\r\nvar events = require('./utils/events');\r\nvar browser = require('./utils/browser');\r\nvar iFinder = require('./utils/interactionFinder');\r\nvar pointerEvents = require('./pointerEvents/base');\r\n\r\nvar _require = require('./utils/window'),\r\n    window = _require.window;\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\nif (!window.Array.isArray) {\r\n  window.Array.isArray = function (obj) {\r\n    return toString.call(obj) === '[object Array]';\r\n  };\r\n}\r\n\r\nif (!String.prototype.trim) {\r\n  String.prototype.trim = function () {\r\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n  };\r\n}\r\n\r\n// http://www.quirksmode.org/dom/events/click.html\r\n// >Events leading to dblclick\r\n//\r\n// IE8 doesn't fire down event before dblclick.\r\n// This workaround tries to fire a tap and doubletap after dblclick\r\nfunction onIE8Dblclick(event) {\r\n  var eventTarget = event.target;\r\n  var interaction = iFinder.search(event, event.type, eventTarget);\r\n\r\n  if (!interaction) {\r\n    return;\r\n  }\r\n\r\n  if (interaction.prevTap && event.clientX === interaction.prevTap.clientX && event.clientY === interaction.prevTap.clientY && eventTarget === interaction.prevTap.target) {\r\n\r\n    interaction.downTargets[0] = eventTarget;\r\n    interaction.downTimes[0] = new Date().getTime();\r\n\r\n    pointerEvents.fire({\r\n      interaction: interaction,\r\n      event: event,\r\n      eventTarget: eventTarget,\r\n      pointer: event,\r\n      type: 'tap'\r\n    });\r\n  }\r\n}\r\n\r\nif (browser.isIE8) {\r\n  var selectFix = function selectFix(event) {\r\n    for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var interaction = _ref;\r\n\r\n      if (interaction.interacting()) {\r\n        interaction.target.checkAndPreventDefault(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  var onDocIE8 = function onDocIE8(_ref2, signalName) {\r\n    var doc = _ref2.doc,\r\n        win = _ref2.win;\r\n\r\n    var eventMethod = signalName.indexOf('listen') === 0 ? events.add : events.remove;\r\n\r\n    // For IE's lack of Event#preventDefault\r\n    eventMethod(doc, 'selectstart', selectFix);\r\n\r\n    if (pointerEvents) {\r\n      eventMethod(doc, 'dblclick', onIE8Dblclick);\r\n    }\r\n  };\r\n\r\n  scope.signals.on('add-document', onDocIE8);\r\n  scope.signals.on('remove-document', onDocIE8);\r\n}\r\n\r\nmodule.exports = null;\r\n\r\n},{\"./pointerEvents/base\":31,\"./scope\":34,\"./utils/browser\":37,\"./utils/events\":40,\"./utils/interactionFinder\":45,\"./utils/window\":52}],24:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar InteractEvent = require('../InteractEvent');\r\nvar Interaction = require('../Interaction');\r\nvar extend = require('../utils/extend');\r\n\r\nvar modifiers = {\r\n  names: [],\r\n\r\n  setOffsets: function setOffsets(arg) {\r\n    var interaction = arg.interaction,\r\n        page = arg.pageCoords;\r\n    var target = interaction.target,\r\n        element = interaction.element,\r\n        startOffset = interaction.startOffset;\r\n\r\n    var rect = target.getRect(element);\r\n\r\n    if (rect) {\r\n      startOffset.left = page.x - rect.left;\r\n      startOffset.top = page.y - rect.top;\r\n\r\n      startOffset.right = rect.right - page.x;\r\n      startOffset.bottom = rect.bottom - page.y;\r\n\r\n      if (!('width' in rect)) {\r\n        rect.width = rect.right - rect.left;\r\n      }\r\n      if (!('height' in rect)) {\r\n        rect.height = rect.bottom - rect.top;\r\n      }\r\n    } else {\r\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\r\n    }\r\n\r\n    arg.rect = rect;\r\n    arg.interactable = target;\r\n    arg.element = element;\r\n\r\n    for (var i = 0; i < modifiers.names.length; i++) {\r\n      var modifierName = modifiers.names[i];\r\n\r\n      arg.options = target.options[interaction.prepared.name][modifierName];\r\n\r\n      if (!arg.options) {\r\n        continue;\r\n      }\r\n\r\n      interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\r\n    }\r\n  },\r\n\r\n  setAll: function setAll(arg) {\r\n    var interaction = arg.interaction,\r\n        statuses = arg.statuses,\r\n        preEnd = arg.preEnd,\r\n        requireEndOnly = arg.requireEndOnly;\r\n\r\n    var coords = extend({}, arg.pageCoords);\r\n    var result = {\r\n      dx: 0,\r\n      dy: 0,\r\n      changed: false,\r\n      locked: false,\r\n      shouldMove: true\r\n    };\r\n\r\n    for (var _iterator = modifiers.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var modifierName = _ref;\r\n\r\n      var modifier = modifiers[modifierName];\r\n      var options = interaction.target.options[interaction.prepared.name][modifierName];\r\n\r\n      if (!shouldDo(options, preEnd, requireEndOnly)) {\r\n        continue;\r\n      }\r\n\r\n      arg.status = arg.status = statuses[modifierName];\r\n      arg.options = options;\r\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\r\n\r\n      modifier.set(arg);\r\n\r\n      if (arg.status.locked) {\r\n        coords.x += arg.status.dx;\r\n        coords.y += arg.status.dy;\r\n\r\n        result.dx += arg.status.dx;\r\n        result.dy += arg.status.dy;\r\n\r\n        result.locked = true;\r\n      }\r\n    }\r\n\r\n    // a move should be fired if:\r\n    //  - there are no modifiers enabled,\r\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\r\n    //  - the locked coords have changed since the last pointer move\r\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\r\n\r\n    return result;\r\n  },\r\n\r\n  resetStatuses: function resetStatuses(statuses) {\r\n    for (var _iterator2 = modifiers.names, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n      var _ref2;\r\n\r\n      if (_isArray2) {\r\n        if (_i2 >= _iterator2.length) break;\r\n        _ref2 = _iterator2[_i2++];\r\n      } else {\r\n        _i2 = _iterator2.next();\r\n        if (_i2.done) break;\r\n        _ref2 = _i2.value;\r\n      }\r\n\r\n      var modifierName = _ref2;\r\n\r\n      var status = statuses[modifierName] || {};\r\n\r\n      status.dx = status.dy = 0;\r\n      status.modifiedX = status.modifiedY = NaN;\r\n      status.locked = false;\r\n      status.changed = true;\r\n\r\n      statuses[modifierName] = status;\r\n    }\r\n\r\n    return statuses;\r\n  },\r\n\r\n  start: function start(_ref3, signalName) {\r\n    var interaction = _ref3.interaction;\r\n\r\n    var arg = {\r\n      interaction: interaction,\r\n      pageCoords: (signalName === 'action-resume' ? interaction.curCoords : interaction.startCoords).page,\r\n      startOffset: interaction.startOffset,\r\n      statuses: interaction.modifierStatuses,\r\n      preEnd: false,\r\n      requireEndOnly: false\r\n    };\r\n\r\n    modifiers.setOffsets(arg);\r\n    modifiers.resetStatuses(arg.statuses);\r\n\r\n    arg.pageCoords = extend({}, interaction.startCoords.page);\r\n    interaction.modifierResult = modifiers.setAll(arg);\r\n  }\r\n};\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\r\n  interaction.modifierOffsets = {};\r\n  interaction.modifierStatuses = modifiers.resetStatuses({});\r\n  interaction.modifierResult = null;\r\n});\r\n\r\nInteraction.signals.on('action-start', modifiers.start);\r\nInteraction.signals.on('action-resume', modifiers.start);\r\n\r\nInteraction.signals.on('before-action-move', function (_ref4) {\r\n  var interaction = _ref4.interaction,\r\n      preEnd = _ref4.preEnd,\r\n      interactingBeforeMove = _ref4.interactingBeforeMove;\r\n\r\n  var modifierResult = modifiers.setAll({\r\n    interaction: interaction,\r\n    preEnd: preEnd,\r\n    pageCoords: interaction.curCoords.page,\r\n    statuses: interaction.modifierStatuses,\r\n    requireEndOnly: false\r\n  });\r\n\r\n  // don't fire an action move if a modifier would keep the event in the same\r\n  // cordinates as before\r\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\r\n    interaction._dontFireMove = true;\r\n  }\r\n\r\n  interaction.modifierResult = modifierResult;\r\n});\r\n\r\nInteraction.signals.on('action-end', function (_ref5) {\r\n  var interaction = _ref5.interaction,\r\n      event = _ref5.event;\r\n\r\n  for (var i = 0; i < modifiers.names.length; i++) {\r\n    var options = interaction.target.options[interaction.prepared.name][modifiers.names[i]];\r\n\r\n    // if the endOnly option is true for any modifier\r\n    if (shouldDo(options, true, true)) {\r\n      // fire a move event at the modified coordinates\r\n      interaction.doMove({ event: event, preEnd: true });\r\n      break;\r\n    }\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('set-xy', function (arg) {\r\n  var iEvent = arg.iEvent,\r\n      interaction = arg.interaction;\r\n\r\n  var modifierArg = extend({}, arg);\r\n\r\n  for (var i = 0; i < modifiers.names.length; i++) {\r\n    var modifierName = modifiers.names[i];\r\n    modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\r\n\r\n    if (!modifierArg.options) {\r\n      continue;\r\n    }\r\n\r\n    var modifier = modifiers[modifierName];\r\n\r\n    modifierArg.status = interaction.modifierStatuses[modifierName];\r\n\r\n    iEvent[modifierName] = modifier.modifyCoords(modifierArg);\r\n  }\r\n});\r\n\r\nfunction shouldDo(options, preEnd, requireEndOnly) {\r\n  return options && options.enabled && (preEnd || !options.endOnly) && (!requireEndOnly || options.endOnly);\r\n}\r\n\r\nmodule.exports = modifiers;\r\n\r\n},{\"../InteractEvent\":3,\"../Interaction\":5,\"../utils/extend\":41}],25:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar modifiers = require('./index');\r\nvar utils = require('../utils');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\nvar restrict = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    restriction: null,\r\n    elementRect: null\r\n  },\r\n\r\n  setOffset: function setOffset(_ref) {\r\n    var rect = _ref.rect,\r\n        startOffset = _ref.startOffset,\r\n        options = _ref.options;\r\n\r\n    var elementRect = options && options.elementRect;\r\n    var offset = {};\r\n\r\n    if (rect && elementRect) {\r\n      offset.left = startOffset.left - rect.width * elementRect.left;\r\n      offset.top = startOffset.top - rect.height * elementRect.top;\r\n\r\n      offset.right = startOffset.right - rect.width * (1 - elementRect.right);\r\n      offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\r\n    } else {\r\n      offset.left = offset.top = offset.right = offset.bottom = 0;\r\n    }\r\n\r\n    return offset;\r\n  },\r\n\r\n  set: function set(_ref2) {\r\n    var pageCoords = _ref2.pageCoords,\r\n        interaction = _ref2.interaction,\r\n        status = _ref2.status,\r\n        options = _ref2.options;\r\n\r\n    if (!options) {\r\n      return status;\r\n    }\r\n\r\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\r\n\r\n    var restriction = getRestrictionRect(options.restriction, interaction, page);\r\n\r\n    if (!restriction) {\r\n      return status;\r\n    }\r\n\r\n    status.dx = 0;\r\n    status.dy = 0;\r\n    status.locked = false;\r\n\r\n    var rect = restriction;\r\n    var modifiedX = page.x;\r\n    var modifiedY = page.y;\r\n\r\n    var offset = interaction.modifierOffsets.restrict;\r\n\r\n    // object is assumed to have\r\n    // x, y, width, height or\r\n    // left, top, right, bottom\r\n    if ('x' in restriction && 'y' in restriction) {\r\n      modifiedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\r\n      modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\r\n    } else {\r\n      modifiedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\r\n      modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\r\n    }\r\n\r\n    status.dx = modifiedX - page.x;\r\n    status.dy = modifiedY - page.y;\r\n\r\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\r\n    status.locked = !!(status.dx || status.dy);\r\n\r\n    status.modifiedX = modifiedX;\r\n    status.modifiedY = modifiedY;\r\n  },\r\n\r\n  modifyCoords: function modifyCoords(_ref3) {\r\n    var page = _ref3.page,\r\n        client = _ref3.client,\r\n        status = _ref3.status,\r\n        phase = _ref3.phase,\r\n        options = _ref3.options;\r\n\r\n    var elementRect = options && options.elementRect;\r\n\r\n    if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n\r\n        return {\r\n          dx: status.dx,\r\n          dy: status.dy\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  getRestrictionRect: getRestrictionRect\r\n};\r\n\r\nfunction getRestrictionRect(value, interaction, page) {\r\n  if (utils.is.function(value)) {\r\n    return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\r\n  } else {\r\n    return utils.resolveRectLike(value, interaction.target, interaction.element);\r\n  }\r\n}\r\n\r\nmodifiers.restrict = restrict;\r\nmodifiers.names.push('restrict');\r\n\r\ndefaultOptions.perAction.restrict = restrict.defaults;\r\n\r\nmodule.exports = restrict;\r\n\r\n},{\"../defaultOptions\":18,\"../utils\":44,\"./index\":24}],26:[function(require,module,exports){\r\n'use strict';\r\n\r\n// This module adds the options.resize.restrictEdges setting which sets min and\r\n// max for the top, left, bottom and right edges of the target being resized.\r\n//\r\n// interact(target).resize({\r\n//   edges: { top: true, left: true },\r\n//   restrictEdges: {\r\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\r\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\r\n//   },\r\n// });\r\n\r\nvar modifiers = require('./index');\r\nvar utils = require('../utils');\r\nvar rectUtils = require('../utils/rect');\r\nvar defaultOptions = require('../defaultOptions');\r\nvar resize = require('../actions/resize');\r\n\r\nvar _require = require('./restrict'),\r\n    getRestrictionRect = _require.getRestrictionRect;\r\n\r\nvar noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity };\r\nvar noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity };\r\n\r\nvar restrictEdges = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    min: null,\r\n    max: null,\r\n    offset: null\r\n  },\r\n\r\n  setOffset: function setOffset(_ref) {\r\n    var interaction = _ref.interaction,\r\n        startOffset = _ref.startOffset,\r\n        options = _ref.options;\r\n\r\n    if (!options) {\r\n      return utils.extend({}, startOffset);\r\n    }\r\n\r\n    var offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\r\n\r\n    if (offset) {\r\n      return {\r\n        top: startOffset.top + offset.y,\r\n        left: startOffset.left + offset.x,\r\n        bottom: startOffset.bottom + offset.y,\r\n        right: startOffset.right + offset.x\r\n      };\r\n    }\r\n\r\n    return startOffset;\r\n  },\r\n\r\n  set: function set(_ref2) {\r\n    var pageCoords = _ref2.pageCoords,\r\n        interaction = _ref2.interaction,\r\n        status = _ref2.status,\r\n        offset = _ref2.offset,\r\n        options = _ref2.options;\r\n\r\n    var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\r\n\r\n    if (!interaction.interacting() || !edges) {\r\n      return;\r\n    }\r\n\r\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\r\n    var inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\r\n    var outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\r\n\r\n    var modifiedX = page.x;\r\n    var modifiedY = page.y;\r\n\r\n    status.dx = 0;\r\n    status.dy = 0;\r\n    status.locked = false;\r\n\r\n    if (edges.top) {\r\n      modifiedY = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);\r\n    } else if (edges.bottom) {\r\n      modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\r\n    }\r\n    if (edges.left) {\r\n      modifiedX = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);\r\n    } else if (edges.right) {\r\n      modifiedX = Math.max(Math.min(outer.right - offset.right, page.x), inner.right - offset.right);\r\n    }\r\n\r\n    status.dx = modifiedX - page.x;\r\n    status.dy = modifiedY - page.y;\r\n\r\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\r\n    status.locked = !!(status.dx || status.dy);\r\n\r\n    status.modifiedX = modifiedX;\r\n    status.modifiedY = modifiedY;\r\n  },\r\n\r\n  modifyCoords: function modifyCoords(_ref3) {\r\n    var page = _ref3.page,\r\n        client = _ref3.client,\r\n        status = _ref3.status,\r\n        phase = _ref3.phase,\r\n        options = _ref3.options;\r\n\r\n    if (options && options.enabled && !(phase === 'start' && status.locked)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n\r\n        return {\r\n          dx: status.dx,\r\n          dy: status.dy\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  noInner: noInner,\r\n  noOuter: noOuter,\r\n  getRestrictionRect: getRestrictionRect\r\n};\r\n\r\nmodifiers.restrictEdges = restrictEdges;\r\nmodifiers.names.push('restrictEdges');\r\n\r\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\r\nresize.defaults.restrictEdges = restrictEdges.defaults;\r\n\r\nmodule.exports = restrictEdges;\r\n\r\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils\":44,\"../utils/rect\":51,\"./index\":24,\"./restrict\":25}],27:[function(require,module,exports){\r\n'use strict';\r\n\r\n// This module adds the options.resize.restrictSize setting which sets min and\r\n// max width and height for the target being resized.\r\n//\r\n// interact(target).resize({\r\n//   edges: { top: true, left: true },\r\n//   restrictSize: {\r\n//     min: { width: -600, height: -600 },\r\n//     max: { width:  600, height:  600 },\r\n//   },\r\n// });\r\n\r\nvar modifiers = require('./index');\r\nvar restrictEdges = require('./restrictEdges');\r\nvar utils = require('../utils');\r\nvar rectUtils = require('../utils/rect');\r\nvar defaultOptions = require('../defaultOptions');\r\nvar resize = require('../actions/resize');\r\n\r\nvar noMin = { width: -Infinity, height: -Infinity };\r\nvar noMax = { width: +Infinity, height: +Infinity };\r\n\r\nvar restrictSize = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    min: null,\r\n    max: null\r\n  },\r\n\r\n  setOffset: function setOffset(_ref) {\r\n    var interaction = _ref.interaction;\r\n\r\n    return interaction.startOffset;\r\n  },\r\n\r\n  set: function set(arg) {\r\n    var interaction = arg.interaction,\r\n        options = arg.options;\r\n\r\n    var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\r\n\r\n    if (!interaction.interacting() || !edges) {\r\n      return;\r\n    }\r\n\r\n    var rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\r\n\r\n    var minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\r\n    var maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\r\n\r\n    arg.options = {\r\n      enabled: options.enabled,\r\n      endOnly: options.endOnly,\r\n      inner: utils.extend({}, restrictEdges.noInner),\r\n      outer: utils.extend({}, restrictEdges.noOuter)\r\n    };\r\n\r\n    if (edges.top) {\r\n      arg.options.inner.top = rect.bottom - minSize.height;\r\n      arg.options.outer.top = rect.bottom - maxSize.height;\r\n    } else if (edges.bottom) {\r\n      arg.options.inner.bottom = rect.top + minSize.height;\r\n      arg.options.outer.bottom = rect.top + maxSize.height;\r\n    }\r\n    if (edges.left) {\r\n      arg.options.inner.left = rect.right - minSize.width;\r\n      arg.options.outer.left = rect.right - maxSize.width;\r\n    } else if (edges.right) {\r\n      arg.options.inner.right = rect.left + minSize.width;\r\n      arg.options.outer.right = rect.left + maxSize.width;\r\n    }\r\n\r\n    restrictEdges.set(arg);\r\n  },\r\n\r\n  modifyCoords: restrictEdges.modifyCoords\r\n};\r\n\r\nmodifiers.restrictSize = restrictSize;\r\nmodifiers.names.push('restrictSize');\r\n\r\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\r\nresize.defaults.restrictSize = restrictSize.defaults;\r\n\r\nmodule.exports = restrictSize;\r\n\r\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils\":44,\"../utils/rect\":51,\"./index\":24,\"./restrictEdges\":26}],28:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar modifiers = require('./index');\r\nvar interact = require('../interact');\r\nvar utils = require('../utils');\r\nvar defaultOptions = require('../defaultOptions');\r\n\r\nvar snap = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    range: Infinity,\r\n    targets: null,\r\n    offsets: null,\r\n\r\n    relativePoints: null\r\n  },\r\n\r\n  setOffset: function setOffset(_ref) {\r\n    var interaction = _ref.interaction,\r\n        interactable = _ref.interactable,\r\n        element = _ref.element,\r\n        rect = _ref.rect,\r\n        startOffset = _ref.startOffset,\r\n        options = _ref.options;\r\n\r\n    var offsets = [];\r\n    var optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\r\n    var origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\r\n    options = options || interactable.options[interaction.prepared.name].snap || {};\r\n\r\n    var snapOffset = void 0;\r\n\r\n    if (options.offset === 'startCoords') {\r\n      snapOffset = {\r\n        x: interaction.startCoords.page.x - origin.x,\r\n        y: interaction.startCoords.page.y - origin.y\r\n      };\r\n    } else {\r\n      var offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\r\n\r\n      snapOffset = utils.rectToXY(offsetRect) || { x: 0, y: 0 };\r\n    }\r\n\r\n    if (rect && options.relativePoints && options.relativePoints.length) {\r\n      for (var _iterator = options.relativePoints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n        var _ref2;\r\n\r\n        if (_isArray) {\r\n          if (_i >= _iterator.length) break;\r\n          _ref2 = _iterator[_i++];\r\n        } else {\r\n          _i = _iterator.next();\r\n          if (_i.done) break;\r\n          _ref2 = _i.value;\r\n        }\r\n\r\n        var _ref3 = _ref2,\r\n            relativeX = _ref3.x,\r\n            relativeY = _ref3.y;\r\n\r\n        offsets.push({\r\n          x: startOffset.left - rect.width * relativeX + snapOffset.x,\r\n          y: startOffset.top - rect.height * relativeY + snapOffset.y\r\n        });\r\n      }\r\n    } else {\r\n      offsets.push(snapOffset);\r\n    }\r\n\r\n    return offsets;\r\n  },\r\n\r\n  set: function set(_ref4) {\r\n    var interaction = _ref4.interaction,\r\n        pageCoords = _ref4.pageCoords,\r\n        status = _ref4.status,\r\n        options = _ref4.options,\r\n        offsets = _ref4.offset;\r\n\r\n    var targets = [];\r\n    var target = void 0;\r\n    var page = void 0;\r\n    var i = void 0;\r\n\r\n    if (status.useStatusXY) {\r\n      page = { x: status.x, y: status.y };\r\n    } else {\r\n      var origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\r\n\r\n      page = utils.extend({}, pageCoords);\r\n\r\n      page.x -= origin.x;\r\n      page.y -= origin.y;\r\n    }\r\n\r\n    status.realX = page.x;\r\n    status.realY = page.y;\r\n\r\n    var len = options.targets ? options.targets.length : 0;\r\n\r\n    for (var _iterator2 = offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n      var _ref5;\r\n\r\n      if (_isArray2) {\r\n        if (_i2 >= _iterator2.length) break;\r\n        _ref5 = _iterator2[_i2++];\r\n      } else {\r\n        _i2 = _iterator2.next();\r\n        if (_i2.done) break;\r\n        _ref5 = _i2.value;\r\n      }\r\n\r\n      var _ref6 = _ref5,\r\n          offsetX = _ref6.x,\r\n          offsetY = _ref6.y;\r\n\r\n      var relativeX = page.x - offsetX;\r\n      var relativeY = page.y - offsetY;\r\n\r\n      for (var _iterator3 = options.targets, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\r\n        var _ref7;\r\n\r\n        if (_isArray3) {\r\n          if (_i3 >= _iterator3.length) break;\r\n          _ref7 = _iterator3[_i3++];\r\n        } else {\r\n          _i3 = _iterator3.next();\r\n          if (_i3.done) break;\r\n          _ref7 = _i3.value;\r\n        }\r\n\r\n        var snapTarget = _ref7;\r\n\r\n        if (utils.is.function(snapTarget)) {\r\n          target = snapTarget(relativeX, relativeY, interaction);\r\n        } else {\r\n          target = snapTarget;\r\n        }\r\n\r\n        if (!target) {\r\n          continue;\r\n        }\r\n\r\n        targets.push({\r\n          x: utils.is.number(target.x) ? target.x + offsetX : relativeX,\r\n          y: utils.is.number(target.y) ? target.y + offsetY : relativeY,\r\n\r\n          range: utils.is.number(target.range) ? target.range : options.range\r\n        });\r\n      }\r\n    }\r\n\r\n    var closest = {\r\n      target: null,\r\n      inRange: false,\r\n      distance: 0,\r\n      range: 0,\r\n      dx: 0,\r\n      dy: 0\r\n    };\r\n\r\n    for (i = 0, len = targets.length; i < len; i++) {\r\n      target = targets[i];\r\n\r\n      var range = target.range;\r\n      var dx = target.x - page.x;\r\n      var dy = target.y - page.y;\r\n      var distance = utils.hypot(dx, dy);\r\n      var inRange = distance <= range;\r\n\r\n      // Infinite targets count as being out of range\r\n      // compared to non infinite ones that are in range\r\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\r\n        inRange = false;\r\n      }\r\n\r\n      if (!closest.target || (inRange\r\n      // is the closest target in range?\r\n      ? closest.inRange && range !== Infinity\r\n      // the pointer is relatively deeper in this target\r\n      ? distance / range < closest.distance / closest.range\r\n      // this target has Infinite range and the closest doesn't\r\n      : range === Infinity && closest.range !== Infinity ||\r\n      // OR this target is closer that the previous closest\r\n      distance < closest.distance :\r\n      // The other is not in range and the pointer is closer to this target\r\n      !closest.inRange && distance < closest.distance)) {\r\n\r\n        closest.target = target;\r\n        closest.distance = distance;\r\n        closest.range = range;\r\n        closest.inRange = inRange;\r\n        closest.dx = dx;\r\n        closest.dy = dy;\r\n\r\n        status.range = range;\r\n      }\r\n    }\r\n\r\n    var snapChanged = void 0;\r\n\r\n    if (closest.target) {\r\n      snapChanged = status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y;\r\n\r\n      status.modifiedX = closest.target.x;\r\n      status.modifiedY = closest.target.y;\r\n    } else {\r\n      snapChanged = true;\r\n\r\n      status.modifiedX = NaN;\r\n      status.modifiedY = NaN;\r\n    }\r\n\r\n    status.dx = closest.dx;\r\n    status.dy = closest.dy;\r\n\r\n    status.changed = snapChanged || closest.inRange && !status.locked;\r\n    status.locked = closest.inRange;\r\n  },\r\n\r\n  modifyCoords: function modifyCoords(_ref8) {\r\n    var page = _ref8.page,\r\n        client = _ref8.client,\r\n        status = _ref8.status,\r\n        phase = _ref8.phase,\r\n        options = _ref8.options;\r\n\r\n    var relativePoints = options && options.relativePoints;\r\n\r\n    if (options && options.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n      }\r\n\r\n      return {\r\n        range: status.range,\r\n        locked: status.locked,\r\n        x: status.modifiedX,\r\n        y: status.modifiedY,\r\n        realX: status.realX,\r\n        realY: status.realY,\r\n        dx: status.dx,\r\n        dy: status.dy\r\n      };\r\n    }\r\n  }\r\n};\r\n\r\ninteract.createSnapGrid = function (grid) {\r\n  return function (x, y) {\r\n    var limits = grid.limits || {\r\n      left: -Infinity,\r\n      right: Infinity,\r\n      top: -Infinity,\r\n      bottom: Infinity\r\n    };\r\n    var offsetX = 0;\r\n    var offsetY = 0;\r\n\r\n    if (utils.is.object(grid.offset)) {\r\n      offsetX = grid.offset.x;\r\n      offsetY = grid.offset.y;\r\n    }\r\n\r\n    var gridx = Math.round((x - offsetX) / grid.x);\r\n    var gridy = Math.round((y - offsetY) / grid.y);\r\n\r\n    var newX = Math.max(limits.left, Math.min(limits.right, gridx * grid.x + offsetX));\r\n    var newY = Math.max(limits.top, Math.min(limits.bottom, gridy * grid.y + offsetY));\r\n\r\n    return {\r\n      x: newX,\r\n      y: newY,\r\n      range: grid.range\r\n    };\r\n  };\r\n};\r\n\r\nmodifiers.snap = snap;\r\nmodifiers.names.push('snap');\r\n\r\ndefaultOptions.perAction.snap = snap.defaults;\r\n\r\nmodule.exports = snap;\r\n\r\n},{\"../defaultOptions\":18,\"../interact\":21,\"../utils\":44,\"./index\":24}],29:[function(require,module,exports){\r\n'use strict';\r\n\r\n// This module allows snapping of the size of targets during resize\r\n// interactions.\r\n\r\nvar modifiers = require('./index');\r\nvar snap = require('./snap');\r\nvar defaultOptions = require('../defaultOptions');\r\nvar resize = require('../actions/resize');\r\nvar utils = require('../utils/');\r\n\r\nvar snapSize = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    range: Infinity,\r\n    targets: null,\r\n    offsets: null\r\n  },\r\n\r\n  setOffset: function setOffset(arg) {\r\n    var interaction = arg.interaction,\r\n        options = arg.options;\r\n\r\n    var edges = interaction.prepared.edges;\r\n\r\n    if (!edges) {\r\n      return;\r\n    }\r\n\r\n    arg.options = {\r\n      relativePoints: [{\r\n        x: edges.left ? 0 : 1,\r\n        y: edges.top ? 0 : 1\r\n      }],\r\n      origin: { x: 0, y: 0 },\r\n      offset: 'self',\r\n      range: options.range\r\n    };\r\n\r\n    var offsets = snap.setOffset(arg);\r\n    arg.options = options;\r\n\r\n    return offsets;\r\n  },\r\n\r\n  set: function set(arg) {\r\n    var interaction = arg.interaction,\r\n        options = arg.options,\r\n        offset = arg.offset,\r\n        pageCoords = arg.pageCoords;\r\n\r\n    var page = utils.extend({}, pageCoords);\r\n    var relativeX = page.x - offset[0].x;\r\n    var relativeY = page.y - offset[0].y;\r\n\r\n    arg.options = utils.extend({}, options);\r\n    arg.options.targets = [];\r\n\r\n    for (var _iterator = options.targets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var snapTarget = _ref;\r\n\r\n      var target = void 0;\r\n\r\n      if (utils.is.function(snapTarget)) {\r\n        target = snapTarget(relativeX, relativeY, interaction);\r\n      } else {\r\n        target = snapTarget;\r\n      }\r\n\r\n      if (!target) {\r\n        continue;\r\n      }\r\n\r\n      if ('width' in target && 'height' in target) {\r\n        target.x = target.width;\r\n        target.y = target.height;\r\n      }\r\n\r\n      arg.options.targets.push(target);\r\n    }\r\n\r\n    snap.set(arg);\r\n  },\r\n\r\n  modifyCoords: function modifyCoords(arg) {\r\n    var options = arg.options;\r\n\r\n\r\n    arg.options = utils.extend({}, options);\r\n    arg.options.enabled = options.enabled;\r\n    arg.options.relativePoints = [null];\r\n\r\n    snap.modifyCoords(arg);\r\n  }\r\n};\r\n\r\nmodifiers.snapSize = snapSize;\r\nmodifiers.names.push('snapSize');\r\n\r\ndefaultOptions.perAction.snapSize = snapSize.defaults;\r\nresize.defaults.snapSize = snapSize.defaults;\r\n\r\nmodule.exports = snapSize;\r\n\r\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils/\":44,\"./index\":24,\"./snap\":28}],30:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar pointerUtils = require('../utils/pointerUtils');\r\n\r\nmodule.exports = function () {\r\n  function PointerEvent(type, pointer, event, eventTarget, interaction) {\r\n    _classCallCheck(this, PointerEvent);\r\n\r\n    pointerUtils.pointerExtend(this, event);\r\n\r\n    if (event !== pointer) {\r\n      pointerUtils.pointerExtend(this, pointer);\r\n    }\r\n\r\n    this.interaction = interaction;\r\n\r\n    this.timeStamp = new Date().getTime();\r\n    this.originalEvent = event;\r\n    this.type = type;\r\n    this.pointerId = pointerUtils.getPointerId(pointer);\r\n    this.pointerType = pointerUtils.getPointerType(pointer);\r\n    this.target = eventTarget;\r\n    this.currentTarget = null;\r\n\r\n    if (type === 'tap') {\r\n      var pointerIndex = interaction.getPointerIndex(pointer);\r\n      this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\r\n\r\n      var interval = this.timeStamp - interaction.tapTime;\r\n\r\n      this.double = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === this.target && interval < 500);\r\n    } else if (type === 'doubletap') {\r\n      this.dt = pointer.timeStamp - interaction.tapTime;\r\n    }\r\n  }\r\n\r\n  PointerEvent.prototype.subtractOrigin = function subtractOrigin(_ref) {\r\n    var originX = _ref.x,\r\n        originY = _ref.y;\r\n\r\n    this.pageX -= originX;\r\n    this.pageY -= originY;\r\n    this.clientX -= originX;\r\n    this.clientY -= originY;\r\n\r\n    return this;\r\n  };\r\n\r\n  PointerEvent.prototype.addOrigin = function addOrigin(_ref2) {\r\n    var originX = _ref2.x,\r\n        originY = _ref2.y;\r\n\r\n    this.pageX += originX;\r\n    this.pageY += originY;\r\n    this.clientX += originX;\r\n    this.clientY += originY;\r\n\r\n    return this;\r\n  };\r\n\r\n  PointerEvent.prototype.preventDefault = function preventDefault() {\r\n    this.originalEvent.preventDefault();\r\n  };\r\n\r\n  PointerEvent.prototype.stopPropagation = function stopPropagation() {\r\n    this.propagationStopped = true;\r\n  };\r\n\r\n  PointerEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\r\n    this.immediatePropagationStopped = this.propagationStopped = true;\r\n  };\r\n\r\n  return PointerEvent;\r\n}();\r\n\r\n},{\"../utils/pointerUtils\":49}],31:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar PointerEvent = require('./PointerEvent');\r\nvar Interaction = require('../Interaction');\r\nvar utils = require('../utils');\r\nvar browser = require('../utils/browser');\r\nvar defaults = require('../defaultOptions');\r\nvar signals = require('../utils/Signals').new();\r\n\r\nvar _require = require('../utils/arr'),\r\n    filter = _require.filter;\r\n\r\nvar simpleSignals = ['down', 'up', 'cancel'];\r\nvar simpleEvents = ['down', 'up', 'cancel'];\r\n\r\nvar pointerEvents = {\r\n  PointerEvent: PointerEvent,\r\n  fire: fire,\r\n  collectEventTargets: collectEventTargets,\r\n  signals: signals,\r\n  defaults: {\r\n    holdDuration: 600,\r\n    ignoreFrom: null,\r\n    allowFrom: null,\r\n    origin: { x: 0, y: 0 }\r\n  },\r\n  types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']\r\n};\r\n\r\nfunction fire(arg) {\r\n  var interaction = arg.interaction,\r\n      pointer = arg.pointer,\r\n      event = arg.event,\r\n      eventTarget = arg.eventTarget,\r\n      _arg$type = arg.type,\r\n      type = _arg$type === undefined ? arg.pointerEvent.type : _arg$type,\r\n      _arg$targets = arg.targets,\r\n      targets = _arg$targets === undefined ? collectEventTargets(arg) : _arg$targets,\r\n      _arg$pointerEvent = arg.pointerEvent,\r\n      pointerEvent = _arg$pointerEvent === undefined ? new PointerEvent(type, pointer, event, eventTarget, interaction) : _arg$pointerEvent;\r\n\r\n\r\n  var signalArg = {\r\n    interaction: interaction,\r\n    pointer: pointer,\r\n    event: event,\r\n    eventTarget: eventTarget,\r\n    targets: targets,\r\n    type: type,\r\n    pointerEvent: pointerEvent\r\n  };\r\n\r\n  for (var i = 0; i < targets.length; i++) {\r\n    var target = targets[i];\r\n\r\n    for (var prop in target.props || {}) {\r\n      pointerEvent[prop] = target.props[prop];\r\n    }\r\n\r\n    var origin = utils.getOriginXY(target.eventable, target.element);\r\n\r\n    pointerEvent.subtractOrigin(origin);\r\n    pointerEvent.eventable = target.eventable;\r\n    pointerEvent.currentTarget = target.element;\r\n\r\n    target.eventable.fire(pointerEvent);\r\n\r\n    pointerEvent.addOrigin(origin);\r\n\r\n    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].element !== pointerEvent.currentTarget) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  signals.fire('fired', signalArg);\r\n\r\n  if (type === 'tap') {\r\n    // if pointerEvent should make a double tap, create and fire a doubletap\r\n    // PointerEvent and use that as the prevTap\r\n    var prevTap = pointerEvent.double ? fire({\r\n      interaction: interaction, pointer: pointer, event: event, eventTarget: eventTarget,\r\n      type: 'doubletap'\r\n    }) : pointerEvent;\r\n\r\n    interaction.prevTap = prevTap;\r\n    interaction.tapTime = prevTap.timeStamp;\r\n  }\r\n\r\n  return pointerEvent;\r\n}\r\n\r\nfunction collectEventTargets(_ref) {\r\n  var interaction = _ref.interaction,\r\n      pointer = _ref.pointer,\r\n      event = _ref.event,\r\n      eventTarget = _ref.eventTarget,\r\n      type = _ref.type;\r\n\r\n  var pointerIndex = interaction.getPointerIndex(pointer);\r\n\r\n  // do not fire a tap event if the pointer was moved before being lifted\r\n  if (type === 'tap' && (interaction.pointerWasMoved\r\n  // or if the pointerup target is different to the pointerdown target\r\n  || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\r\n    return [];\r\n  }\r\n\r\n  var path = utils.getPath(eventTarget);\r\n  var signalArg = {\r\n    interaction: interaction,\r\n    pointer: pointer,\r\n    event: event,\r\n    eventTarget: eventTarget,\r\n    type: type,\r\n    path: path,\r\n    targets: [],\r\n    element: null\r\n  };\r\n\r\n  for (var _iterator = path, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n    var _ref2;\r\n\r\n    if (_isArray) {\r\n      if (_i >= _iterator.length) break;\r\n      _ref2 = _iterator[_i++];\r\n    } else {\r\n      _i = _iterator.next();\r\n      if (_i.done) break;\r\n      _ref2 = _i.value;\r\n    }\r\n\r\n    var element = _ref2;\r\n\r\n    signalArg.element = element;\r\n\r\n    signals.fire('collect-targets', signalArg);\r\n  }\r\n\r\n  if (type === 'hold') {\r\n    signalArg.targets = filter(signalArg.targets, function (target) {\r\n      return target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration;\r\n    });\r\n  }\r\n\r\n  return signalArg.targets;\r\n}\r\n\r\nInteraction.signals.on('update-pointer-down', function (_ref3) {\r\n  var interaction = _ref3.interaction,\r\n      pointerIndex = _ref3.pointerIndex;\r\n\r\n  interaction.holdTimers[pointerIndex] = { duration: Infinity, timeout: null };\r\n});\r\n\r\nInteraction.signals.on('remove-pointer', function (_ref4) {\r\n  var interaction = _ref4.interaction,\r\n      pointerIndex = _ref4.pointerIndex;\r\n\r\n  interaction.holdTimers.splice(pointerIndex, 1);\r\n});\r\n\r\nInteraction.signals.on('move', function (_ref5) {\r\n  var interaction = _ref5.interaction,\r\n      pointer = _ref5.pointer,\r\n      event = _ref5.event,\r\n      eventTarget = _ref5.eventTarget,\r\n      duplicateMove = _ref5.duplicateMove;\r\n\r\n  var pointerIndex = interaction.getPointerIndex(pointer);\r\n\r\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\r\n    if (interaction.pointerIsDown) {\r\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\r\n    }\r\n\r\n    fire({\r\n      interaction: interaction, pointer: pointer, event: event, eventTarget: eventTarget,\r\n      type: 'move'\r\n    });\r\n  }\r\n});\r\n\r\nInteraction.signals.on('down', function (_ref6) {\r\n  var interaction = _ref6.interaction,\r\n      pointer = _ref6.pointer,\r\n      event = _ref6.event,\r\n      eventTarget = _ref6.eventTarget,\r\n      pointerIndex = _ref6.pointerIndex;\r\n\r\n  // copy event to be used in timeout for IE8\r\n  var eventCopy = browser.isIE8 ? utils.extend({}, event) : event;\r\n\r\n  var timer = interaction.holdTimers[pointerIndex];\r\n  var path = utils.getPath(eventTarget);\r\n  var signalArg = {\r\n    interaction: interaction,\r\n    pointer: pointer,\r\n    event: event,\r\n    eventTarget: eventTarget,\r\n    type: 'hold',\r\n    targets: [],\r\n    path: path,\r\n    element: null\r\n  };\r\n\r\n  for (var _iterator2 = path, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n    var _ref7;\r\n\r\n    if (_isArray2) {\r\n      if (_i2 >= _iterator2.length) break;\r\n      _ref7 = _iterator2[_i2++];\r\n    } else {\r\n      _i2 = _iterator2.next();\r\n      if (_i2.done) break;\r\n      _ref7 = _i2.value;\r\n    }\r\n\r\n    var element = _ref7;\r\n\r\n    signalArg.element = element;\r\n\r\n    signals.fire('collect-targets', signalArg);\r\n  }\r\n\r\n  if (!signalArg.targets.length) {\r\n    return;\r\n  }\r\n\r\n  var minDuration = Infinity;\r\n\r\n  for (var i = 0; i < signalArg.targets.length; i++) {\r\n    var target = signalArg.targets[i];\r\n    var holdDuration = target.eventable.options.holdDuration;\r\n\r\n    if (holdDuration < minDuration) {\r\n      minDuration = holdDuration;\r\n    }\r\n  }\r\n\r\n  timer.duration = minDuration;\r\n  timer.timeout = setTimeout(function () {\r\n    fire({\r\n      interaction: interaction,\r\n      eventTarget: eventTarget,\r\n      pointer: browser.isIE8 ? eventCopy : pointer,\r\n      event: eventCopy,\r\n      type: 'hold'\r\n    });\r\n  }, minDuration);\r\n});\r\n\r\nInteraction.signals.on('up', function (_ref8) {\r\n  var interaction = _ref8.interaction,\r\n      pointer = _ref8.pointer,\r\n      event = _ref8.event,\r\n      eventTarget = _ref8.eventTarget;\r\n\r\n  if (!interaction.pointerWasMoved) {\r\n    fire({ interaction: interaction, eventTarget: eventTarget, pointer: pointer, event: event, type: 'tap' });\r\n  }\r\n});\r\n\r\n['up', 'cancel'].forEach(function (signalName) {\r\n  Interaction.signals.on(signalName, function (_ref9) {\r\n    var interaction = _ref9.interaction,\r\n        pointerIndex = _ref9.pointerIndex;\r\n\r\n    if (interaction.holdTimers[pointerIndex]) {\r\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\r\n    }\r\n  });\r\n});\r\n\r\nfunction createSignalListener(type) {\r\n  return function (_ref10) {\r\n    var interaction = _ref10.interaction,\r\n        pointer = _ref10.pointer,\r\n        event = _ref10.event,\r\n        eventTarget = _ref10.eventTarget;\r\n\r\n    fire({ interaction: interaction, eventTarget: eventTarget, pointer: pointer, event: event, type: type });\r\n  };\r\n}\r\n\r\nfor (var i = 0; i < simpleSignals.length; i++) {\r\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.prevTap = null; // the most recent tap event on this interaction\r\n  interaction.tapTime = 0; // time of the most recent tap event\r\n  interaction.holdTimers = []; // [{ duration, timeout }]\r\n});\r\n\r\ndefaults.pointerEvents = pointerEvents.defaults;\r\nmodule.exports = pointerEvents;\r\n\r\n},{\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":44,\"../utils/Signals\":35,\"../utils/arr\":36,\"../utils/browser\":37,\"./PointerEvent\":30}],32:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar pointerEvents = require('./base');\r\nvar Interaction = require('../Interaction');\r\n\r\npointerEvents.signals.on('new', onNew);\r\npointerEvents.signals.on('fired', onFired);\r\n\r\nvar _arr = ['move', 'up', 'cancel', 'endall'];\r\nfor (var _i = 0; _i < _arr.length; _i++) {\r\n  var signal = _arr[_i];\r\n  Interaction.signals.on(signal, endHoldRepeat);\r\n}\r\n\r\nfunction onNew(_ref) {\r\n  var pointerEvent = _ref.pointerEvent;\r\n\r\n  if (pointerEvent.type !== 'hold') {\r\n    return;\r\n  }\r\n\r\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\r\n}\r\n\r\nfunction onFired(_ref2) {\r\n  var interaction = _ref2.interaction,\r\n      pointerEvent = _ref2.pointerEvent,\r\n      eventTarget = _ref2.eventTarget,\r\n      targets = _ref2.targets;\r\n\r\n  if (pointerEvent.type !== 'hold' || !targets.length) {\r\n    return;\r\n  }\r\n\r\n  // get the repeat interval from the first eventable\r\n  var interval = targets[0].eventable.options.holdRepeatInterval;\r\n\r\n  // don't repeat if the interval is 0 or less\r\n  if (interval <= 0) {\r\n    return;\r\n  }\r\n\r\n  // set a timeout to fire the holdrepeat event\r\n  interaction.holdIntervalHandle = setTimeout(function () {\r\n    pointerEvents.fire({\r\n      interaction: interaction,\r\n      eventTarget: eventTarget,\r\n      type: 'hold',\r\n      pointer: pointerEvent,\r\n      event: pointerEvent\r\n    });\r\n  }, interval);\r\n}\r\n\r\nfunction endHoldRepeat(_ref3) {\r\n  var interaction = _ref3.interaction;\r\n\r\n  // set the interaction's holdStopTime property\r\n  // to stop further holdRepeat events\r\n  if (interaction.holdIntervalHandle) {\r\n    clearInterval(interaction.holdIntervalHandle);\r\n    interaction.holdIntervalHandle = null;\r\n  }\r\n}\r\n\r\n// don't repeat by default\r\npointerEvents.defaults.holdRepeatInterval = 0;\r\npointerEvents.types.push('holdrepeat');\r\n\r\nmodule.exports = {\r\n  onNew: onNew,\r\n  onFired: onFired,\r\n  endHoldRepeat: endHoldRepeat\r\n};\r\n\r\n},{\"../Interaction\":5,\"./base\":31}],33:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar pointerEvents = require('./base');\r\nvar Interactable = require('../Interactable');\r\nvar browser = require('../utils/browser');\r\nvar is = require('../utils/is');\r\nvar domUtils = require('../utils/domUtils');\r\nvar scope = require('../scope');\r\nvar extend = require('../utils/extend');\r\n\r\nvar _require = require('../utils/arr'),\r\n    merge = _require.merge;\r\n\r\npointerEvents.signals.on('collect-targets', function (_ref) {\r\n  var targets = _ref.targets,\r\n      element = _ref.element,\r\n      type = _ref.type,\r\n      eventTarget = _ref.eventTarget;\r\n\r\n  function collectSelectors(interactable, selector, context) {\r\n    var els = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\r\n\r\n    var eventable = interactable.events;\r\n    var options = eventable.options;\r\n\r\n    if (eventable[type] && is.element(element) && domUtils.matchesSelector(element, selector, els) && interactable.testIgnoreAllow(options, element, eventTarget)) {\r\n\r\n      targets.push({\r\n        element: element,\r\n        eventable: eventable,\r\n        props: { interactable: interactable }\r\n      });\r\n    }\r\n  }\r\n\r\n  var interactable = scope.interactables.get(element);\r\n\r\n  if (interactable) {\r\n    var eventable = interactable.events;\r\n    var options = eventable.options;\r\n\r\n    if (eventable[type] && interactable.testIgnoreAllow(options, element, eventTarget)) {\r\n      targets.push({\r\n        element: element,\r\n        eventable: eventable,\r\n        props: { interactable: interactable }\r\n      });\r\n    }\r\n  }\r\n\r\n  scope.interactables.forEachSelector(collectSelectors, element);\r\n});\r\n\r\nInteractable.signals.on('new', function (_ref2) {\r\n  var interactable = _ref2.interactable;\r\n\r\n  interactable.events.getRect = function (element) {\r\n    return interactable.getRect(element);\r\n  };\r\n});\r\n\r\nInteractable.signals.on('set', function (_ref3) {\r\n  var interactable = _ref3.interactable,\r\n      options = _ref3.options;\r\n\r\n  extend(interactable.events.options, pointerEvents.defaults);\r\n  extend(interactable.events.options, options);\r\n});\r\n\r\nmerge(Interactable.eventTypes, pointerEvents.types);\r\n\r\nInteractable.prototype.pointerEvents = function (options) {\r\n  extend(this.events.options, options);\r\n\r\n  return this;\r\n};\r\n\r\nvar __backCompatOption = Interactable.prototype._backCompatOption;\r\n\r\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\r\n  var ret = __backCompatOption.call(this, optionName, newValue);\r\n\r\n  if (ret === this) {\r\n    this.events.options[optionName] = newValue;\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nInteractable.settingsMethods.push('pointerEvents');\r\n\r\n},{\"../Interactable\":4,\"../scope\":34,\"../utils/arr\":36,\"../utils/browser\":37,\"../utils/domUtils\":39,\"../utils/extend\":41,\"../utils/is\":46,\"./base\":31}],34:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar utils = require('./utils');\r\nvar events = require('./utils/events');\r\nvar signals = require('./utils/Signals').new();\r\n\r\nvar scope = {\r\n  signals: signals,\r\n  events: events,\r\n  utils: utils,\r\n\r\n  // main document\r\n  document: require('./utils/domObjects').document,\r\n  // all documents being listened to\r\n  documents: [],\r\n\r\n  addDocument: function addDocument(doc, win) {\r\n    // do nothing if document is already known\r\n    if (utils.contains(scope.documents, doc)) {\r\n      return false;\r\n    }\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    scope.documents.push(doc);\r\n    events.documents.push(doc);\r\n\r\n    // don't add an unload event for the main document\r\n    // so that the page may be cached in browser history\r\n    if (doc !== scope.document) {\r\n      events.add(win, 'unload', scope.onWindowUnload);\r\n    }\r\n\r\n    signals.fire('add-document', { doc: doc, win: win });\r\n  },\r\n\r\n  removeDocument: function removeDocument(doc, win) {\r\n    var index = utils.indexOf(scope.documents, doc);\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    events.remove(win, 'unload', scope.onWindowUnload);\r\n\r\n    scope.documents.splice(index, 1);\r\n    events.documents.splice(index, 1);\r\n\r\n    signals.fire('remove-document', { win: win, doc: doc });\r\n  },\r\n\r\n  onWindowUnload: function onWindowUnload() {\r\n    scope.removeDocument(this.document, this);\r\n  }\r\n};\r\n\r\nmodule.exports = scope;\r\n\r\n},{\"./utils\":44,\"./utils/Signals\":35,\"./utils/domObjects\":38,\"./utils/events\":40}],35:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar _require = require('./arr'),\r\n    indexOf = _require.indexOf;\r\n\r\nvar Signals = function () {\r\n  function Signals() {\r\n    _classCallCheck(this, Signals);\r\n\r\n    this.listeners = {\r\n      // signalName: [listeners],\r\n    };\r\n  }\r\n\r\n  Signals.prototype.on = function on(name, listener) {\r\n    if (!this.listeners[name]) {\r\n      this.listeners[name] = [listener];\r\n      return;\r\n    }\r\n\r\n    this.listeners[name].push(listener);\r\n  };\r\n\r\n  Signals.prototype.off = function off(name, listener) {\r\n    if (!this.listeners[name]) {\r\n      return;\r\n    }\r\n\r\n    var index = indexOf(this.listeners[name], listener);\r\n\r\n    if (index !== -1) {\r\n      this.listeners[name].splice(index, 1);\r\n    }\r\n  };\r\n\r\n  Signals.prototype.fire = function fire(name, arg) {\r\n    var targetListeners = this.listeners[name];\r\n\r\n    if (!targetListeners) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < targetListeners.length; i++) {\r\n      if (targetListeners[i](arg, name) === false) {\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  return Signals;\r\n}();\r\n\r\nSignals.new = function () {\r\n  return new Signals();\r\n};\r\n\r\nmodule.exports = Signals;\r\n\r\n},{\"./arr\":36}],36:[function(require,module,exports){\r\n\"use strict\";\r\n\r\nfunction indexOf(array, target) {\r\n  for (var i = 0, len = array.length; i < len; i++) {\r\n    if (array[i] === target) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction contains(array, target) {\r\n  return indexOf(array, target) !== -1;\r\n}\r\n\r\nfunction merge(target, source) {\r\n  for (var i = 0; i < source.length; i++) {\r\n    target.push(source[i]);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction filter(array, test) {\r\n  var result = [];\r\n\r\n  for (var i = 0; i < array.length; i++) {\r\n    if (test(array[i])) {\r\n      result.push(array[i]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = {\r\n  indexOf: indexOf,\r\n  contains: contains,\r\n  merge: merge,\r\n  filter: filter\r\n};\r\n\r\n},{}],37:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar _require = require('./window'),\r\n    window = _require.window;\r\n\r\nvar is = require('./is');\r\nvar domObjects = require('./domObjects');\r\n\r\nvar Element = domObjects.Element;\r\nvar navigator = window.navigator;\r\n\r\nvar browser = {\r\n  // Does the browser support touch input?\r\n  supportsTouch: !!('ontouchstart' in window || is.function(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch),\r\n\r\n  // Does the browser support PointerEvents\r\n  supportsPointerEvent: !!domObjects.PointerEvent,\r\n\r\n  isIE8: 'attachEvent' in window && !('addEventListener' in window),\r\n\r\n  // Opera Mobile must be handled differently\r\n  isOperaMobile: navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto'),\r\n\r\n  // scrolling doesn't change the result of getClientRects on iOS 7\r\n  isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\r\n\r\n  isIe9OrOlder: /MSIE (8|9)/.test(navigator.userAgent),\r\n\r\n  // prefix matchesSelector\r\n  prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\r\n\r\n  useMatchesSelectorPolyfill: false,\r\n\r\n  pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === window.MSPointerEvent ? {\r\n    up: 'MSPointerUp',\r\n    down: 'MSPointerDown',\r\n    over: 'mouseover',\r\n    out: 'mouseout',\r\n    move: 'MSPointerMove',\r\n    cancel: 'MSPointerCancel'\r\n  } : {\r\n    up: 'pointerup',\r\n    down: 'pointerdown',\r\n    over: 'pointerover',\r\n    out: 'pointerout',\r\n    move: 'pointermove',\r\n    cancel: 'pointercancel'\r\n  } : null,\r\n\r\n  // because Webkit and Opera still use 'mousewheel' event type\r\n  wheelEvent: 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\r\n\r\n};\r\n\r\nbrowser.useMatchesSelectorPolyfill = !is.function(Element.prototype[browser.prefixedMatchesSelector]);\r\n\r\nmodule.exports = browser;\r\n\r\n},{\"./domObjects\":38,\"./is\":46,\"./window\":52}],38:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar domObjects = {};\r\nvar win = require('./window').window;\r\n\r\nfunction blank() {}\r\n\r\ndomObjects.document = win.document;\r\ndomObjects.DocumentFragment = win.DocumentFragment || blank;\r\ndomObjects.SVGElement = win.SVGElement || blank;\r\ndomObjects.SVGSVGElement = win.SVGSVGElement || blank;\r\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\r\ndomObjects.Element = win.Element || blank;\r\ndomObjects.HTMLElement = win.HTMLElement || domObjects.Element;\r\n\r\ndomObjects.Event = win.Event;\r\ndomObjects.Touch = win.Touch || blank;\r\ndomObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\r\n\r\nmodule.exports = domObjects;\r\n\r\n},{\"./window\":52}],39:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar win = require('./window');\r\nvar browser = require('./browser');\r\nvar is = require('./is');\r\nvar domObjects = require('./domObjects');\r\n\r\nvar domUtils = {\r\n  nodeContains: function nodeContains(parent, child) {\r\n    while (child) {\r\n      if (child === parent) {\r\n        return true;\r\n      }\r\n\r\n      child = child.parentNode;\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  closest: function closest(element, selector) {\r\n    while (is.element(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) {\r\n        return element;\r\n      }\r\n\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  parentNode: function parentNode(node) {\r\n    var parent = node.parentNode;\r\n\r\n    if (is.docFrag(parent)) {\r\n      // skip past #shado-root fragments\r\n      while ((parent = parent.host) && is.docFrag(parent)) {\r\n        continue;\r\n      }\r\n\r\n      return parent;\r\n    }\r\n\r\n    return parent;\r\n  },\r\n\r\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\r\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill ? function (element, selector, elems) {\r\n    elems = elems || element.parentNode.querySelectorAll(selector);\r\n\r\n    for (var i = 0, len = elems.length; i < len; i++) {\r\n      if (elems[i] === element) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  } : null,\r\n\r\n  matchesSelector: function matchesSelector(element, selector, nodeList) {\r\n    if (browser.useMatchesSelectorPolyfill) {\r\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\r\n    }\r\n\r\n    // remove /deep/ from selectors if shadowDOM polyfill is used\r\n    if (win.window !== win.realWindow) {\r\n      selector = selector.replace(/\\/deep\\//g, ' ');\r\n    }\r\n\r\n    return element[browser.prefixedMatchesSelector](selector);\r\n  },\r\n\r\n  // Test for the element that's \"above\" all other qualifiers\r\n  indexOfDeepestElement: function indexOfDeepestElement(elements) {\r\n    var deepestZoneParents = [];\r\n    var dropzoneParents = [];\r\n    var dropzone = void 0;\r\n    var deepestZone = elements[0];\r\n    var index = deepestZone ? 0 : -1;\r\n    var parent = void 0;\r\n    var child = void 0;\r\n    var i = void 0;\r\n    var n = void 0;\r\n\r\n    for (i = 1; i < elements.length; i++) {\r\n      dropzone = elements[i];\r\n\r\n      // an element might belong to multiple selector dropzones\r\n      if (!dropzone || dropzone === deepestZone) {\r\n        continue;\r\n      }\r\n\r\n      if (!deepestZone) {\r\n        deepestZone = dropzone;\r\n        index = i;\r\n        continue;\r\n      }\r\n\r\n      // check if the deepest or current are document.documentElement or document.rootElement\r\n      // - if the current dropzone is, do nothing and continue\r\n      if (dropzone.parentNode === dropzone.ownerDocument) {\r\n        continue;\r\n      }\r\n      // - if deepest is, update with the current dropzone and continue to next\r\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\r\n          deepestZone = dropzone;\r\n          index = i;\r\n          continue;\r\n        }\r\n\r\n      if (!deepestZoneParents.length) {\r\n        parent = deepestZone;\r\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\r\n          deepestZoneParents.unshift(parent);\r\n          parent = parent.parentNode;\r\n        }\r\n      }\r\n\r\n      // if this element is an svg element and the current deepest is\r\n      // an HTMLElement\r\n      if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\r\n\r\n        if (dropzone === deepestZone.parentNode) {\r\n          continue;\r\n        }\r\n\r\n        parent = dropzone.ownerSVGElement;\r\n      } else {\r\n        parent = dropzone;\r\n      }\r\n\r\n      dropzoneParents = [];\r\n\r\n      while (parent.parentNode !== parent.ownerDocument) {\r\n        dropzoneParents.unshift(parent);\r\n        parent = parent.parentNode;\r\n      }\r\n\r\n      n = 0;\r\n\r\n      // get (position of last common ancestor) + 1\r\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\r\n        n++;\r\n      }\r\n\r\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\r\n\r\n      child = parents[0].lastChild;\r\n\r\n      while (child) {\r\n        if (child === parents[1]) {\r\n          deepestZone = dropzone;\r\n          index = i;\r\n          deepestZoneParents = [];\r\n\r\n          break;\r\n        } else if (child === parents[2]) {\r\n          break;\r\n        }\r\n\r\n        child = child.previousSibling;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  },\r\n\r\n  matchesUpTo: function matchesUpTo(element, selector, limit) {\r\n    while (is.element(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) {\r\n        return true;\r\n      }\r\n\r\n      element = domUtils.parentNode(element);\r\n\r\n      if (element === limit) {\r\n        return domUtils.matchesSelector(element, selector);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  getActualElement: function getActualElement(element) {\r\n    return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\r\n  },\r\n\r\n  getScrollXY: function getScrollXY(relevantWindow) {\r\n    relevantWindow = relevantWindow || win.window;\r\n    return {\r\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\r\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\r\n    };\r\n  },\r\n\r\n  getElementClientRect: function getElementClientRect(element) {\r\n    var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\r\n\r\n    return clientRect && {\r\n      left: clientRect.left,\r\n      right: clientRect.right,\r\n      top: clientRect.top,\r\n      bottom: clientRect.bottom,\r\n      width: clientRect.width || clientRect.right - clientRect.left,\r\n      height: clientRect.height || clientRect.bottom - clientRect.top\r\n    };\r\n  },\r\n\r\n  getElementRect: function getElementRect(element) {\r\n    var clientRect = domUtils.getElementClientRect(element);\r\n\r\n    if (!browser.isIOS7 && clientRect) {\r\n      var scroll = domUtils.getScrollXY(win.getWindow(element));\r\n\r\n      clientRect.left += scroll.x;\r\n      clientRect.right += scroll.x;\r\n      clientRect.top += scroll.y;\r\n      clientRect.bottom += scroll.y;\r\n    }\r\n\r\n    return clientRect;\r\n  },\r\n\r\n  getPath: function getPath(element) {\r\n    var path = [];\r\n\r\n    while (element) {\r\n      path.push(element);\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return path;\r\n  },\r\n\r\n  trySelector: function trySelector(value) {\r\n    if (!is.string(value)) {\r\n      return false;\r\n    }\r\n\r\n    // an exception will be raised if it is invalid\r\n    domObjects.document.querySelector(value);\r\n    return true;\r\n  }\r\n};\r\n\r\nmodule.exports = domUtils;\r\n\r\n},{\"./browser\":37,\"./domObjects\":38,\"./is\":46,\"./window\":52}],40:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar is = require('./is');\r\nvar domUtils = require('./domUtils');\r\nvar pExtend = require('./pointerExtend');\r\n\r\nvar _require = require('./window'),\r\n    window = _require.window,\r\n    getWindow = _require.getWindow;\r\n\r\nvar _require2 = require('./arr'),\r\n    indexOf = _require2.indexOf,\r\n    contains = _require2.contains;\r\n\r\nvar useAttachEvent = 'attachEvent' in window && !('addEventListener' in window);\r\nvar addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener';\r\nvar removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener';\r\nvar on = useAttachEvent ? 'on' : '';\r\n\r\nvar elements = [];\r\nvar targets = [];\r\nvar attachedListeners = [];\r\n\r\n// {\r\n//   type: {\r\n//     selectors: ['selector', ...],\r\n//     contexts : [document, ...],\r\n//     listeners: [[listener, capture, passive], ...]\r\n//   }\r\n//  }\r\nvar delegatedEvents = {};\r\n\r\nvar documents = [];\r\n\r\nvar supportsOptions = !useAttachEvent && function () {\r\n  var supported = false;\r\n\r\n  window.document.createElement('div').addEventListener('test', null, {\r\n    get capture() {\r\n      supported = true;\r\n    }\r\n  });\r\n\r\n  return supported;\r\n}();\r\n\r\nfunction add(element, type, listener, optionalArg) {\r\n  var options = getOptions(optionalArg);\r\n  var elementIndex = indexOf(elements, element);\r\n  var target = targets[elementIndex];\r\n\r\n  if (!target) {\r\n    target = {\r\n      events: {},\r\n      typeCount: 0\r\n    };\r\n\r\n    elementIndex = elements.push(element) - 1;\r\n    targets.push(target);\r\n\r\n    attachedListeners.push(useAttachEvent ? {\r\n      supplied: [],\r\n      wrapped: [],\r\n      useCount: []\r\n    } : null);\r\n  }\r\n\r\n  if (!target.events[type]) {\r\n    target.events[type] = [];\r\n    target.typeCount++;\r\n  }\r\n\r\n  if (!contains(target.events[type], listener)) {\r\n    var ret = void 0;\r\n\r\n    if (useAttachEvent) {\r\n      var _attachedListeners$el = attachedListeners[elementIndex],\r\n          supplied = _attachedListeners$el.supplied,\r\n          wrapped = _attachedListeners$el.wrapped,\r\n          useCount = _attachedListeners$el.useCount;\r\n\r\n      var listenerIndex = indexOf(supplied, listener);\r\n\r\n      var wrappedListener = wrapped[listenerIndex] || function (event) {\r\n        if (!event.immediatePropagationStopped) {\r\n          event.target = event.srcElement;\r\n          event.currentTarget = element;\r\n\r\n          event.preventDefault = event.preventDefault || preventDef;\r\n          event.stopPropagation = event.stopPropagation || stopProp;\r\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\r\n\r\n          if (/mouse|click/.test(event.type)) {\r\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\r\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\r\n          }\r\n\r\n          listener(event);\r\n        }\r\n      };\r\n\r\n      ret = element[addEvent](on + type, wrappedListener, !!options.capture);\r\n\r\n      if (listenerIndex === -1) {\r\n        supplied.push(listener);\r\n        wrapped.push(wrappedListener);\r\n        useCount.push(1);\r\n      } else {\r\n        useCount[listenerIndex]++;\r\n      }\r\n    } else {\r\n      ret = element[addEvent](type, listener, supportsOptions ? options : !!options.capture);\r\n    }\r\n    target.events[type].push(listener);\r\n\r\n    return ret;\r\n  }\r\n}\r\n\r\nfunction remove(element, type, listener, optionalArg) {\r\n  var options = getOptions(optionalArg);\r\n  var elementIndex = indexOf(elements, element);\r\n  var target = targets[elementIndex];\r\n\r\n  if (!target || !target.events) {\r\n    return;\r\n  }\r\n\r\n  var wrappedListener = listener;\r\n  var listeners = void 0;\r\n  var listenerIndex = void 0;\r\n\r\n  if (useAttachEvent) {\r\n    listeners = attachedListeners[elementIndex];\r\n    listenerIndex = indexOf(listeners.supplied, listener);\r\n    wrappedListener = listeners.wrapped[listenerIndex];\r\n  }\r\n\r\n  if (type === 'all') {\r\n    for (type in target.events) {\r\n      if (target.events.hasOwnProperty(type)) {\r\n        remove(element, type, 'all');\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (target.events[type]) {\r\n    var len = target.events[type].length;\r\n\r\n    if (listener === 'all') {\r\n      for (var i = 0; i < len; i++) {\r\n        remove(element, type, target.events[type][i], options);\r\n      }\r\n      return;\r\n    } else {\r\n      for (var _i = 0; _i < len; _i++) {\r\n        if (target.events[type][_i] === listener) {\r\n          element[removeEvent](on + type, wrappedListener, supportsOptions ? options : !!options.capture);\r\n          target.events[type].splice(_i, 1);\r\n\r\n          if (useAttachEvent && listeners) {\r\n            listeners.useCount[listenerIndex]--;\r\n            if (listeners.useCount[listenerIndex] === 0) {\r\n              listeners.supplied.splice(listenerIndex, 1);\r\n              listeners.wrapped.splice(listenerIndex, 1);\r\n              listeners.useCount.splice(listenerIndex, 1);\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (target.events[type] && target.events[type].length === 0) {\r\n      target.events[type] = null;\r\n      target.typeCount--;\r\n    }\r\n  }\r\n\r\n  if (!target.typeCount) {\r\n    targets.splice(elementIndex, 1);\r\n    elements.splice(elementIndex, 1);\r\n    attachedListeners.splice(elementIndex, 1);\r\n  }\r\n}\r\n\r\nfunction addDelegate(selector, context, type, listener, optionalArg) {\r\n  var options = getOptions(optionalArg);\r\n  if (!delegatedEvents[type]) {\r\n    delegatedEvents[type] = {\r\n      selectors: [],\r\n      contexts: [],\r\n      listeners: []\r\n    };\r\n\r\n    // add delegate listener functions\r\n    for (var i = 0; i < documents.length; i++) {\r\n      add(documents[i], type, delegateListener);\r\n      add(documents[i], type, delegateUseCapture, true);\r\n    }\r\n  }\r\n\r\n  var delegated = delegatedEvents[type];\r\n  var index = void 0;\r\n\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (index === -1) {\r\n    index = delegated.selectors.length;\r\n\r\n    delegated.selectors.push(selector);\r\n    delegated.contexts.push(context);\r\n    delegated.listeners.push([]);\r\n  }\r\n\r\n  // keep listener and capture and passive flags\r\n  delegated.listeners[index].push([listener, !!options.capture, options.passive]);\r\n}\r\n\r\nfunction removeDelegate(selector, context, type, listener, optionalArg) {\r\n  var options = getOptions(optionalArg);\r\n  var delegated = delegatedEvents[type];\r\n  var matchFound = false;\r\n  var index = void 0;\r\n\r\n  if (!delegated) {\r\n    return;\r\n  }\r\n\r\n  // count from last index of delegated to 0\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    // look for matching selector and context Node\r\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\r\n\r\n      var listeners = delegated.listeners[index];\r\n\r\n      // each item of the listeners array is an array: [function, capture, passive]\r\n      for (var i = listeners.length - 1; i >= 0; i--) {\r\n        var _listeners$i = listeners[i],\r\n            fn = _listeners$i[0],\r\n            capture = _listeners$i[1],\r\n            passive = _listeners$i[2];\r\n\r\n        // check if the listener functions and capture and passive flags match\r\n\r\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\r\n          // remove the listener from the array of listeners\r\n          listeners.splice(i, 1);\r\n\r\n          // if all listeners for this interactable have been removed\r\n          // remove the interactable from the delegated arrays\r\n          if (!listeners.length) {\r\n            delegated.selectors.splice(index, 1);\r\n            delegated.contexts.splice(index, 1);\r\n            delegated.listeners.splice(index, 1);\r\n\r\n            // remove delegate function from context\r\n            remove(context, type, delegateListener);\r\n            remove(context, type, delegateUseCapture, true);\r\n\r\n            // remove the arrays if they are empty\r\n            if (!delegated.selectors.length) {\r\n              delegatedEvents[type] = null;\r\n            }\r\n          }\r\n\r\n          // only remove one listener\r\n          matchFound = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (matchFound) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// bound to the interactable context when a DOM event\r\n// listener is added to a selector interactable\r\nfunction delegateListener(event, optionalArg) {\r\n  var options = getOptions(optionalArg);\r\n  var fakeEvent = {};\r\n  var delegated = delegatedEvents[event.type];\r\n  var eventTarget = domUtils.getActualElement(event.path ? event.path[0] : event.target);\r\n  var element = eventTarget;\r\n\r\n  // duplicate the event so that currentTarget can be changed\r\n  pExtend(fakeEvent, event);\r\n\r\n  fakeEvent.originalEvent = event;\r\n  fakeEvent.preventDefault = preventOriginalDefault;\r\n\r\n  // climb up document tree looking for selector matches\r\n  while (is.element(element)) {\r\n    for (var i = 0; i < delegated.selectors.length; i++) {\r\n      var selector = delegated.selectors[i];\r\n      var context = delegated.contexts[i];\r\n\r\n      if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\r\n\r\n        var listeners = delegated.listeners[i];\r\n\r\n        fakeEvent.currentTarget = element;\r\n\r\n        for (var j = 0; j < listeners.length; j++) {\r\n          var _listeners$j = listeners[j],\r\n              fn = _listeners$j[0],\r\n              capture = _listeners$j[1],\r\n              passive = _listeners$j[2];\r\n\r\n\r\n          if (capture === !!options.capture && passive === options.passive) {\r\n            fn(fakeEvent);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    element = domUtils.parentNode(element);\r\n  }\r\n}\r\n\r\nfunction delegateUseCapture(event) {\r\n  return delegateListener.call(this, event, true);\r\n}\r\n\r\nfunction preventDef() {\r\n  this.returnValue = false;\r\n}\r\n\r\nfunction preventOriginalDefault() {\r\n  this.originalEvent.preventDefault();\r\n}\r\n\r\nfunction stopProp() {\r\n  this.cancelBubble = true;\r\n}\r\n\r\nfunction stopImmProp() {\r\n  this.cancelBubble = true;\r\n  this.immediatePropagationStopped = true;\r\n}\r\n\r\nfunction getOptions(param) {\r\n  return is.object(param) ? param : { capture: param };\r\n}\r\n\r\nmodule.exports = {\r\n  add: add,\r\n  remove: remove,\r\n\r\n  addDelegate: addDelegate,\r\n  removeDelegate: removeDelegate,\r\n\r\n  delegateListener: delegateListener,\r\n  delegateUseCapture: delegateUseCapture,\r\n  delegatedEvents: delegatedEvents,\r\n  documents: documents,\r\n\r\n  useAttachEvent: useAttachEvent,\r\n  supportsOptions: supportsOptions,\r\n\r\n  _elements: elements,\r\n  _targets: targets,\r\n  _attachedListeners: attachedListeners\r\n};\r\n\r\n},{\"./arr\":36,\"./domUtils\":39,\"./is\":46,\"./pointerExtend\":48,\"./window\":52}],41:[function(require,module,exports){\r\n\"use strict\";\r\n\r\nmodule.exports = function extend(dest, source) {\r\n  for (var prop in source) {\r\n    dest[prop] = source[prop];\r\n  }\r\n  return dest;\r\n};\r\n\r\n},{}],42:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar _require = require('./rect'),\r\n    resolveRectLike = _require.resolveRectLike,\r\n    rectToXY = _require.rectToXY;\r\n\r\nmodule.exports = function (target, element, action) {\r\n  var actionOptions = target.options[action];\r\n  var actionOrigin = actionOptions && actionOptions.origin;\r\n  var origin = actionOrigin || target.options.origin;\r\n\r\n  var originRect = resolveRectLike(origin, target, element, [target && element]);\r\n\r\n  return rectToXY(originRect) || { x: 0, y: 0 };\r\n};\r\n\r\n},{\"./rect\":51}],43:[function(require,module,exports){\r\n\"use strict\";\r\n\r\nmodule.exports = function (x, y) {\r\n  return Math.sqrt(x * x + y * y);\r\n};\r\n\r\n},{}],44:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar extend = require('./extend');\r\nvar win = require('./window');\r\n\r\nvar utils = {\r\n  warnOnce: function warnOnce(method, message) {\r\n    var warned = false;\r\n\r\n    return function () {\r\n      if (!warned) {\r\n        win.window.console.warn(message);\r\n        warned = true;\r\n      }\r\n\r\n      return method.apply(this, arguments);\r\n    };\r\n  },\r\n\r\n  // http://stackoverflow.com/a/5634528/2280888\r\n  _getQBezierValue: function _getQBezierValue(t, p1, p2, p3) {\r\n    var iT = 1 - t;\r\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\r\n  },\r\n\r\n  getQuadraticCurvePoint: function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\r\n    return {\r\n      x: utils._getQBezierValue(position, startX, cpX, endX),\r\n      y: utils._getQBezierValue(position, startY, cpY, endY)\r\n    };\r\n  },\r\n\r\n  // http://gizma.com/easing/\r\n  easeOutQuad: function easeOutQuad(t, b, c, d) {\r\n    t /= d;\r\n    return -c * t * (t - 2) + b;\r\n  },\r\n\r\n  copyAction: function copyAction(dest, src) {\r\n    dest.name = src.name;\r\n    dest.axis = src.axis;\r\n    dest.edges = src.edges;\r\n\r\n    return dest;\r\n  },\r\n\r\n  is: require('./is'),\r\n  extend: extend,\r\n  hypot: require('./hypot'),\r\n  getOriginXY: require('./getOriginXY')\r\n};\r\n\r\nextend(utils, require('./arr'));\r\nextend(utils, require('./domUtils'));\r\nextend(utils, require('./pointerUtils'));\r\nextend(utils, require('./rect'));\r\n\r\nmodule.exports = utils;\r\n\r\n},{\"./arr\":36,\"./domUtils\":39,\"./extend\":41,\"./getOriginXY\":42,\"./hypot\":43,\"./is\":46,\"./pointerUtils\":49,\"./rect\":51,\"./window\":52}],45:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar scope = require('../scope');\r\nvar utils = require('./index');\r\n\r\nvar finder = {\r\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'],\r\n\r\n  search: function search(pointer, eventType, eventTarget) {\r\n    var pointerType = utils.getPointerType(pointer);\r\n    var pointerId = utils.getPointerId(pointer);\r\n    var details = { pointer: pointer, pointerId: pointerId, pointerType: pointerType, eventType: eventType, eventTarget: eventTarget };\r\n\r\n    for (var _iterator = finder.methodOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var method = _ref;\r\n\r\n      var interaction = finder[method](details);\r\n\r\n      if (interaction) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // try to resume simulation with a new pointer\r\n  simulationResume: function simulationResume(_ref2) {\r\n    var pointerType = _ref2.pointerType,\r\n        eventType = _ref2.eventType,\r\n        eventTarget = _ref2.eventTarget;\r\n\r\n    if (!/down|start/i.test(eventType)) {\r\n      return null;\r\n    }\r\n\r\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\r\n      var _ref3;\r\n\r\n      if (_isArray2) {\r\n        if (_i2 >= _iterator2.length) break;\r\n        _ref3 = _iterator2[_i2++];\r\n      } else {\r\n        _i2 = _iterator2.next();\r\n        if (_i2.done) break;\r\n        _ref3 = _i2.value;\r\n      }\r\n\r\n      var interaction = _ref3;\r\n\r\n      var element = eventTarget;\r\n\r\n      if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {\r\n        while (element) {\r\n          // if the element is the interaction element\r\n          if (element === interaction.element) {\r\n            return interaction;\r\n          }\r\n          element = utils.parentNode(element);\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // if it's a mouse or pen interaction\r\n  mouseOrPen: function mouseOrPen(_ref4) {\r\n    var pointerId = _ref4.pointerId,\r\n        pointerType = _ref4.pointerType,\r\n        eventType = _ref4.eventType;\r\n\r\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\r\n      return null;\r\n    }\r\n\r\n    var firstNonActive = void 0;\r\n\r\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\r\n      var _ref5;\r\n\r\n      if (_isArray3) {\r\n        if (_i3 >= _iterator3.length) break;\r\n        _ref5 = _iterator3[_i3++];\r\n      } else {\r\n        _i3 = _iterator3.next();\r\n        if (_i3.done) break;\r\n        _ref5 = _i3.value;\r\n      }\r\n\r\n      var interaction = _ref5;\r\n\r\n      if (interaction.pointerType === pointerType) {\r\n        // if it's a down event, skip interactions with running simulations\r\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) {\r\n          continue;\r\n        }\r\n\r\n        // if the interaction is active, return it immediately\r\n        if (interaction.interacting()) {\r\n          return interaction;\r\n        }\r\n        // otherwise save it and look for another active interaction\r\n        else if (!firstNonActive) {\r\n            firstNonActive = interaction;\r\n          }\r\n      }\r\n    }\r\n\r\n    // if no active mouse interaction was found use the first inactive mouse\r\n    // interaction\r\n    if (firstNonActive) {\r\n      return firstNonActive;\r\n    }\r\n\r\n    // find any mouse or pen interaction.\r\n    // ignore the interaction if the eventType is a *down, and a simulation\r\n    // is active\r\n    for (var _iterator4 = scope.interactions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\r\n      var _ref6;\r\n\r\n      if (_isArray4) {\r\n        if (_i4 >= _iterator4.length) break;\r\n        _ref6 = _iterator4[_i4++];\r\n      } else {\r\n        _i4 = _iterator4.next();\r\n        if (_i4.done) break;\r\n        _ref6 = _i4.value;\r\n      }\r\n\r\n      var _interaction = _ref6;\r\n\r\n      if (_interaction.pointerType === pointerType && !(/down/i.test(eventType) && _interaction.simulation)) {\r\n        return _interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // get interaction that has this pointer\r\n  hasPointer: function hasPointer(_ref7) {\r\n    var pointerId = _ref7.pointerId;\r\n\r\n    for (var _iterator5 = scope.interactions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\r\n      var _ref8;\r\n\r\n      if (_isArray5) {\r\n        if (_i5 >= _iterator5.length) break;\r\n        _ref8 = _iterator5[_i5++];\r\n      } else {\r\n        _i5 = _iterator5.next();\r\n        if (_i5.done) break;\r\n        _ref8 = _i5.value;\r\n      }\r\n\r\n      var interaction = _ref8;\r\n\r\n      if (utils.contains(interaction.pointerIds, pointerId)) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // get first idle interaction with a matching pointerType\r\n  idle: function idle(_ref9) {\r\n    var pointerType = _ref9.pointerType;\r\n\r\n    for (var _iterator6 = scope.interactions, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\r\n      var _ref10;\r\n\r\n      if (_isArray6) {\r\n        if (_i6 >= _iterator6.length) break;\r\n        _ref10 = _iterator6[_i6++];\r\n      } else {\r\n        _i6 = _iterator6.next();\r\n        if (_i6.done) break;\r\n        _ref10 = _i6.value;\r\n      }\r\n\r\n      var interaction = _ref10;\r\n\r\n      // if there's already a pointer held down\r\n      if (interaction.pointerIds.length === 1) {\r\n        var target = interaction.target;\r\n        // don't add this pointer if there is a target interactable and it\r\n        // isn't gesturable\r\n        if (target && !target.options.gesture.enabled) {\r\n          continue;\r\n        }\r\n      }\r\n      // maximum of 2 pointers per interaction\r\n      else if (interaction.pointerIds.length >= 2) {\r\n          continue;\r\n        }\r\n\r\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\r\n        return interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n};\r\n\r\nmodule.exports = finder;\r\n\r\n},{\"../scope\":34,\"./index\":44}],46:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar win = require('./window');\r\nvar isWindow = require('./isWindow');\r\n\r\nvar is = {\r\n  array: function array() {},\r\n\r\n  window: function window(thing) {\r\n    return thing === win.window || isWindow(thing);\r\n  },\r\n\r\n  docFrag: function docFrag(thing) {\r\n    return is.object(thing) && thing.nodeType === 11;\r\n  },\r\n\r\n  object: function object(thing) {\r\n    return !!thing && (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object';\r\n  },\r\n\r\n  function: function _function(thing) {\r\n    return typeof thing === 'function';\r\n  },\r\n\r\n  number: function number(thing) {\r\n    return typeof thing === 'number';\r\n  },\r\n\r\n  bool: function bool(thing) {\r\n    return typeof thing === 'boolean';\r\n  },\r\n\r\n  string: function string(thing) {\r\n    return typeof thing === 'string';\r\n  },\r\n\r\n  element: function element(thing) {\r\n    if (!thing || (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    var _window = win.getWindow(thing) || win.window;\r\n\r\n    return (/object|function/.test(_typeof(_window.Element)) ? thing instanceof _window.Element //DOM2\r\n      : thing.nodeType === 1 && typeof thing.nodeName === 'string'\r\n    );\r\n  }\r\n};\r\n\r\nis.array = function (thing) {\r\n  return is.object(thing) && typeof thing.length !== 'undefined' && is.function(thing.splice);\r\n};\r\n\r\nmodule.exports = is;\r\n\r\n},{\"./isWindow\":47,\"./window\":52}],47:[function(require,module,exports){\r\n\"use strict\";\r\n\r\nmodule.exports = function (thing) {\r\n  return !!(thing && thing.Window) && thing instanceof thing.Window;\r\n};\r\n\r\n},{}],48:[function(require,module,exports){\r\n'use strict';\r\n\r\nfunction pointerExtend(dest, source) {\r\n  for (var prop in source) {\r\n    var prefixedPropREs = module.exports.prefixedPropREs;\r\n    var deprecated = false;\r\n\r\n    // skip deprecated prefixed properties\r\n    for (var vendor in prefixedPropREs) {\r\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\r\n        deprecated = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!deprecated && typeof source[prop] !== 'function') {\r\n      dest[prop] = source[prop];\r\n    }\r\n  }\r\n  return dest;\r\n}\r\n\r\npointerExtend.prefixedPropREs = {\r\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\r\n};\r\n\r\nmodule.exports = pointerExtend;\r\n\r\n},{}],49:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar hypot = require('./hypot');\r\nvar browser = require('./browser');\r\nvar dom = require('./domObjects');\r\nvar domUtils = require('./domUtils');\r\nvar domObjects = require('./domObjects');\r\nvar is = require('./is');\r\nvar pointerExtend = require('./pointerExtend');\r\n\r\nvar pointerUtils = {\r\n  copyCoords: function copyCoords(dest, src) {\r\n    dest.page = dest.page || {};\r\n    dest.page.x = src.page.x;\r\n    dest.page.y = src.page.y;\r\n\r\n    dest.client = dest.client || {};\r\n    dest.client.x = src.client.x;\r\n    dest.client.y = src.client.y;\r\n\r\n    dest.timeStamp = src.timeStamp;\r\n  },\r\n\r\n  setCoordDeltas: function setCoordDeltas(targetObj, prev, cur) {\r\n    targetObj.page.x = cur.page.x - prev.page.x;\r\n    targetObj.page.y = cur.page.y - prev.page.y;\r\n    targetObj.client.x = cur.client.x - prev.client.x;\r\n    targetObj.client.y = cur.client.y - prev.client.y;\r\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\r\n\r\n    // set pointer velocity\r\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\r\n\r\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\r\n    targetObj.page.vx = targetObj.page.x / dt;\r\n    targetObj.page.vy = targetObj.page.y / dt;\r\n\r\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\r\n    targetObj.client.vx = targetObj.client.x / dt;\r\n    targetObj.client.vy = targetObj.client.y / dt;\r\n  },\r\n\r\n  isNativePointer: function isNativePointer(pointer) {\r\n    return pointer instanceof dom.Event || pointer instanceof dom.Touch;\r\n  },\r\n\r\n  // Get specified X/Y coords for mouse or event.touches[0]\r\n  getXY: function getXY(type, pointer, xy) {\r\n    xy = xy || {};\r\n    type = type || 'page';\r\n\r\n    xy.x = pointer[type + 'X'];\r\n    xy.y = pointer[type + 'Y'];\r\n\r\n    return xy;\r\n  },\r\n\r\n  getPageXY: function getPageXY(pointer, page) {\r\n    page = page || {};\r\n\r\n    // Opera Mobile handles the viewport and scrolling oddly\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      pointerUtils.getXY('screen', pointer, page);\r\n\r\n      page.x += window.scrollX;\r\n      page.y += window.scrollY;\r\n    } else {\r\n      pointerUtils.getXY('page', pointer, page);\r\n    }\r\n\r\n    return page;\r\n  },\r\n\r\n  getClientXY: function getClientXY(pointer, client) {\r\n    client = client || {};\r\n\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      // Opera Mobile handles the viewport and scrolling oddly\r\n      pointerUtils.getXY('screen', pointer, client);\r\n    } else {\r\n      pointerUtils.getXY('client', pointer, client);\r\n    }\r\n\r\n    return client;\r\n  },\r\n\r\n  getPointerId: function getPointerId(pointer) {\r\n    return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\r\n  },\r\n\r\n  setCoords: function setCoords(targetObj, pointers, timeStamp) {\r\n    var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];\r\n\r\n    var tmpXY = {};\r\n\r\n    pointerUtils.getPageXY(pointer, tmpXY);\r\n    targetObj.page.x = tmpXY.x;\r\n    targetObj.page.y = tmpXY.y;\r\n\r\n    pointerUtils.getClientXY(pointer, tmpXY);\r\n    targetObj.client.x = tmpXY.x;\r\n    targetObj.client.y = tmpXY.y;\r\n\r\n    targetObj.timeStamp = is.number(timeStamp) ? timeStamp : new Date().getTime();\r\n  },\r\n\r\n  pointerExtend: pointerExtend,\r\n\r\n  getTouchPair: function getTouchPair(event) {\r\n    var touches = [];\r\n\r\n    // array of touches is supplied\r\n    if (is.array(event)) {\r\n      touches[0] = event[0];\r\n      touches[1] = event[1];\r\n    }\r\n    // an event\r\n    else {\r\n        if (event.type === 'touchend') {\r\n          if (event.touches.length === 1) {\r\n            touches[0] = event.touches[0];\r\n            touches[1] = event.changedTouches[0];\r\n          } else if (event.touches.length === 0) {\r\n            touches[0] = event.changedTouches[0];\r\n            touches[1] = event.changedTouches[1];\r\n          }\r\n        } else {\r\n          touches[0] = event.touches[0];\r\n          touches[1] = event.touches[1];\r\n        }\r\n      }\r\n\r\n    return touches;\r\n  },\r\n\r\n  pointerAverage: function pointerAverage(pointers) {\r\n    var average = {\r\n      pageX: 0,\r\n      pageY: 0,\r\n      clientX: 0,\r\n      clientY: 0,\r\n      screenX: 0,\r\n      screenY: 0\r\n    };\r\n\r\n    for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\r\n      var _ref;\r\n\r\n      if (_isArray) {\r\n        if (_i >= _iterator.length) break;\r\n        _ref = _iterator[_i++];\r\n      } else {\r\n        _i = _iterator.next();\r\n        if (_i.done) break;\r\n        _ref = _i.value;\r\n      }\r\n\r\n      var pointer = _ref;\r\n\r\n      for (var _prop in average) {\r\n        average[_prop] += pointer[_prop];\r\n      }\r\n    }\r\n    for (var prop in average) {\r\n      average[prop] /= pointers.length;\r\n    }\r\n\r\n    return average;\r\n  },\r\n\r\n  touchBBox: function touchBBox(event) {\r\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\r\n      return;\r\n    }\r\n\r\n    var touches = pointerUtils.getTouchPair(event);\r\n    var minX = Math.min(touches[0].pageX, touches[1].pageX);\r\n    var minY = Math.min(touches[0].pageY, touches[1].pageY);\r\n    var maxX = Math.max(touches[0].pageX, touches[1].pageX);\r\n    var maxY = Math.max(touches[0].pageY, touches[1].pageY);\r\n\r\n    return {\r\n      x: minX,\r\n      y: minY,\r\n      left: minX,\r\n      top: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY\r\n    };\r\n  },\r\n\r\n  touchDistance: function touchDistance(event, deltaSource) {\r\n    var sourceX = deltaSource + 'X';\r\n    var sourceY = deltaSource + 'Y';\r\n    var touches = pointerUtils.getTouchPair(event);\r\n\r\n    var dx = touches[0][sourceX] - touches[1][sourceX];\r\n    var dy = touches[0][sourceY] - touches[1][sourceY];\r\n\r\n    return hypot(dx, dy);\r\n  },\r\n\r\n  touchAngle: function touchAngle(event, prevAngle, deltaSource) {\r\n    var sourceX = deltaSource + 'X';\r\n    var sourceY = deltaSource + 'Y';\r\n    var touches = pointerUtils.getTouchPair(event);\r\n    var dx = touches[1][sourceX] - touches[0][sourceX];\r\n    var dy = touches[1][sourceY] - touches[0][sourceY];\r\n    var angle = 180 * Math.atan2(dy, dx) / Math.PI;\r\n\r\n    return angle;\r\n  },\r\n\r\n  getPointerType: function getPointerType(pointer) {\r\n    return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]\r\n    // if the PointerEvent API isn't available, then the \"pointer\" must\r\n    // be either a MouseEvent, TouchEvent, or Touch object\r\n    : /touch/.test(pointer.type) || pointer instanceof domObjects.Touch ? 'touch' : 'mouse';\r\n  },\r\n\r\n  // [ event.target, event.currentTarget ]\r\n  getEventTargets: function getEventTargets(event) {\r\n    return [domUtils.getActualElement(event.path ? event.path[0] : event.target), domUtils.getActualElement(event.currentTarget)];\r\n  }\r\n};\r\n\r\nmodule.exports = pointerUtils;\r\n\r\n},{\"./browser\":37,\"./domObjects\":38,\"./domUtils\":39,\"./hypot\":43,\"./is\":46,\"./pointerExtend\":48}],50:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar _require = require('./window'),\r\n    window = _require.window;\r\n\r\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\r\nvar lastTime = 0;\r\nvar request = void 0;\r\nvar cancel = void 0;\r\n\r\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\r\n  request = window[vendors[x] + 'RequestAnimationFrame'];\r\n  cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n}\r\n\r\nif (!request) {\r\n  request = function request(callback) {\r\n    var currTime = new Date().getTime();\r\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n    var id = setTimeout(function () {\r\n      callback(currTime + timeToCall);\r\n    }, timeToCall);\r\n\r\n    lastTime = currTime + timeToCall;\r\n    return id;\r\n  };\r\n}\r\n\r\nif (!cancel) {\r\n  cancel = function cancel(id) {\r\n    clearTimeout(id);\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  request: request,\r\n  cancel: cancel\r\n};\r\n\r\n},{\"./window\":52}],51:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar extend = require('./extend');\r\nvar is = require('./is');\r\n\r\nvar _require = require('./domUtils'),\r\n    closest = _require.closest,\r\n    parentNode = _require.parentNode,\r\n    getElementRect = _require.getElementRect;\r\n\r\nvar rectUtils = {\r\n  getStringOptionResult: function getStringOptionResult(value, interactable, element) {\r\n    if (!is.string(value)) {\r\n      return null;\r\n    }\r\n\r\n    if (value === 'parent') {\r\n      value = parentNode(element);\r\n    } else if (value === 'self') {\r\n      value = interactable.getRect(element);\r\n    } else {\r\n      value = closest(element, value);\r\n    }\r\n\r\n    return value;\r\n  },\r\n\r\n  resolveRectLike: function resolveRectLike(value, interactable, element, functionArgs) {\r\n    value = rectUtils.getStringOptionResult(value, interactable, element) || value;\r\n\r\n    if (is.function(value)) {\r\n      value = value.apply(null, functionArgs);\r\n    }\r\n\r\n    if (is.element(value)) {\r\n      value = getElementRect(value);\r\n    }\r\n\r\n    return value;\r\n  },\r\n\r\n  rectToXY: function rectToXY(rect) {\r\n    return rect && {\r\n      x: 'x' in rect ? rect.x : rect.left,\r\n      y: 'y' in rect ? rect.y : rect.top\r\n    };\r\n  },\r\n\r\n  xywhToTlbr: function xywhToTlbr(rect) {\r\n    if (rect && !('left' in rect && 'top' in rect)) {\r\n      rect = extend({}, rect);\r\n\r\n      rect.left = rect.x || 0;\r\n      rect.top = rect.y || 0;\r\n      rect.right = rect.right || rect.left + rect.width;\r\n      rect.bottom = rect.bottom || rect.top + rect.height;\r\n    }\r\n\r\n    return rect;\r\n  },\r\n\r\n  tlbrToXywh: function tlbrToXywh(rect) {\r\n    if (rect && !('x' in rect && 'y' in rect)) {\r\n      rect = extend({}, rect);\r\n\r\n      rect.x = rect.left || 0;\r\n      rect.top = rect.top || 0;\r\n      rect.width = rect.width || rect.right - rect.x;\r\n      rect.height = rect.height || rect.bottom - rect.y;\r\n    }\r\n\r\n    return rect;\r\n  }\r\n};\r\n\r\nmodule.exports = rectUtils;\r\n\r\n},{\"./domUtils\":39,\"./extend\":41,\"./is\":46}],52:[function(require,module,exports){\r\n'use strict';\r\n\r\nvar win = module.exports;\r\nvar isWindow = require('./isWindow');\r\n\r\nfunction init(window) {\r\n  // get wrapped window if using Shadow DOM polyfill\r\n\r\n  win.realWindow = window;\r\n\r\n  // create a TextNode\r\n  var el = window.document.createTextNode('');\r\n\r\n  // check if it's wrapped by a polyfill\r\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\r\n    // use wrapped window\r\n    window = window.wrap(window);\r\n  }\r\n\r\n  win.window = window;\r\n}\r\n\r\nif (typeof window === 'undefined') {\r\n  win.window = undefined;\r\n  win.realWindow = undefined;\r\n} else {\r\n  init(window);\r\n}\r\n\r\nwin.getWindow = function getWindow(node) {\r\n  if (isWindow(node)) {\r\n    return node;\r\n  }\r\n\r\n  var rootNode = node.ownerDocument || node;\r\n\r\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\r\n};\r\n\r\nwin.init = init;\r\n\r\n},{\"./isWindow\":47}]},{},[1])(1)\r\n});\r\n\r\n\r\n//# sourceMappingURL=interact.js.map\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJhY3Rqcy9kaXN0L2ludGVyYWN0LmpzP2JiZmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IllBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQTJELG1CQUFtQixnREFBZ0QsYUFBYSxLQUFLLE1BQU0sZ0NBQWdDLFNBQVMscUNBQXFDLFNBQVMsbUNBQW1DLE9BQU8sS0FBSyxPQUFPLGtCQUFrQixhQUFhLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsOEJBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDNXlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMsRUFBRSx5Q0FBeUM7QUFDNUM7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QywrQ0FBK0M7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZUFBZTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUMsRUFBRSx3Q0FBd0M7QUFDM0M7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QjtBQUN4QiwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdGQUF3RjtBQUMzRjs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3SkFBd0o7QUFDeEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUE7QUFDQTs7QUFFQSw2S0FBNks7QUFDN0s7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkJBQTJCLHFCQUFxQjs7QUFFaEQ7O0FBRUE7QUFDQSx5S0FBeUs7QUFDeks7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLG1PQUFtTztBQUN0Tzs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCO0FBQ3ZCLHdCQUF3Qjs7QUFFeEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQkFBaUI7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsb0JBQW9COztBQUU5QztBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQsa0RBQWtELG9CQUFvQjtBQUN0RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQseUNBQXlDLFNBQVM7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7O0FBRUEsK0RBQStELDJCQUEyQjtBQUMxRjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFvRDtBQUM3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDJCQUEyQjtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUpBQWlKO0FBQ2pKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7O0FBRUE7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsK0lBQStJO0FBQ2xKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdDQUF3QztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGtDQUFrQyxzR0FBc0c7QUFDeEksR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDRHQUE0RztBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEpBQTBKO0FBQzFKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDhDQUE4QztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiw4Q0FBOEM7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsOENBQThDO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxlQUFlOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5Qjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMklBQTJJO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsWUFBWSxhQUFhOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsNEdBQTRHO0FBQy9HOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSxrSUFBa0k7QUFDckk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSxtSEFBbUg7QUFDdEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFtRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0pBQW9KO0FBQ3BKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxnRkFBZ0Y7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDJCQUEyQjtBQUN2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG9KQUFvSjtBQUNwSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHNNQUFzTTtBQUN6TTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsRUFBRSwrQkFBK0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDRHQUE0RztBQUMvRzs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsbUNBQW1DO0FBQ3RDOztBQUVBOztBQUVBLENBQUMsRUFBRSxtQ0FBbUM7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLGFBQWE7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUsc2dCQUFzZ0I7QUFDemdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2SUFBNkk7QUFDN0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQkFBbUI7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxSkFBcUo7QUFDcko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSx3R0FBd0c7QUFDM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBKQUEwSjtBQUMxSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDRHQUE0RztBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJKQUEySjtBQUMzSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLG1JQUFtSTtBQUN0STs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw0QkFBNEI7QUFDL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdKQUF3SjtBQUN4Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQ0FBMEM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGNBQWM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxxQkFBcUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHlEQUF5RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QUFDQSxtQkFBbUI7O0FBRW5CLDJKQUEySjtBQUMzSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1LQUFtSztBQUNuSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1LQUFtSztBQUNuSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1LQUFtSztBQUNuSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxtS0FBbUs7QUFDbks7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsbUtBQW1LO0FBQ25LOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDJCQUEyQjtBQUM5Qjs7QUFFQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDhCQUE4QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpSkFBaUo7QUFDako7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSw2RkFBNkY7QUFDaEc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxjQUFjO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHdDQUF3QztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRztBQUN4QixDQUFDOzs7QUFHRCIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBpbnRlcmFjdC5qcyB2MS4zLjAtYWxwaGEuNCtzaGEuNzk3MDQxNi1kaXJ0eVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUYXllIEFkZXllbWkgPGRldkB0YXllLm1lPlxyXG4gKiBPcGVuIHNvdXJjZSB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vdGF5ZS9pbnRlcmFjdC5qcy9tYXN0ZXIvTElDRU5TRVxyXG4gKi9cclxuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuaW50ZXJhY3QgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqIEluIGEgKHdpbmRvd2xlc3MpIHNlcnZlciBlbnZpcm9ubWVudCB0aGlzIGZpbGUgZXhwb3J0cyBhIGZhY3RvcnkgZnVuY3Rpb25cclxuICogdGhhdCB0YWtlcyB0aGUgd2luZG93IHRvIHVzZS5cclxuICpcclxuICogICAgIHZhciBpbnRlcmFjdCA9IHJlcXVpcmUoJ2ludGVyYWN0LmpzJykod2luZG93T2JqZWN0KTtcclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YXllL2ludGVyYWN0LmpzL2lzc3Vlcy8xODdcclxuICovXHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHdpbmRvdykge1xyXG4gICAgcmVxdWlyZSgnLi9zcmMvdXRpbHMvd2luZG93JykuaW5pdCh3aW5kb3cpO1xyXG5cclxuICAgIHJldHVybiByZXF1aXJlKCcuL3NyYy9pbmRleCcpO1xyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9pbmRleCcpO1xyXG59XHJcblxyXG59LHtcIi4vc3JjL2luZGV4XCI6MTksXCIuL3NyYy91dGlscy93aW5kb3dcIjo1Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9hcnInKSxcclxuICAgIGluZGV4T2YgPSBfcmVxdWlyZS5pbmRleE9mO1xyXG5cclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbHMvZXh0ZW5kLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBmaXJlVW50aWxJbW1lZGlhdGVTdG9wcGVkKGV2ZW50LCBsaXN0ZW5lcnMpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZXZlbnQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuICAgIGxpc3RlbmVyc1tpXShldmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgRXZlbnRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIEV2ZW50YWJsZShvcHRpb25zKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRhYmxlKTtcclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMgfHwge30pO1xyXG4gIH1cclxuXHJcbiAgRXZlbnRhYmxlLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gZmlyZShldmVudCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHZvaWQgMDtcclxuICAgIHZhciBvbkV2ZW50ID0gJ29uJyArIGV2ZW50LnR5cGU7XHJcbiAgICB2YXIgZ2xvYmFsID0gdGhpcy5nbG9iYWw7XHJcblxyXG4gICAgLy8gSW50ZXJhY3RhYmxlI29uKCkgbGlzdGVuZXJzXHJcbiAgICBpZiAobGlzdGVuZXJzID0gdGhpc1tldmVudC50eXBlXSkge1xyXG4gICAgICBmaXJlVW50aWxJbW1lZGlhdGVTdG9wcGVkKGV2ZW50LCBsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGludGVyYWN0YWJsZS5vbmV2ZW50IGxpc3RlbmVyXHJcbiAgICBpZiAodGhpc1tvbkV2ZW50XSkge1xyXG4gICAgICB0aGlzW29uRXZlbnRdKGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnRlcmFjdC5vbigpIGxpc3RlbmVyc1xyXG4gICAgaWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgJiYgZ2xvYmFsICYmIChsaXN0ZW5lcnMgPSBnbG9iYWxbZXZlbnQudHlwZV0pKSB7XHJcbiAgICAgIGZpcmVVbnRpbEltbWVkaWF0ZVN0b3BwZWQoZXZlbnQsIGxpc3RlbmVycyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIC8vIGlmIHRoaXMgdHlwZSBvZiBldmVudCB3YXMgbmV2ZXIgYm91bmRcclxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcclxuICAgICAgdGhpc1tldmVudFR5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpc1tldmVudFR5cGVdID0gW2xpc3RlbmVyXTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBFdmVudGFibGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAvLyBpZiBpdCBpcyBhbiBhY3Rpb24gZXZlbnQgdHlwZVxyXG4gICAgdmFyIGV2ZW50TGlzdCA9IHRoaXNbZXZlbnRUeXBlXTtcclxuICAgIHZhciBpbmRleCA9IGV2ZW50TGlzdCA/IGluZGV4T2YoZXZlbnRMaXN0LCBsaXN0ZW5lcikgOiAtMTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIGV2ZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChldmVudExpc3QgJiYgZXZlbnRMaXN0Lmxlbmd0aCA9PT0gMCB8fCAhbGlzdGVuZXIpIHtcclxuICAgICAgdGhpc1tldmVudFR5cGVdID0gbGlzdGVuZXI7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEV2ZW50YWJsZTtcclxufSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudGFibGU7XHJcblxyXG59LHtcIi4vdXRpbHMvYXJyXCI6MzYsXCIuL3V0aWxzL2V4dGVuZC5qc1wiOjQxfV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscy9leHRlbmQnKTtcclxudmFyIGdldE9yaWdpblhZID0gcmVxdWlyZSgnLi91dGlscy9nZXRPcmlnaW5YWScpO1xyXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRPcHRpb25zJyk7XHJcbnZhciBzaWduYWxzID0gcmVxdWlyZSgnLi91dGlscy9TaWduYWxzJykubmV3KCk7XHJcblxyXG52YXIgSW50ZXJhY3RFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBJbnRlcmFjdEV2ZW50KGludGVyYWN0aW9uLCBldmVudCwgYWN0aW9uLCBwaGFzZSwgZWxlbWVudCwgcmVsYXRlZCkge1xyXG4gICAgdmFyIHByZUVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XHJcblxyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyYWN0RXZlbnQpO1xyXG5cclxuICAgIHZhciB0YXJnZXQgPSBpbnRlcmFjdGlvbi50YXJnZXQ7XHJcbiAgICB2YXIgZGVsdGFTb3VyY2UgPSAodGFyZ2V0ICYmIHRhcmdldC5vcHRpb25zIHx8IGRlZmF1bHRzKS5kZWx0YVNvdXJjZTtcclxuICAgIHZhciBvcmlnaW4gPSBnZXRPcmlnaW5YWSh0YXJnZXQsIGVsZW1lbnQsIGFjdGlvbik7XHJcbiAgICB2YXIgc3RhcnRpbmcgPSBwaGFzZSA9PT0gJ3N0YXJ0JztcclxuICAgIHZhciBlbmRpbmcgPSBwaGFzZSA9PT0gJ2VuZCc7XHJcbiAgICB2YXIgY29vcmRzID0gc3RhcnRpbmcgPyBpbnRlcmFjdGlvbi5zdGFydENvb3JkcyA6IGludGVyYWN0aW9uLmN1ckNvb3JkcztcclxuICAgIHZhciBwcmV2RXZlbnQgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQ7XHJcblxyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgaW50ZXJhY3Rpb24uZWxlbWVudDtcclxuXHJcbiAgICB2YXIgcGFnZSA9IGV4dGVuZCh7fSwgY29vcmRzLnBhZ2UpO1xyXG4gICAgdmFyIGNsaWVudCA9IGV4dGVuZCh7fSwgY29vcmRzLmNsaWVudCk7XHJcblxyXG4gICAgcGFnZS54IC09IG9yaWdpbi54O1xyXG4gICAgcGFnZS55IC09IG9yaWdpbi55O1xyXG5cclxuICAgIGNsaWVudC54IC09IG9yaWdpbi54O1xyXG4gICAgY2xpZW50LnkgLT0gb3JpZ2luLnk7XHJcblxyXG4gICAgdGhpcy5jdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcclxuICAgIHRoaXMuYWx0S2V5ID0gZXZlbnQuYWx0S2V5O1xyXG4gICAgdGhpcy5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xyXG4gICAgdGhpcy5tZXRhS2V5ID0gZXZlbnQubWV0YUtleTtcclxuICAgIHRoaXMuYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgdGhpcy5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcclxuICAgIHRoaXMudGFyZ2V0ID0gZWxlbWVudDtcclxuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkIHx8IG51bGw7XHJcbiAgICB0aGlzLnByZUVuZCA9IHByZUVuZDtcclxuICAgIHRoaXMudHlwZSA9IGFjdGlvbiArIChwaGFzZSB8fCAnJyk7XHJcbiAgICB0aGlzLmludGVyYWN0aW9uID0gaW50ZXJhY3Rpb247XHJcbiAgICB0aGlzLmludGVyYWN0YWJsZSA9IHRhcmdldDtcclxuXHJcbiAgICB0aGlzLnQwID0gc3RhcnRpbmcgPyBpbnRlcmFjdGlvbi5kb3duVGltZXNbaW50ZXJhY3Rpb24uZG93blRpbWVzLmxlbmd0aCAtIDFdIDogcHJldkV2ZW50LnQwO1xyXG5cclxuICAgIHZhciBzaWduYWxBcmcgPSB7XHJcbiAgICAgIGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbixcclxuICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICBhY3Rpb246IGFjdGlvbixcclxuICAgICAgcGhhc2U6IHBoYXNlLFxyXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICByZWxhdGVkOiByZWxhdGVkLFxyXG4gICAgICBwYWdlOiBwYWdlLFxyXG4gICAgICBjbGllbnQ6IGNsaWVudCxcclxuICAgICAgY29vcmRzOiBjb29yZHMsXHJcbiAgICAgIHN0YXJ0aW5nOiBzdGFydGluZyxcclxuICAgICAgZW5kaW5nOiBlbmRpbmcsXHJcbiAgICAgIGRlbHRhU291cmNlOiBkZWx0YVNvdXJjZSxcclxuICAgICAgaUV2ZW50OiB0aGlzXHJcbiAgICB9O1xyXG5cclxuICAgIHNpZ25hbHMuZmlyZSgnc2V0LXh5Jywgc2lnbmFsQXJnKTtcclxuXHJcbiAgICBpZiAoZW5kaW5nKSB7XHJcbiAgICAgIC8vIHVzZSBwcmV2aW91cyBjb29yZHMgd2hlbiBlbmRpbmdcclxuICAgICAgdGhpcy5wYWdlWCA9IHByZXZFdmVudC5wYWdlWDtcclxuICAgICAgdGhpcy5wYWdlWSA9IHByZXZFdmVudC5wYWdlWTtcclxuICAgICAgdGhpcy5jbGllbnRYID0gcHJldkV2ZW50LmNsaWVudFg7XHJcbiAgICAgIHRoaXMuY2xpZW50WSA9IHByZXZFdmVudC5jbGllbnRZO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wYWdlWCA9IHBhZ2UueDtcclxuICAgICAgdGhpcy5wYWdlWSA9IHBhZ2UueTtcclxuICAgICAgdGhpcy5jbGllbnRYID0gY2xpZW50Lng7XHJcbiAgICAgIHRoaXMuY2xpZW50WSA9IGNsaWVudC55O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMueDAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnggLSBvcmlnaW4ueDtcclxuICAgIHRoaXMueTAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnkgLSBvcmlnaW4ueTtcclxuICAgIHRoaXMuY2xpZW50WDAgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueCAtIG9yaWdpbi54O1xyXG4gICAgdGhpcy5jbGllbnRZMCA9IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLmNsaWVudC55IC0gb3JpZ2luLnk7XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCdzZXQtZGVsdGEnLCBzaWduYWxBcmcpO1xyXG5cclxuICAgIHRoaXMudGltZVN0YW1wID0gY29vcmRzLnRpbWVTdGFtcDtcclxuICAgIHRoaXMuZHQgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEudGltZVN0YW1wO1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMudGltZVN0YW1wIC0gdGhpcy50MDtcclxuXHJcbiAgICAvLyBzcGVlZCBhbmQgdmVsb2NpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmRcclxuICAgIHRoaXMuc3BlZWQgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGFbZGVsdGFTb3VyY2VdLnNwZWVkO1xyXG4gICAgdGhpcy52ZWxvY2l0eVggPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGFbZGVsdGFTb3VyY2VdLnZ4O1xyXG4gICAgdGhpcy52ZWxvY2l0eVkgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGFbZGVsdGFTb3VyY2VdLnZ5O1xyXG5cclxuICAgIHRoaXMuc3dpcGUgPSBlbmRpbmcgfHwgcGhhc2UgPT09ICdpbmVydGlhc3RhcnQnID8gdGhpcy5nZXRTd2lwZSgpIDogbnVsbDtcclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ25ldycsIHNpZ25hbEFyZyk7XHJcbiAgfVxyXG5cclxuICBJbnRlcmFjdEV2ZW50LnByb3RvdHlwZS5nZXRTd2lwZSA9IGZ1bmN0aW9uIGdldFN3aXBlKCkge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gdGhpcy5pbnRlcmFjdGlvbjtcclxuXHJcbiAgICBpZiAoaW50ZXJhY3Rpb24ucHJldkV2ZW50LnNwZWVkIDwgNjAwIHx8IHRoaXMudGltZVN0YW1wIC0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LnRpbWVTdGFtcCA+IDE1MCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKGludGVyYWN0aW9uLnByZXZFdmVudC52ZWxvY2l0eVksIGludGVyYWN0aW9uLnByZXZFdmVudC52ZWxvY2l0eVgpIC8gTWF0aC5QSTtcclxuICAgIHZhciBvdmVybGFwID0gMjIuNTtcclxuXHJcbiAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgIGFuZ2xlICs9IDM2MDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGVmdCA9IDEzNSAtIG92ZXJsYXAgPD0gYW5nbGUgJiYgYW5nbGUgPCAyMjUgKyBvdmVybGFwO1xyXG4gICAgdmFyIHVwID0gMjI1IC0gb3ZlcmxhcCA8PSBhbmdsZSAmJiBhbmdsZSA8IDMxNSArIG92ZXJsYXA7XHJcblxyXG4gICAgdmFyIHJpZ2h0ID0gIWxlZnQgJiYgKDMxNSAtIG92ZXJsYXAgPD0gYW5nbGUgfHwgYW5nbGUgPCA0NSArIG92ZXJsYXApO1xyXG4gICAgdmFyIGRvd24gPSAhdXAgJiYgNDUgLSBvdmVybGFwIDw9IGFuZ2xlICYmIGFuZ2xlIDwgMTM1ICsgb3ZlcmxhcDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cDogdXAsXHJcbiAgICAgIGRvd246IGRvd24sXHJcbiAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgIHJpZ2h0OiByaWdodCxcclxuICAgICAgYW5nbGU6IGFuZ2xlLFxyXG4gICAgICBzcGVlZDogaW50ZXJhY3Rpb24ucHJldkV2ZW50LnNwZWVkLFxyXG4gICAgICB2ZWxvY2l0eToge1xyXG4gICAgICAgIHg6IGludGVyYWN0aW9uLnByZXZFdmVudC52ZWxvY2l0eVgsXHJcbiAgICAgICAgeTogaW50ZXJhY3Rpb24ucHJldkV2ZW50LnZlbG9jaXR5WVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0RXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7fTtcclxuXHJcbiAgSW50ZXJhY3RFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xyXG4gICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgSW50ZXJhY3RFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBJbnRlcmFjdEV2ZW50O1xyXG59KCk7XHJcblxyXG5zaWduYWxzLm9uKCdzZXQtZGVsdGEnLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gIHZhciBpRXZlbnQgPSBfcmVmLmlFdmVudCxcclxuICAgICAgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBzdGFydGluZyA9IF9yZWYuc3RhcnRpbmcsXHJcbiAgICAgIGRlbHRhU291cmNlID0gX3JlZi5kZWx0YVNvdXJjZTtcclxuXHJcbiAgdmFyIHByZXZFdmVudCA9IHN0YXJ0aW5nID8gaUV2ZW50IDogaW50ZXJhY3Rpb24ucHJldkV2ZW50O1xyXG5cclxuICBpZiAoZGVsdGFTb3VyY2UgPT09ICdjbGllbnQnKSB7XHJcbiAgICBpRXZlbnQuZHggPSBpRXZlbnQuY2xpZW50WCAtIHByZXZFdmVudC5jbGllbnRYO1xyXG4gICAgaUV2ZW50LmR5ID0gaUV2ZW50LmNsaWVudFkgLSBwcmV2RXZlbnQuY2xpZW50WTtcclxuICB9IGVsc2Uge1xyXG4gICAgaUV2ZW50LmR4ID0gaUV2ZW50LnBhZ2VYIC0gcHJldkV2ZW50LnBhZ2VYO1xyXG4gICAgaUV2ZW50LmR5ID0gaUV2ZW50LnBhZ2VZIC0gcHJldkV2ZW50LnBhZ2VZO1xyXG4gIH1cclxufSk7XHJcblxyXG5JbnRlcmFjdEV2ZW50LnNpZ25hbHMgPSBzaWduYWxzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdEV2ZW50O1xyXG5cclxufSx7XCIuL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuL3V0aWxzL1NpZ25hbHNcIjozNSxcIi4vdXRpbHMvZXh0ZW5kXCI6NDEsXCIuL3V0aWxzL2dldE9yaWdpblhZXCI6NDJ9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBpcyA9IHJlcXVpcmUoJy4vdXRpbHMvaXMnKTtcclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnRzJyk7XHJcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzL2V4dGVuZCcpO1xyXG52YXIgYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9iYXNlJyk7XHJcbnZhciBzY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUnKTtcclxudmFyIEV2ZW50YWJsZSA9IHJlcXVpcmUoJy4vRXZlbnRhYmxlJyk7XHJcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdE9wdGlvbnMnKTtcclxudmFyIHNpZ25hbHMgPSByZXF1aXJlKCcuL3V0aWxzL1NpZ25hbHMnKS5uZXcoKTtcclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvZG9tVXRpbHMnKSxcclxuICAgIGdldEVsZW1lbnRSZWN0ID0gX3JlcXVpcmUuZ2V0RWxlbWVudFJlY3QsXHJcbiAgICBub2RlQ29udGFpbnMgPSBfcmVxdWlyZS5ub2RlQ29udGFpbnMsXHJcbiAgICB0cnlTZWxlY3RvciA9IF9yZXF1aXJlLnRyeVNlbGVjdG9yO1xyXG5cclxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vdXRpbHMvd2luZG93JyksXHJcbiAgICBnZXRXaW5kb3cgPSBfcmVxdWlyZTIuZ2V0V2luZG93O1xyXG5cclxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoJy4vdXRpbHMvYXJyJyksXHJcbiAgICBpbmRleE9mID0gX3JlcXVpcmUzLmluZGV4T2YsXHJcbiAgICBjb250YWlucyA9IF9yZXF1aXJlMy5jb250YWlucztcclxuXHJcbnZhciBfcmVxdWlyZTQgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKSxcclxuICAgIHdoZWVsRXZlbnQgPSBfcmVxdWlyZTQud2hlZWxFdmVudDtcclxuXHJcbi8vIGFsbCBzZXQgaW50ZXJhY3RhYmxlc1xyXG5cclxuXHJcbnNjb3BlLmludGVyYWN0YWJsZXMgPSBbXTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlXHJcbiBbIHByb3BlcnR5IF1cclxuICoqXHJcbiAqIE9iamVjdCB0eXBlIHJldHVybmVkIGJ5IEBpbnRlcmFjdFxyXG5cXCovXHJcblxyXG52YXIgSW50ZXJhY3RhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIEludGVyYWN0YWJsZSh0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGFibGUpO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRhYmxlKCk7XHJcbiAgICB0aGlzLl9jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHNjb3BlLmRvY3VtZW50O1xyXG4gICAgdGhpcy5fd2luID0gZ2V0V2luZG93KHRyeVNlbGVjdG9yKHRhcmdldCkgPyB0aGlzLl9jb250ZXh0IDogdGFyZ2V0KTtcclxuICAgIHRoaXMuX2RvYyA9IHRoaXMuX3dpbi5kb2N1bWVudDtcclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ25ldycsIHtcclxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgIGludGVyYWN0YWJsZTogdGhpcyxcclxuICAgICAgd2luOiB0aGlzLl93aW5cclxuICAgIH0pO1xyXG5cclxuICAgIHNjb3BlLmFkZERvY3VtZW50KHRoaXMuX2RvYywgdGhpcy5fd2luKTtcclxuXHJcbiAgICBzY29wZS5pbnRlcmFjdGFibGVzLnB1c2godGhpcyk7XHJcblxyXG4gICAgdGhpcy5zZXQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnNldE9uRXZlbnRzID0gZnVuY3Rpb24gc2V0T25FdmVudHMoYWN0aW9uLCBwaGFzZXMpIHtcclxuICAgIHZhciBvbkFjdGlvbiA9ICdvbicgKyBhY3Rpb247XHJcblxyXG4gICAgaWYgKGlzLmZ1bmN0aW9uKHBoYXNlcy5vbnN0YXJ0KSkge1xyXG4gICAgICB0aGlzLmV2ZW50c1tvbkFjdGlvbiArICdzdGFydCddID0gcGhhc2VzLm9uc3RhcnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXMuZnVuY3Rpb24ocGhhc2VzLm9ubW92ZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHNbb25BY3Rpb24gKyAnbW92ZSddID0gcGhhc2VzLm9ubW92ZTtcclxuICAgIH1cclxuICAgIGlmIChpcy5mdW5jdGlvbihwaGFzZXMub25lbmQpKSB7XHJcbiAgICAgIHRoaXMuZXZlbnRzW29uQWN0aW9uICsgJ2VuZCddID0gcGhhc2VzLm9uZW5kO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzLmZ1bmN0aW9uKHBoYXNlcy5vbmluZXJ0aWFzdGFydCkpIHtcclxuICAgICAgdGhpcy5ldmVudHNbb25BY3Rpb24gKyAnaW5lcnRpYXN0YXJ0J10gPSBwaGFzZXMub25pbmVydGlhc3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5zZXRQZXJBY3Rpb24gPSBmdW5jdGlvbiBzZXRQZXJBY3Rpb24oYWN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAvLyBmb3IgYWxsIHRoZSBkZWZhdWx0IHBlci1hY3Rpb24gb3B0aW9uc1xyXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcclxuICAgICAgLy8gaWYgdGhpcyBvcHRpb24gZXhpc3RzIGZvciB0aGlzIGFjdGlvblxyXG4gICAgICBpZiAob3B0aW9uIGluIGRlZmF1bHRzW2FjdGlvbl0pIHtcclxuICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIGluIHRoZSBvcHRpb25zIGFyZyBpcyBhbiBvYmplY3QgdmFsdWVcclxuICAgICAgICBpZiAoaXMub2JqZWN0KG9wdGlvbnNbb3B0aW9uXSkpIHtcclxuICAgICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgb2JqZWN0XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXVtvcHRpb25dID0gZXh0ZW5kKHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbl0gfHwge30sIG9wdGlvbnNbb3B0aW9uXSk7XHJcblxyXG4gICAgICAgICAgaWYgKGlzLm9iamVjdChkZWZhdWx0cy5wZXJBY3Rpb25bb3B0aW9uXSkgJiYgJ2VuYWJsZWQnIGluIGRlZmF1bHRzLnBlckFjdGlvbltvcHRpb25dKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbl0uZW5hYmxlZCA9IG9wdGlvbnNbb3B0aW9uXS5lbmFibGVkID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGlzLmJvb2wob3B0aW9uc1tvcHRpb25dKSAmJiBpcy5vYmplY3QoZGVmYXVsdHMucGVyQWN0aW9uW29wdGlvbl0pKSB7XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnNbYWN0aW9uXVtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgLy8gb3IgaWYgaXQncyBub3QgdW5kZWZpbmVkLCBkbyBhIHBsYWluIGFzc2lnbm1lbnRcclxuICAgICAgICAgIHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLypcXFxyXG4gICAqIEludGVyYWN0YWJsZS5nZXRSZWN0XHJcbiAgIFsgbWV0aG9kIF1cclxuICAgKlxyXG4gICAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIGdldCBhbiBJbnRlcmFjdGFibGVzIGJvdW5kaW5nIHJlY3QuIENhbiBiZVxyXG4gICAqIG92ZXJyaWRkZW4gdXNpbmcgQEludGVyYWN0YWJsZS5yZWN0Q2hlY2tlci5cclxuICAgKlxyXG4gICAtIGVsZW1lbnQgKEVsZW1lbnQpICNvcHRpb25hbCBUaGUgZWxlbWVudCB0byBtZWFzdXJlLlxyXG4gICA9IChvYmplY3QpIFRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUuXHJcbiAgIG8ge1xyXG4gICBvICAgICB0b3AgICA6IDAsXHJcbiAgIG8gICAgIGxlZnQgIDogMCxcclxuICAgbyAgICAgYm90dG9tOiAwLFxyXG4gICBvICAgICByaWdodCA6IDAsXHJcbiAgIG8gICAgIHdpZHRoIDogMCxcclxuICAgbyAgICAgaGVpZ2h0OiAwXHJcbiAgIG8gfVxyXG4gIFxcKi9cclxuXHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uIGdldFJlY3QoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgaWYgKGlzLnN0cmluZyh0aGlzLnRhcmdldCkgJiYgIWlzLmVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgZWxlbWVudCA9IHRoaXMuX2NvbnRleHQucXVlcnlTZWxlY3Rvcih0aGlzLnRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdldEVsZW1lbnRSZWN0KGVsZW1lbnQpO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUucmVjdENoZWNrZXJcclxuICAgWyBtZXRob2QgXVxyXG4gICAqXHJcbiAgICogUmV0dXJucyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW50ZXJhY3RhYmxlJ3NcclxuICAgKiBlbGVtZW50J3MgcmVjdGFuZ2xlXHJcbiAgICpcclxuICAgLSBjaGVja2VyIChmdW5jdGlvbikgI29wdGlvbmFsIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGlzIEludGVyYWN0YWJsZSdzIGJvdW5kaW5nIHJlY3RhbmdsZS4gU2VlIEBJbnRlcmFjdGFibGUuZ2V0UmVjdFxyXG4gICA9IChmdW5jdGlvbiB8IG9iamVjdCkgVGhlIGNoZWNrZXIgZnVuY3Rpb24gb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICBcXCovXHJcblxyXG5cclxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnJlY3RDaGVja2VyID0gZnVuY3Rpb24gcmVjdENoZWNrZXIoY2hlY2tlcikge1xyXG4gICAgaWYgKGlzLmZ1bmN0aW9uKGNoZWNrZXIpKSB7XHJcbiAgICAgIHRoaXMuZ2V0UmVjdCA9IGNoZWNrZXI7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hlY2tlciA9PT0gbnVsbCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmdldFJlY3Q7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0O1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUuX2JhY2tDb21wYXRPcHRpb24gPSBmdW5jdGlvbiBfYmFja0NvbXBhdE9wdGlvbihvcHRpb25OYW1lLCBuZXdWYWx1ZSkge1xyXG4gICAgaWYgKHRyeVNlbGVjdG9yKG5ld1ZhbHVlKSB8fCBpcy5vYmplY3QobmV3VmFsdWUpKSB7XHJcbiAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25OYW1lXSA9IG5ld1ZhbHVlO1xyXG5cclxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gYWN0aW9ucy5uYW1lcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjtcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWN0aW9uID0gX3JlZjtcclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zW2FjdGlvbl1bb3B0aW9uTmFtZV0gPSBuZXdWYWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc1tvcHRpb25OYW1lXTtcclxuICB9O1xyXG5cclxuICAvKlxcXHJcbiAgICogSW50ZXJhY3RhYmxlLm9yaWdpblxyXG4gICBbIG1ldGhvZCBdXHJcbiAgICpcclxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG9yaWdpbiBvZiB0aGUgSW50ZXJhY3RhYmxlJ3MgZWxlbWVudC4gIFRoZSB4IGFuZCB5XHJcbiAgICogb2YgdGhlIG9yaWdpbiB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSBhY3Rpb24gZXZlbnQgY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgLSBvcmlnaW4gKG9iamVjdCB8IHN0cmluZykgI29wdGlvbmFsIEFuIG9iamVjdCBlZy4geyB4OiAwLCB5OiAwIH0gb3Igc3RyaW5nICdwYXJlbnQnLCAnc2VsZicgb3IgYW55IENTUyBzZWxlY3RvclxyXG4gICAqIE9SXHJcbiAgIC0gb3JpZ2luIChFbGVtZW50KSAjb3B0aW9uYWwgQW4gSFRNTCBvciBTVkcgRWxlbWVudCB3aG9zZSByZWN0IHdpbGwgYmUgdXNlZFxyXG4gICAqKlxyXG4gICA9IChvYmplY3QpIFRoZSBjdXJyZW50IG9yaWdpbiBvciB0aGlzIEludGVyYWN0YWJsZVxyXG4gIFxcKi9cclxuXHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUub3JpZ2luID0gZnVuY3Rpb24gb3JpZ2luKG5ld1ZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbignb3JpZ2luJywgbmV3VmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUuZGVsdGFTb3VyY2VcclxuICAgWyBtZXRob2QgXVxyXG4gICAqXHJcbiAgICogUmV0dXJucyBvciBzZXRzIHRoZSBtb3VzZSBjb29yZGluYXRlIHR5cGVzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxyXG4gICAqIG1vdmVtZW50IG9mIHRoZSBwb2ludGVyLlxyXG4gICAqXHJcbiAgIC0gbmV3VmFsdWUgKHN0cmluZykgI29wdGlvbmFsIFVzZSAnY2xpZW50JyBpZiB5b3Ugd2lsbCBiZSBzY3JvbGxpbmcgd2hpbGUgaW50ZXJhY3Rpbmc7IFVzZSAncGFnZScgaWYgeW91IHdhbnQgYXV0b1Njcm9sbCB0byB3b3JrXHJcbiAgID0gKHN0cmluZyB8IG9iamVjdCkgVGhlIGN1cnJlbnQgZGVsdGFTb3VyY2Ugb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICBcXCovXHJcblxyXG5cclxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLmRlbHRhU291cmNlID0gZnVuY3Rpb24gZGVsdGFTb3VyY2UobmV3VmFsdWUpIHtcclxuICAgIGlmIChuZXdWYWx1ZSA9PT0gJ3BhZ2UnIHx8IG5ld1ZhbHVlID09PSAnY2xpZW50Jykge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2UgPSBuZXdWYWx1ZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2U7XHJcbiAgfTtcclxuXHJcbiAgLypcXFxyXG4gICAqIEludGVyYWN0YWJsZS5jb250ZXh0XHJcbiAgIFsgbWV0aG9kIF1cclxuICAgKlxyXG4gICAqIEdldHMgdGhlIHNlbGVjdG9yIGNvbnRleHQgTm9kZSBvZiB0aGUgSW50ZXJhY3RhYmxlLiBUaGUgZGVmYXVsdCBpcyBgd2luZG93LmRvY3VtZW50YC5cclxuICAgKlxyXG4gICA9IChOb2RlKSBUaGUgY29udGV4dCBOb2RlIG9mIHRoaXMgSW50ZXJhY3RhYmxlXHJcbiAgICoqXHJcbiAgXFwqL1xyXG5cclxuXHJcbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24gY29udGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUuaW5Db250ZXh0ID0gZnVuY3Rpb24gaW5Db250ZXh0KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0ID09PSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgbm9kZUNvbnRhaW5zKHRoaXMuX2NvbnRleHQsIGVsZW1lbnQpO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUuZmlyZVxyXG4gICBbIG1ldGhvZCBdXHJcbiAgICpcclxuICAgKiBDYWxscyBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBJbnRlcmFjdEV2ZW50IHR5cGUgYm91bmQgZ2xvYmFsbHlcclxuICAgKiBhbmQgZGlyZWN0bHkgdG8gdGhpcyBJbnRlcmFjdGFibGVcclxuICAgKlxyXG4gICAtIGlFdmVudCAoSW50ZXJhY3RFdmVudCkgVGhlIEludGVyYWN0RXZlbnQgb2JqZWN0IHRvIGJlIGZpcmVkIG9uIHRoaXMgSW50ZXJhY3RhYmxlXHJcbiAgID0gKEludGVyYWN0YWJsZSkgdGhpcyBJbnRlcmFjdGFibGVcclxuICBcXCovXHJcblxyXG5cclxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiBmaXJlKGlFdmVudCkge1xyXG4gICAgdGhpcy5ldmVudHMuZmlyZShpRXZlbnQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUuX29uT2ZmTXVsdGlwbGUgPSBmdW5jdGlvbiBfb25PZmZNdWx0aXBsZShtZXRob2QsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcclxuICAgIGlmIChpcy5zdHJpbmcoZXZlbnRUeXBlKSAmJiBldmVudFR5cGUuc2VhcmNoKCcgJykgIT09IC0xKSB7XHJcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZS50cmltKCkuc3BsaXQoLyArLyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzLmFycmF5KGV2ZW50VHlwZSkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudFR5cGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzW21ldGhvZF0oZXZlbnRUeXBlW2ldLCBsaXN0ZW5lciwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpcy5vYmplY3QoZXZlbnRUeXBlKSkge1xyXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXNbbWV0aG9kXShwcm9wLCBldmVudFR5cGVbcHJvcF0sIGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLypcXFxyXG4gICAqIEludGVyYWN0YWJsZS5vblxyXG4gICBbIG1ldGhvZCBdXHJcbiAgICpcclxuICAgKiBCaW5kcyBhIGxpc3RlbmVyIGZvciBhbiBJbnRlcmFjdEV2ZW50LCBwb2ludGVyRXZlbnQgb3IgRE9NIGV2ZW50LlxyXG4gICAqXHJcbiAgIC0gZXZlbnRUeXBlICAoc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QpIFRoZSB0eXBlcyBvZiBldmVudHMgdG8gbGlzdGVuIGZvclxyXG4gICAtIGxpc3RlbmVyICAgKGZ1bmN0aW9uKSBUaGUgZnVuY3Rpb24gZXZlbnQgKHMpXHJcbiAgIC0gb3B0aW9ucyAgICAob2JqZWN0IHwgYm9vbGVhbikgI29wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IG9yIHVzZUNhcHR1cmUgZmxhZyBmb3IgYWRkRXZlbnRMaXN0ZW5lclxyXG4gICA9IChvYmplY3QpIFRoaXMgSW50ZXJhY3RhYmxlXHJcbiAgXFwqL1xyXG5cclxuXHJcbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0aGlzLl9vbk9mZk11bHRpcGxlKCdvbicsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChldmVudFR5cGUgPT09ICd3aGVlbCcpIHtcclxuICAgICAgZXZlbnRUeXBlID0gd2hlZWxFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29udGFpbnMoSW50ZXJhY3RhYmxlLmV2ZW50VHlwZXMsIGV2ZW50VHlwZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvLyBkZWxlZ2F0ZWQgZXZlbnQgZm9yIHNlbGVjdG9yXHJcbiAgICBlbHNlIGlmIChpcy5zdHJpbmcodGhpcy50YXJnZXQpKSB7XHJcbiAgICAgICAgZXZlbnRzLmFkZERlbGVnYXRlKHRoaXMudGFyZ2V0LCB0aGlzLl9jb250ZXh0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBldmVudHMuYWRkKHRoaXMudGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUub2ZmXHJcbiAgIFsgbWV0aG9kIF1cclxuICAgKlxyXG4gICAqIFJlbW92ZXMgYW4gSW50ZXJhY3RFdmVudCwgcG9pbnRlckV2ZW50IG9yIERPTSBldmVudCBsaXN0ZW5lclxyXG4gICAqXHJcbiAgIC0gZXZlbnRUeXBlICAoc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QpIFRoZSB0eXBlcyBvZiBldmVudHMgdGhhdCB3ZXJlIGxpc3RlbmVkIGZvclxyXG4gICAtIGxpc3RlbmVyICAgKGZ1bmN0aW9uKSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxyXG4gICAtIG9wdGlvbnMgICAgKG9iamVjdCB8IGJvb2xlYW4pICNvcHRpb25hbCBvcHRpb25zIG9iamVjdCBvciB1c2VDYXB0dXJlIGZsYWcgZm9yIHJlbW92ZUV2ZW50TGlzdGVuZXJcclxuICAgPSAob2JqZWN0KSBUaGlzIEludGVyYWN0YWJsZVxyXG4gIFxcKi9cclxuXHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0aGlzLl9vbk9mZk11bHRpcGxlKCdvZmYnLCBldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXZlbnRUeXBlID09PSAnd2hlZWwnKSB7XHJcbiAgICAgIGV2ZW50VHlwZSA9IHdoZWVsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgaXQgaXMgYW4gYWN0aW9uIGV2ZW50IHR5cGVcclxuICAgIGlmIChjb250YWlucyhJbnRlcmFjdGFibGUuZXZlbnRUeXBlcywgZXZlbnRUeXBlKSkge1xyXG4gICAgICB0aGlzLmV2ZW50cy5vZmYoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvLyBkZWxlZ2F0ZWQgZXZlbnRcclxuICAgIGVsc2UgaWYgKGlzLnN0cmluZyh0aGlzLnRhcmdldCkpIHtcclxuICAgICAgICBldmVudHMucmVtb3ZlRGVsZWdhdGUodGhpcy50YXJnZXQsIHRoaXMuX2NvbnRleHQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBmcm9tIHRoaXMgSW50ZXJhdGFibGUncyBlbGVtZW50XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZXZlbnRzLnJlbW92ZSh0aGlzLnRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUuc2V0XHJcbiAgIFsgbWV0aG9kIF1cclxuICAgKlxyXG4gICAqIFJlc2V0IHRoZSBvcHRpb25zIG9mIHRoaXMgSW50ZXJhY3RhYmxlXHJcbiAgIC0gb3B0aW9ucyAob2JqZWN0KSBUaGUgbmV3IHNldHRpbmdzIHRvIGFwcGx5XHJcbiAgID0gKG9iamVjdCkgVGhpcyBJbnRlcmFjdGFibGVcclxuICBcXCovXHJcblxyXG5cclxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XHJcbiAgICBpZiAoIWlzLm9iamVjdChvcHRpb25zKSkge1xyXG4gICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cy5iYXNlKTtcclxuXHJcbiAgICB2YXIgcGVyQWN0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMucGVyQWN0aW9uKTtcclxuXHJcbiAgICBmb3IgKHZhciBhY3Rpb25OYW1lIGluIGFjdGlvbnMubWV0aG9kRGljdCkge1xyXG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGFjdGlvbnMubWV0aG9kRGljdFthY3Rpb25OYW1lXTtcclxuXHJcbiAgICAgIHRoaXMub3B0aW9uc1thY3Rpb25OYW1lXSA9IGV4dGVuZCh7fSwgZGVmYXVsdHNbYWN0aW9uTmFtZV0pO1xyXG5cclxuICAgICAgdGhpcy5zZXRQZXJBY3Rpb24oYWN0aW9uTmFtZSwgcGVyQWN0aW9ucyk7XHJcblxyXG4gICAgICB0aGlzW21ldGhvZE5hbWVdKG9wdGlvbnNbYWN0aW9uTmFtZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBJbnRlcmFjdGFibGUuc2V0dGluZ3NNZXRob2RzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWYyO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5Mikge1xyXG4gICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNldHRpbmcgPSBfcmVmMjtcclxuXHJcbiAgICAgIHRoaXMub3B0aW9uc1tzZXR0aW5nXSA9IGRlZmF1bHRzLmJhc2Vbc2V0dGluZ107XHJcblxyXG4gICAgICBpZiAoc2V0dGluZyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpc1tzZXR0aW5nXShvcHRpb25zW3NldHRpbmddKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNpZ25hbHMuZmlyZSgnc2V0Jywge1xyXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICBpbnRlcmFjdGFibGU6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qXFxcclxuICAgKiBJbnRlcmFjdGFibGUudW5zZXRcclxuICAgWyBtZXRob2QgXVxyXG4gICAqXHJcbiAgICogUmVtb3ZlIHRoaXMgaW50ZXJhY3RhYmxlIGZyb20gdGhlIGxpc3Qgb2YgaW50ZXJhY3RhYmxlcyBhbmQgcmVtb3ZlXHJcbiAgICogaXQncyBhY3Rpb24gY2FwYWJpbGl0aWVzIGFuZCBldmVudCBsaXN0ZW5lcnNcclxuICAgKlxyXG4gICA9IChvYmplY3QpIEBpbnRlcmFjdFxyXG4gIFxcKi9cclxuXHJcblxyXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiB1bnNldCgpIHtcclxuICAgIGV2ZW50cy5yZW1vdmUodGhpcy50YXJnZXQsICdhbGwnKTtcclxuXHJcbiAgICBpZiAoaXMuc3RyaW5nKHRoaXMudGFyZ2V0KSkge1xyXG4gICAgICAvLyByZW1vdmUgZGVsZWdhdGVkIGV2ZW50c1xyXG4gICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cy5kZWxlZ2F0ZWRFdmVudHMpIHtcclxuICAgICAgICB2YXIgZGVsZWdhdGVkID0gZXZlbnRzLmRlbGVnYXRlZEV2ZW50c1t0eXBlXTtcclxuXHJcbiAgICAgICAgaWYgKGRlbGVnYXRlZC5zZWxlY3RvcnNbMF0gPT09IHRoaXMudGFyZ2V0ICYmIGRlbGVnYXRlZC5jb250ZXh0c1swXSA9PT0gdGhpcy5fY29udGV4dCkge1xyXG5cclxuICAgICAgICAgIGRlbGVnYXRlZC5zZWxlY3RvcnMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgICAgZGVsZWdhdGVkLmNvbnRleHRzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgIGRlbGVnYXRlZC5saXN0ZW5lcnMuc3BsaWNlKDAsIDEpO1xyXG5cclxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYXJyYXlzIGlmIHRoZXkgYXJlIGVtcHR5XHJcbiAgICAgICAgICBpZiAoIWRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlZFt0eXBlXSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBldmVudHMucmVtb3ZlKHRoaXMuX2NvbnRleHQsIHR5cGUsIGV2ZW50cy5kZWxlZ2F0ZUxpc3RlbmVyKTtcclxuICAgICAgICBldmVudHMucmVtb3ZlKHRoaXMuX2NvbnRleHQsIHR5cGUsIGV2ZW50cy5kZWxlZ2F0ZVVzZUNhcHR1cmUsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBldmVudHMucmVtb3ZlKHRoaXMsICdhbGwnKTtcclxuICAgIH1cclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ3Vuc2V0JywgeyBpbnRlcmFjdGFibGU6IHRoaXMgfSk7XHJcblxyXG4gICAgc2NvcGUuaW50ZXJhY3RhYmxlcy5zcGxpY2UoaW5kZXhPZihzY29wZS5pbnRlcmFjdGFibGVzLCB0aGlzKSwgMSk7XHJcblxyXG4gICAgLy8gU3RvcCByZWxhdGVkIGludGVyYWN0aW9ucyB3aGVuIGFuIEludGVyYWN0YWJsZSBpcyB1bnNldFxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHNjb3BlLmludGVyYWN0aW9ucyB8fCBbXSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmMztcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheTMpIHtcclxuICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYzO1xyXG5cclxuICAgICAgaWYgKGludGVyYWN0aW9uLnRhcmdldCA9PT0gdGhpcyAmJiBpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpKSB7XHJcbiAgICAgICAgaW50ZXJhY3Rpb24uc3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNjb3BlLmludGVyYWN0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBJbnRlcmFjdGFibGU7XHJcbn0oKTtcclxuXHJcbnNjb3BlLmludGVyYWN0YWJsZXMuaW5kZXhPZkVsZW1lbnQgPSBmdW5jdGlvbiBpbmRleE9mRWxlbWVudCh0YXJnZXQsIGNvbnRleHQpIHtcclxuICBjb250ZXh0ID0gY29udGV4dCB8fCBzY29wZS5kb2N1bWVudDtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaW50ZXJhY3RhYmxlID0gdGhpc1tpXTtcclxuXHJcbiAgICBpZiAoaW50ZXJhY3RhYmxlLnRhcmdldCA9PT0gdGFyZ2V0ICYmIGludGVyYWN0YWJsZS5fY29udGV4dCA9PT0gY29udGV4dCkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIC0xO1xyXG59O1xyXG5cclxuc2NvcGUuaW50ZXJhY3RhYmxlcy5nZXQgPSBmdW5jdGlvbiBpbnRlcmFjdGFibGVHZXQoZWxlbWVudCwgb3B0aW9ucywgZG9udENoZWNrSW5Db250ZXh0KSB7XHJcbiAgdmFyIHJldCA9IHRoaXNbdGhpcy5pbmRleE9mRWxlbWVudChlbGVtZW50LCBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCldO1xyXG5cclxuICByZXR1cm4gcmV0ICYmIChpcy5zdHJpbmcoZWxlbWVudCkgfHwgZG9udENoZWNrSW5Db250ZXh0IHx8IHJldC5pbkNvbnRleHQoZWxlbWVudCkpID8gcmV0IDogbnVsbDtcclxufTtcclxuXHJcbnNjb3BlLmludGVyYWN0YWJsZXMuZm9yRWFjaFNlbGVjdG9yID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgaW50ZXJhY3RhYmxlID0gdGhpc1tpXTtcclxuXHJcbiAgICAvLyBza2lwIG5vbiBDU1Mgc2VsZWN0b3IgdGFyZ2V0cyBhbmQgb3V0IG9mIGNvbnRleHQgZWxlbWVudHNcclxuICAgIGlmICghaXMuc3RyaW5nKGludGVyYWN0YWJsZS50YXJnZXQpIHx8IGVsZW1lbnQgJiYgIWludGVyYWN0YWJsZS5pbkNvbnRleHQoZWxlbWVudCkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJldCA9IGNhbGxiYWNrKGludGVyYWN0YWJsZSwgaW50ZXJhY3RhYmxlLnRhcmdldCwgaW50ZXJhY3RhYmxlLl9jb250ZXh0LCBpLCB0aGlzKTtcclxuXHJcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBhbGwgaW50ZXJhY3QuanMgZXZlbnRUeXBlc1xyXG5JbnRlcmFjdGFibGUuZXZlbnRUeXBlcyA9IHNjb3BlLmV2ZW50VHlwZXMgPSBbXTtcclxuXHJcbkludGVyYWN0YWJsZS5zaWduYWxzID0gc2lnbmFscztcclxuXHJcbkludGVyYWN0YWJsZS5zZXR0aW5nc01ldGhvZHMgPSBbJ2RlbHRhU291cmNlJywgJ29yaWdpbicsICdwcmV2ZW50RGVmYXVsdCcsICdyZWN0Q2hlY2tlciddO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGFibGU7XHJcblxyXG59LHtcIi4vRXZlbnRhYmxlXCI6MixcIi4vYWN0aW9ucy9iYXNlXCI6NixcIi4vZGVmYXVsdE9wdGlvbnNcIjoxOCxcIi4vc2NvcGVcIjozNCxcIi4vdXRpbHMvU2lnbmFsc1wiOjM1LFwiLi91dGlscy9hcnJcIjozNixcIi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi91dGlscy9kb21VdGlsc1wiOjM5LFwiLi91dGlscy9ldmVudHNcIjo0MCxcIi4vdXRpbHMvZXh0ZW5kXCI6NDEsXCIuL3V0aWxzL2lzXCI6NDYsXCIuL3V0aWxzL3dpbmRvd1wiOjUyfV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgc2NvcGUgPSByZXF1aXJlKCcuL3Njb3BlJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnRzJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJyk7XHJcbnZhciBkb21PYmplY3RzID0gcmVxdWlyZSgnLi91dGlscy9kb21PYmplY3RzJyk7XHJcbnZhciBmaW5kZXIgPSByZXF1aXJlKCcuL3V0aWxzL2ludGVyYWN0aW9uRmluZGVyJyk7XHJcbnZhciBzaWduYWxzID0gcmVxdWlyZSgnLi91dGlscy9TaWduYWxzJykubmV3KCk7XHJcblxyXG52YXIgbGlzdGVuZXJzID0ge307XHJcbnZhciBtZXRob2ROYW1lcyA9IFsncG9pbnRlckRvd24nLCAncG9pbnRlck1vdmUnLCAncG9pbnRlclVwJywgJ3VwZGF0ZVBvaW50ZXInLCAncmVtb3ZlUG9pbnRlciddO1xyXG5cclxuLy8gZm9yIGlnbm9yaW5nIGJyb3dzZXIncyBzaW11bGF0ZWQgbW91c2UgZXZlbnRzXHJcbnZhciBwcmV2VG91Y2hUaW1lID0gMDtcclxuXHJcbi8vIGFsbCBhY3RpdmUgYW5kIGlkbGUgaW50ZXJhY3Rpb25zXHJcbnNjb3BlLmludGVyYWN0aW9ucyA9IFtdO1xyXG5cclxudmFyIEludGVyYWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIEludGVyYWN0aW9uKF9yZWYpIHtcclxuICAgIHZhciBwb2ludGVyVHlwZSA9IF9yZWYucG9pbnRlclR5cGU7XHJcblxyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyYWN0aW9uKTtcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7IC8vIGN1cnJlbnQgaW50ZXJhY3RhYmxlIGJlaW5nIGludGVyYWN0ZWQgd2l0aFxyXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDsgLy8gdGhlIHRhcmdldCBlbGVtZW50IG9mIHRoZSBpbnRlcmFjdGFibGVcclxuXHJcbiAgICB0aGlzLnByZXBhcmVkID0geyAvLyBhY3Rpb24gdGhhdCdzIHJlYWR5IHRvIGJlIGZpcmVkIG9uIG5leHQgbW92ZSBldmVudFxyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBheGlzOiBudWxsLFxyXG4gICAgICBlZGdlczogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGFkZGVkIHBvaW50ZXJzXHJcbiAgICB0aGlzLnBvaW50ZXJzID0gW107XHJcbiAgICB0aGlzLnBvaW50ZXJJZHMgPSBbXTtcclxuICAgIHRoaXMuZG93blRhcmdldHMgPSBbXTtcclxuICAgIHRoaXMuZG93blRpbWVzID0gW107XHJcblxyXG4gICAgLy8gUHJldmlvdXMgbmF0aXZlIHBvaW50ZXIgbW92ZSBldmVudCBjb29yZGluYXRlc1xyXG4gICAgdGhpcy5wcmV2Q29vcmRzID0ge1xyXG4gICAgICBwYWdlOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgY2xpZW50OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgICAgdGltZVN0YW1wOiAwXHJcbiAgICB9O1xyXG4gICAgLy8gY3VycmVudCBuYXRpdmUgcG9pbnRlciBtb3ZlIGV2ZW50IGNvb3JkaW5hdGVzXHJcbiAgICB0aGlzLmN1ckNvb3JkcyA9IHtcclxuICAgICAgcGFnZTogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgIGNsaWVudDogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgIHRpbWVTdGFtcDogMFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdGFydGluZyBJbnRlcmFjdEV2ZW50IHBvaW50ZXIgY29vcmRpbmF0ZXNcclxuICAgIHRoaXMuc3RhcnRDb29yZHMgPSB7XHJcbiAgICAgIHBhZ2U6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICBjbGllbnQ6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICB0aW1lU3RhbXA6IDBcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2hhbmdlIGluIGNvb3JkaW5hdGVzIGFuZCB0aW1lIG9mIHRoZSBwb2ludGVyXHJcbiAgICB0aGlzLnBvaW50ZXJEZWx0YSA9IHtcclxuICAgICAgcGFnZTogeyB4OiAwLCB5OiAwLCB2eDogMCwgdnk6IDAsIHNwZWVkOiAwIH0sXHJcbiAgICAgIGNsaWVudDogeyB4OiAwLCB5OiAwLCB2eDogMCwgdnk6IDAsIHNwZWVkOiAwIH0sXHJcbiAgICAgIHRpbWVTdGFtcDogMFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRvd25FdmVudCA9IG51bGw7IC8vIHBvaW50ZXJkb3duL21vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50XHJcbiAgICB0aGlzLmRvd25Qb2ludGVyID0ge307XHJcblxyXG4gICAgdGhpcy5fZXZlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgdGhpcy5fY3VyRXZlbnRUYXJnZXQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDsgLy8gcHJldmlvdXMgYWN0aW9uIGV2ZW50XHJcblxyXG4gICAgdGhpcy5wb2ludGVySXNEb3duID0gZmFsc2U7XHJcbiAgICB0aGlzLnBvaW50ZXJXYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCduZXcnLCB0aGlzKTtcclxuXHJcbiAgICBzY29wZS5pbnRlcmFjdGlvbnMucHVzaCh0aGlzKTtcclxuICB9XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5wb2ludGVyRG93biA9IGZ1bmN0aW9uIHBvaW50ZXJEb3duKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCkge1xyXG4gICAgdmFyIHBvaW50ZXJJbmRleCA9IHRoaXMudXBkYXRlUG9pbnRlcihwb2ludGVyLCBldmVudCwgdHJ1ZSk7XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCdkb3duJywge1xyXG4gICAgICBwb2ludGVyOiBwb2ludGVyLFxyXG4gICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcclxuICAgICAgcG9pbnRlckluZGV4OiBwb2ludGVySW5kZXgsXHJcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKlxcXHJcbiAgICogSW50ZXJhY3Rpb24uc3RhcnRcclxuICAgWyBtZXRob2QgXVxyXG4gICAqXHJcbiAgICogU3RhcnQgYW4gYWN0aW9uIHdpdGggdGhlIGdpdmVuIEludGVyYWN0YWJsZSBhbmQgRWxlbWVudCBhcyB0YXJ0Z2V0cy4gVGhlXHJcbiAgICogYWN0aW9uIG11c3QgYmUgZW5hYmxlZCBmb3IgdGhlIHRhcmdldCBJbnRlcmFjdGFibGUgYW5kIGFuIGFwcHJvcHJpYXRlIG51bWJlclxyXG4gICAqIG9mIHBvaW50ZXJzIG11c3QgYmUgaGVsZCBkb3duIC0gMSBmb3IgZHJhZy9yZXNpemUsIDIgZm9yIGdlc3R1cmUuXHJcbiAgICpcclxuICAgKiBVc2UgaXQgd2l0aCBgaW50ZXJhY3RhYmxlLjxhY3Rpb24+YWJsZSh7IG1hbnVhbFN0YXJ0OiBmYWxzZSB9KWAgdG8gYWx3YXlzXHJcbiAgICogW3N0YXJ0IGFjdGlvbnMgbWFudWFsbHldKGh0dHBzOi8vZ2l0aHViLmNvbS90YXllL2ludGVyYWN0LmpzL2lzc3Vlcy8xMTQpXHJcbiAgICpcclxuICAgLSBhY3Rpb24gIChvYmplY3QpICBUaGUgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCAtIGRyYWcsIHJlc2l6ZSwgZXRjLlxyXG4gICAtIHRhcmdldCAgKEludGVyYWN0YWJsZSkgVGhlIEludGVyYWN0YWJsZSB0byB0YXJnZXRcclxuICAgLSBlbGVtZW50IChFbGVtZW50KSBUaGUgRE9NIEVsZW1lbnQgdG8gdGFyZ2V0XHJcbiAgID0gKG9iamVjdCkgaW50ZXJhY3RcclxuICAgKipcclxuICAgfCBpbnRlcmFjdCh0YXJnZXQpXHJcbiAgIHwgICAuZHJhZ2dhYmxlKHtcclxuICAgfCAgICAgLy8gZGlzYWJsZSB0aGUgZGVmYXVsdCBkcmFnIHN0YXJ0IGJ5IGRvd24tPm1vdmVcclxuICAgfCAgICAgbWFudWFsU3RhcnQ6IHRydWVcclxuICAgfCAgIH0pXHJcbiAgIHwgICAvLyBzdGFydCBkcmFnZ2luZyBhZnRlciB0aGUgdXNlciBob2xkcyB0aGUgcG9pbnRlciBkb3duXHJcbiAgIHwgICAub24oJ2hvbGQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgfCAgICAgdmFyIGludGVyYWN0aW9uID0gZXZlbnQuaW50ZXJhY3Rpb247XHJcbiAgIHxcclxuICAgfCAgICAgaWYgKCFpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpKSB7XHJcbiAgIHwgICAgICAgaW50ZXJhY3Rpb24uc3RhcnQoeyBuYW1lOiAnZHJhZycgfSxcclxuICAgfCAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5pbnRlcmFjdGFibGUsXHJcbiAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgIHwgICAgIH1cclxuICAgfCB9KTtcclxuICAgXFwqL1xyXG5cclxuXHJcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoYWN0aW9uLCB0YXJnZXQsIGVsZW1lbnQpIHtcclxuICAgIGlmICh0aGlzLmludGVyYWN0aW5nKCkgfHwgIXRoaXMucG9pbnRlcklzRG93biB8fCB0aGlzLnBvaW50ZXJJZHMubGVuZ3RoIDwgKGFjdGlvbi5uYW1lID09PSAnZ2VzdHVyZScgPyAyIDogMSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoaXMgaW50ZXJhY3Rpb24gaGFkIGJlZW4gcmVtb3ZlZCBhZnRlciBzdG9wcGluZ1xyXG4gICAgLy8gYWRkIGl0IGJhY2tcclxuICAgIGlmICh1dGlscy5pbmRleE9mKHNjb3BlLmludGVyYWN0aW9ucywgdGhpcykgPT09IC0xKSB7XHJcbiAgICAgIHNjb3BlLmludGVyYWN0aW9ucy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHV0aWxzLmNvcHlBY3Rpb24odGhpcy5wcmVwYXJlZCwgYWN0aW9uKTtcclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ2FjdGlvbi1zdGFydCcsIHtcclxuICAgICAgaW50ZXJhY3Rpb246IHRoaXMsXHJcbiAgICAgIGV2ZW50OiB0aGlzLmRvd25FdmVudFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gcG9pbnRlck1vdmUocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0KSB7XHJcbiAgICBpZiAoIXRoaXMuc2ltdWxhdGlvbikge1xyXG4gICAgICB0aGlzLnVwZGF0ZVBvaW50ZXIocG9pbnRlcik7XHJcbiAgICAgIHV0aWxzLnNldENvb3Jkcyh0aGlzLmN1ckNvb3JkcywgdGhpcy5wb2ludGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGR1cGxpY2F0ZU1vdmUgPSB0aGlzLmN1ckNvb3Jkcy5wYWdlLnggPT09IHRoaXMucHJldkNvb3Jkcy5wYWdlLnggJiYgdGhpcy5jdXJDb29yZHMucGFnZS55ID09PSB0aGlzLnByZXZDb29yZHMucGFnZS55ICYmIHRoaXMuY3VyQ29vcmRzLmNsaWVudC54ID09PSB0aGlzLnByZXZDb29yZHMuY2xpZW50LnggJiYgdGhpcy5jdXJDb29yZHMuY2xpZW50LnkgPT09IHRoaXMucHJldkNvb3Jkcy5jbGllbnQueTtcclxuXHJcbiAgICB2YXIgZHggPSB2b2lkIDA7XHJcbiAgICB2YXIgZHkgPSB2b2lkIDA7XHJcblxyXG4gICAgLy8gcmVnaXN0ZXIgbW92ZW1lbnQgZ3JlYXRlciB0aGFuIHBvaW50ZXJNb3ZlVG9sZXJhbmNlXHJcbiAgICBpZiAodGhpcy5wb2ludGVySXNEb3duICYmICF0aGlzLnBvaW50ZXJXYXNNb3ZlZCkge1xyXG4gICAgICBkeCA9IHRoaXMuY3VyQ29vcmRzLmNsaWVudC54IC0gdGhpcy5zdGFydENvb3Jkcy5jbGllbnQueDtcclxuICAgICAgZHkgPSB0aGlzLmN1ckNvb3Jkcy5jbGllbnQueSAtIHRoaXMuc3RhcnRDb29yZHMuY2xpZW50Lnk7XHJcblxyXG4gICAgICB0aGlzLnBvaW50ZXJXYXNNb3ZlZCA9IHV0aWxzLmh5cG90KGR4LCBkeSkgPiBJbnRlcmFjdGlvbi5wb2ludGVyTW92ZVRvbGVyYW5jZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2lnbmFsQXJnID0ge1xyXG4gICAgICBwb2ludGVyOiBwb2ludGVyLFxyXG4gICAgICBwb2ludGVySW5kZXg6IHRoaXMuZ2V0UG9pbnRlckluZGV4KHBvaW50ZXIpLFxyXG4gICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcclxuICAgICAgZHg6IGR4LFxyXG4gICAgICBkeTogZHksXHJcbiAgICAgIGR1cGxpY2F0ZTogZHVwbGljYXRlTW92ZSxcclxuICAgICAgaW50ZXJhY3Rpb246IHRoaXMsXHJcbiAgICAgIGludGVyYWN0aW5nQmVmb3JlTW92ZTogdGhpcy5pbnRlcmFjdGluZygpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghZHVwbGljYXRlTW92ZSkge1xyXG4gICAgICAvLyBzZXQgcG9pbnRlciBjb29yZGluYXRlLCB0aW1lIGNoYW5nZXMgYW5kIHNwZWVkc1xyXG4gICAgICB1dGlscy5zZXRDb29yZERlbHRhcyh0aGlzLnBvaW50ZXJEZWx0YSwgdGhpcy5wcmV2Q29vcmRzLCB0aGlzLmN1ckNvb3Jkcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCdtb3ZlJywgc2lnbmFsQXJnKTtcclxuXHJcbiAgICBpZiAoIWR1cGxpY2F0ZU1vdmUpIHtcclxuICAgICAgLy8gaWYgaW50ZXJhY3RpbmcsIGZpcmUgYW4gJ2FjdGlvbi1tb3ZlJyBzaWduYWwgZXRjXHJcbiAgICAgIGlmICh0aGlzLmludGVyYWN0aW5nKCkpIHtcclxuICAgICAgICB0aGlzLmRvTW92ZShzaWduYWxBcmcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5wb2ludGVyV2FzTW92ZWQpIHtcclxuICAgICAgICB1dGlscy5jb3B5Q29vcmRzKHRoaXMucHJldkNvb3JkcywgdGhpcy5jdXJDb29yZHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLypcXFxyXG4gICAqIEludGVyYWN0aW9uLmRvTW92ZVxyXG4gICBbIG1ldGhvZCBdXHJcbiAgICpcclxuICAgKiBGb3JjZSBhIG1vdmUgb2YgdGhlIGN1cnJlbnQgYWN0aW9uIGF0IHRoZSBzYW1lIGNvb3JkaW5hdGVzLiBVc2VmdWwgaWZcclxuICAgKiBzbmFwL3Jlc3RyaWN0IGhhcyBiZWVuIGNoYW5nZWQgYW5kIHlvdSB3YW50IGEgbW92ZW1lbnQgd2l0aCB0aGUgbmV3XHJcbiAgICogc2V0dGluZ3MuXHJcbiAgICpcclxuICAgKipcclxuICAgfCBpbnRlcmFjdCh0YXJnZXQpXHJcbiAgIHwgICAuZHJhZ2dhYmxlKHRydWUpXHJcbiAgIHwgICAub24oJ2RyYWdtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgIHwgICAgIGlmIChzb21lQ29uZGl0aW9uKSB7XHJcbiAgIHwgICAgICAgLy8gY2hhbmdlIHRoZSBzbmFwIHNldHRpbmdzXHJcbiAgIHwgICAgICAgZXZlbnQuaW50ZXJhY3RhYmxlLmRyYWdnYWJsZSh7IHNuYXA6IHsgdGFyZ2V0czogW10gfX0pO1xyXG4gICB8ICAgICAgIC8vIGZpcmUgYW5vdGhlciBtb3ZlIGV2ZW50IHdpdGggcmUtY2FsY3VsYXRlZCBzbmFwXHJcbiAgIHwgICAgICAgZXZlbnQuaW50ZXJhY3Rpb24uZG9Nb3ZlKCk7XHJcbiAgIHwgICAgIH1cclxuICAgfCAgIH0pO1xyXG4gICBcXCovXHJcblxyXG5cclxuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZG9Nb3ZlID0gZnVuY3Rpb24gZG9Nb3ZlKHNpZ25hbEFyZykge1xyXG4gICAgc2lnbmFsQXJnID0gdXRpbHMuZXh0ZW5kKHtcclxuICAgICAgcG9pbnRlcjogdGhpcy5wb2ludGVyc1swXSxcclxuICAgICAgZXZlbnQ6IHRoaXMucHJldkV2ZW50LFxyXG4gICAgICBldmVudFRhcmdldDogdGhpcy5fZXZlbnRUYXJnZXQsXHJcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXHJcbiAgICB9LCBzaWduYWxBcmcgfHwge30pO1xyXG5cclxuICAgIHNpZ25hbHMuZmlyZSgnYmVmb3JlLWFjdGlvbi1tb3ZlJywgc2lnbmFsQXJnKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2RvbnRGaXJlTW92ZSkge1xyXG4gICAgICBzaWduYWxzLmZpcmUoJ2FjdGlvbi1tb3ZlJywgc2lnbmFsQXJnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kb250RmlyZU1vdmUgPSBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvLyBFbmQgaW50ZXJhY3QgbW92ZSBldmVudHMgYW5kIHN0b3AgYXV0by1zY3JvbGwgdW5sZXNzIHNpbXVsYXRpb24gaXMgcnVubmluZ1xyXG5cclxuXHJcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnBvaW50ZXJVcCA9IGZ1bmN0aW9uIHBvaW50ZXJVcChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0KSB7XHJcbiAgICB2YXIgcG9pbnRlckluZGV4ID0gdGhpcy5nZXRQb2ludGVySW5kZXgocG9pbnRlcik7XHJcblxyXG4gICAgc2lnbmFscy5maXJlKC9jYW5jZWwkL2kudGVzdChldmVudC50eXBlKSA/ICdjYW5jZWwnIDogJ3VwJywge1xyXG4gICAgICBwb2ludGVyOiBwb2ludGVyLFxyXG4gICAgICBwb2ludGVySW5kZXg6IHBvaW50ZXJJbmRleCxcclxuICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXHJcbiAgICAgIGN1ckV2ZW50VGFyZ2V0OiBjdXJFdmVudFRhcmdldCxcclxuICAgICAgaW50ZXJhY3Rpb246IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghdGhpcy5zaW11bGF0aW9uKSB7XHJcbiAgICAgIHRoaXMuZW5kKGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcclxuICAgIHRoaXMucmVtb3ZlUG9pbnRlcihwb2ludGVyLCBldmVudCk7XHJcbiAgfTtcclxuXHJcbiAgLypcXFxyXG4gICAqIEludGVyYWN0aW9uLmVuZFxyXG4gICBbIG1ldGhvZCBdXHJcbiAgICpcclxuICAgKiBTdG9wIHRoZSBjdXJyZW50IGFjdGlvbiBhbmQgZmlyZSBhbiBlbmQgZXZlbnQuIEluZXJ0aWFsIG1vdmVtZW50IGRvZXNcclxuICAgKiBub3QgaGFwcGVuLlxyXG4gICAqXHJcbiAgIC0gZXZlbnQgKFBvaW50ZXJFdmVudCkgI29wdGlvbmFsXHJcbiAgICoqXHJcbiAgIHwgaW50ZXJhY3QodGFyZ2V0KVxyXG4gICB8ICAgLmRyYWdnYWJsZSh0cnVlKVxyXG4gICB8ICAgLm9uKCdtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgIHwgICAgIGlmIChldmVudC5wYWdlWCA+IDEwMDApIHtcclxuICAgfCAgICAgICAvLyBlbmQgdGhlIGN1cnJlbnQgYWN0aW9uXHJcbiAgIHwgICAgICAgZXZlbnQuaW50ZXJhY3Rpb24uZW5kKCk7XHJcbiAgIHwgICAgICAgLy8gc3RvcCBhbGwgZnVydGhlciBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWRcclxuICAgfCAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgfCAgICAgfVxyXG4gICB8ICAgfSk7XHJcbiAgIFxcKi9cclxuXHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZXZlbnQpIHtcclxuICAgIGV2ZW50ID0gZXZlbnQgfHwgdGhpcy5wcmV2RXZlbnQ7XHJcblxyXG4gICAgaWYgKHRoaXMuaW50ZXJhY3RpbmcoKSkge1xyXG4gICAgICBzaWduYWxzLmZpcmUoJ2FjdGlvbi1lbmQnLCB7XHJcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgIGludGVyYWN0aW9uOiB0aGlzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RvcCgpO1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gY3VycmVudEFjdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGluZyA/IHRoaXMucHJlcGFyZWQubmFtZSA6IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmludGVyYWN0aW5nID0gZnVuY3Rpb24gaW50ZXJhY3RpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpbmc7XHJcbiAgfTtcclxuXHJcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xyXG4gICAgc2lnbmFscy5maXJlKCdzdG9wJywgeyBpbnRlcmFjdGlvbjogdGhpcyB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpbmcpIHtcclxuICAgICAgc2lnbmFscy5maXJlKCdzdG9wLWFjdGl2ZScsIHsgaW50ZXJhY3Rpb246IHRoaXMgfSk7XHJcbiAgICAgIHNpZ25hbHMuZmlyZSgnc3RvcC0nICsgdGhpcy5wcmVwYXJlZC5uYW1lLCB7IGludGVyYWN0aW9uOiB0aGlzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5wcmVwYXJlZC5uYW1lID0gdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5nZXRQb2ludGVySW5kZXggPSBmdW5jdGlvbiBnZXRQb2ludGVySW5kZXgocG9pbnRlcikge1xyXG4gICAgLy8gbW91c2UgYW5kIHBlbiBpbnRlcmFjdGlvbnMgbWF5IGhhdmUgb25seSBvbmUgcG9pbnRlclxyXG4gICAgaWYgKHRoaXMucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgdGhpcy5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHV0aWxzLmluZGV4T2YodGhpcy5wb2ludGVySWRzLCB1dGlscy5nZXRQb2ludGVySWQocG9pbnRlcikpO1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS51cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihwb2ludGVyLCBldmVudCkge1xyXG4gICAgdmFyIGRvd24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGV2ZW50ICYmIC8oZG93bnxzdGFydCkkL2kudGVzdChldmVudC50eXBlKTtcclxuXHJcbiAgICB2YXIgaWQgPSB1dGlscy5nZXRQb2ludGVySWQocG9pbnRlcik7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldFBvaW50ZXJJbmRleChwb2ludGVyKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgIGluZGV4ID0gdGhpcy5wb2ludGVySWRzLmxlbmd0aDtcclxuICAgICAgdGhpcy5wb2ludGVySWRzW2luZGV4XSA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb3duKSB7XHJcbiAgICAgIHNpZ25hbHMuZmlyZSgndXBkYXRlLXBvaW50ZXItZG93bicsIHtcclxuICAgICAgICBwb2ludGVyOiBwb2ludGVyLFxyXG4gICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICBkb3duOiBkb3duLFxyXG4gICAgICAgIHBvaW50ZXJJZDogaWQsXHJcbiAgICAgICAgcG9pbnRlckluZGV4OiBpbmRleCxcclxuICAgICAgICBpbnRlcmFjdGlvbjogdGhpc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBvaW50ZXJzW2luZGV4XSA9IHBvaW50ZXI7XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5yZW1vdmVQb2ludGVyID0gZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihwb2ludGVyLCBldmVudCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRQb2ludGVySW5kZXgocG9pbnRlcik7XHJcblxyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCdyZW1vdmUtcG9pbnRlcicsIHtcclxuICAgICAgcG9pbnRlcjogcG9pbnRlcixcclxuICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICBwb2ludGVySW5kZXg6IGluZGV4LFxyXG4gICAgICBpbnRlcmFjdGlvbjogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5wb2ludGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy5wb2ludGVySWRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB0aGlzLmRvd25UYXJnZXRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB0aGlzLmRvd25UaW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIH07XHJcblxyXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlRXZlbnRUYXJnZXRzID0gZnVuY3Rpb24gX3VwZGF0ZUV2ZW50VGFyZ2V0cyh0YXJnZXQsIGN1cnJlbnRUYXJnZXQpIHtcclxuICAgIHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy5fY3VyRXZlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBJbnRlcmFjdGlvbjtcclxufSgpO1xyXG5cclxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZE5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgdmFyIG1ldGhvZCA9IG1ldGhvZE5hbWVzW2ldO1xyXG5cclxuICBsaXN0ZW5lcnNbbWV0aG9kXSA9IGRvT25JbnRlcmFjdGlvbnMobWV0aG9kKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZG9PbkludGVyYWN0aW9ucyhtZXRob2QpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB2YXIgcG9pbnRlclR5cGUgPSB1dGlscy5nZXRQb2ludGVyVHlwZShldmVudCk7XHJcblxyXG4gICAgdmFyIF91dGlscyRnZXRFdmVudFRhcmdldCA9IHV0aWxzLmdldEV2ZW50VGFyZ2V0cyhldmVudCksXHJcbiAgICAgICAgZXZlbnRUYXJnZXQgPSBfdXRpbHMkZ2V0RXZlbnRUYXJnZXRbMF0sXHJcbiAgICAgICAgY3VyRXZlbnRUYXJnZXQgPSBfdXRpbHMkZ2V0RXZlbnRUYXJnZXRbMV07XHJcblxyXG4gICAgdmFyIG1hdGNoZXMgPSBbXTsgLy8gWyBbcG9pbnRlciwgaW50ZXJhY3Rpb25dLCAuLi5dXHJcblxyXG4gICAgaWYgKGJyb3dzZXIuc3VwcG9ydHNUb3VjaCAmJiAvdG91Y2gvLnRlc3QoZXZlbnQudHlwZSkpIHtcclxuICAgICAgcHJldlRvdWNoVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb2ludGVyID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbX2ldO1xyXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IGZpbmRlci5zZWFyY2gocG9pbnRlciwgZXZlbnQudHlwZSwgZXZlbnRUYXJnZXQpO1xyXG5cclxuICAgICAgICBtYXRjaGVzLnB1c2goW3BvaW50ZXIsIGludGVyYWN0aW9uIHx8IG5ldyBJbnRlcmFjdGlvbih7IHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSB9KV0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaW52YWxpZFBvaW50ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmICghYnJvd3Nlci5zdXBwb3J0c1BvaW50ZXJFdmVudCAmJiAvbW91c2UvLnRlc3QoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAvLyBpZ25vcmUgbW91c2UgZXZlbnRzIHdoaWxlIHRvdWNoIGludGVyYWN0aW9ucyBhcmUgYWN0aXZlXHJcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc2NvcGUuaW50ZXJhY3Rpb25zLmxlbmd0aCAmJiAhaW52YWxpZFBvaW50ZXI7IF9pMisrKSB7XHJcbiAgICAgICAgICBpbnZhbGlkUG9pbnRlciA9IHNjb3BlLmludGVyYWN0aW9uc1tfaTJdLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIHNjb3BlLmludGVyYWN0aW9uc1tfaTJdLnBvaW50ZXJJc0Rvd247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0cnkgdG8gaWdub3JlIG1vdXNlIGV2ZW50cyB0aGF0IGFyZSBzaW11bGF0ZWQgYnkgdGhlIGJyb3dzZXJcclxuICAgICAgICAvLyBhZnRlciBhIHRvdWNoIGV2ZW50XHJcbiAgICAgICAgaW52YWxpZFBvaW50ZXIgPSBpbnZhbGlkUG9pbnRlciB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHByZXZUb3VjaFRpbWUgPCA1MDBcclxuICAgICAgICAvLyBvbiBpT1MgYW5kIEZpcmVmb3ggTW9iaWxlLCBNb3VzZUV2ZW50LnRpbWVTdGFtcCBpcyB6ZXJvIGlmIHNpbXVsYXRlZFxyXG4gICAgICAgIHx8IGV2ZW50LnRpbWVTdGFtcCA9PT0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpbnZhbGlkUG9pbnRlcikge1xyXG4gICAgICAgIHZhciBfaW50ZXJhY3Rpb24gPSBmaW5kZXIuc2VhcmNoKGV2ZW50LCBldmVudC50eXBlLCBldmVudFRhcmdldCk7XHJcblxyXG4gICAgICAgIGlmICghX2ludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICBfaW50ZXJhY3Rpb24gPSBuZXcgSW50ZXJhY3Rpb24oeyBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRjaGVzLnB1c2goW2V2ZW50LCBfaW50ZXJhY3Rpb25dKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG1hdGNoZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaTMgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICB2YXIgX3JlZjI7XHJcblxyXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcclxuICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yW19pMysrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaTMgPSBfaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZjIgPSBfaTMudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBfcmVmMyA9IF9yZWYyLFxyXG4gICAgICAgICAgX3BvaW50ZXIgPSBfcmVmM1swXSxcclxuICAgICAgICAgIF9pbnRlcmFjdGlvbjIgPSBfcmVmM1sxXTtcclxuXHJcbiAgICAgIF9pbnRlcmFjdGlvbjIuX3VwZGF0ZUV2ZW50VGFyZ2V0cyhldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xyXG4gICAgICBfaW50ZXJhY3Rpb24yW21ldGhvZF0oX3BvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZEFsbChldmVudCkge1xyXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHNjb3BlLmludGVyYWN0aW9ucy5sZW5ndGg7IF9pNCsrKSB7XHJcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBzY29wZS5pbnRlcmFjdGlvbnNbX2k0XTtcclxuXHJcbiAgICBpbnRlcmFjdGlvbi5lbmQoZXZlbnQpO1xyXG4gICAgc2lnbmFscy5maXJlKCdlbmRhbGwnLCB7IGV2ZW50OiBldmVudCwgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uIH0pO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGRvY0V2ZW50cyA9IHsvKiAnZXZlbnRUeXBlJzogbGlzdGVuZXJGdW5jICovfTtcclxudmFyIHBFdmVudFR5cGVzID0gYnJvd3Nlci5wRXZlbnRUeXBlcztcclxuXHJcbmlmIChkb21PYmplY3RzLlBvaW50ZXJFdmVudCkge1xyXG4gIGRvY0V2ZW50c1twRXZlbnRUeXBlcy5kb3duXSA9IGxpc3RlbmVycy5wb2ludGVyRG93bjtcclxuICBkb2NFdmVudHNbcEV2ZW50VHlwZXMubW92ZV0gPSBsaXN0ZW5lcnMucG9pbnRlck1vdmU7XHJcbiAgZG9jRXZlbnRzW3BFdmVudFR5cGVzLnVwXSA9IGxpc3RlbmVycy5wb2ludGVyVXA7XHJcbiAgZG9jRXZlbnRzW3BFdmVudFR5cGVzLmNhbmNlbF0gPSBsaXN0ZW5lcnMucG9pbnRlclVwO1xyXG59IGVsc2Uge1xyXG4gIGRvY0V2ZW50cy5tb3VzZWRvd24gPSBsaXN0ZW5lcnMucG9pbnRlckRvd247XHJcbiAgZG9jRXZlbnRzLm1vdXNlbW92ZSA9IGxpc3RlbmVycy5wb2ludGVyTW92ZTtcclxuICBkb2NFdmVudHMubW91c2V1cCA9IGxpc3RlbmVycy5wb2ludGVyVXA7XHJcblxyXG4gIGRvY0V2ZW50cy50b3VjaHN0YXJ0ID0gbGlzdGVuZXJzLnBvaW50ZXJEb3duO1xyXG4gIGRvY0V2ZW50cy50b3VjaG1vdmUgPSBsaXN0ZW5lcnMucG9pbnRlck1vdmU7XHJcbiAgZG9jRXZlbnRzLnRvdWNoZW5kID0gbGlzdGVuZXJzLnBvaW50ZXJVcDtcclxuICBkb2NFdmVudHMudG91Y2hjYW5jZWwgPSBsaXN0ZW5lcnMucG9pbnRlclVwO1xyXG59XHJcblxyXG5kb2NFdmVudHMuYmx1ciA9IGVuZEFsbDtcclxuXHJcbmZ1bmN0aW9uIG9uRG9jU2lnbmFsKF9yZWY0LCBzaWduYWxOYW1lKSB7XHJcbiAgdmFyIGRvYyA9IF9yZWY0LmRvYztcclxuXHJcbiAgdmFyIGV2ZW50TWV0aG9kID0gc2lnbmFsTmFtZS5pbmRleE9mKCdhZGQnKSA9PT0gMCA/IGV2ZW50cy5hZGQgOiBldmVudHMucmVtb3ZlO1xyXG5cclxuICAvLyBkZWxlZ2F0ZSBldmVudCBsaXN0ZW5lclxyXG4gIGZvciAodmFyIGV2ZW50VHlwZSBpbiBzY29wZS5kZWxlZ2F0ZWRFdmVudHMpIHtcclxuICAgIGV2ZW50TWV0aG9kKGRvYywgZXZlbnRUeXBlLCBldmVudHMuZGVsZWdhdGVMaXN0ZW5lcik7XHJcbiAgICBldmVudE1ldGhvZChkb2MsIGV2ZW50VHlwZSwgZXZlbnRzLmRlbGVnYXRlVXNlQ2FwdHVyZSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBfZXZlbnRUeXBlIGluIGRvY0V2ZW50cykge1xyXG4gICAgZXZlbnRNZXRob2QoZG9jLCBfZXZlbnRUeXBlLCBkb2NFdmVudHNbX2V2ZW50VHlwZV0pO1xyXG4gIH1cclxufVxyXG5cclxuc2lnbmFscy5vbigndXBkYXRlLXBvaW50ZXItZG93bicsIGZ1bmN0aW9uIChfcmVmNSkge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWY1LmludGVyYWN0aW9uLFxyXG4gICAgICBwb2ludGVyID0gX3JlZjUucG9pbnRlcixcclxuICAgICAgcG9pbnRlcklkID0gX3JlZjUucG9pbnRlcklkLFxyXG4gICAgICBwb2ludGVySW5kZXggPSBfcmVmNS5wb2ludGVySW5kZXgsXHJcbiAgICAgIGV2ZW50ID0gX3JlZjUuZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0ID0gX3JlZjUuZXZlbnRUYXJnZXQsXHJcbiAgICAgIGRvd24gPSBfcmVmNS5kb3duO1xyXG5cclxuICBpbnRlcmFjdGlvbi5wb2ludGVySWRzW3BvaW50ZXJJbmRleF0gPSBwb2ludGVySWQ7XHJcbiAgaW50ZXJhY3Rpb24ucG9pbnRlcnNbcG9pbnRlckluZGV4XSA9IHBvaW50ZXI7XHJcblxyXG4gIGlmIChkb3duKSB7XHJcbiAgICBpbnRlcmFjdGlvbi5wb2ludGVySXNEb3duID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICghaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xyXG4gICAgdXRpbHMuc2V0Q29vcmRzKGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLCBpbnRlcmFjdGlvbi5wb2ludGVycyk7XHJcblxyXG4gICAgdXRpbHMuY29weUNvb3JkcyhpbnRlcmFjdGlvbi5jdXJDb29yZHMsIGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzKTtcclxuICAgIHV0aWxzLmNvcHlDb29yZHMoaW50ZXJhY3Rpb24ucHJldkNvb3JkcywgaW50ZXJhY3Rpb24uc3RhcnRDb29yZHMpO1xyXG5cclxuICAgIGludGVyYWN0aW9uLmRvd25FdmVudCA9IGV2ZW50O1xyXG4gICAgaW50ZXJhY3Rpb24uZG93blRpbWVzW3BvaW50ZXJJbmRleF0gPSBpbnRlcmFjdGlvbi5jdXJDb29yZHMudGltZVN0YW1wO1xyXG4gICAgaW50ZXJhY3Rpb24uZG93blRhcmdldHNbcG9pbnRlckluZGV4XSA9IGV2ZW50VGFyZ2V0IHx8IGV2ZW50ICYmIHV0aWxzLmdldEV2ZW50VGFyZ2V0cyhldmVudClbMF07XHJcbiAgICBpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgICB1dGlscy5wb2ludGVyRXh0ZW5kKGludGVyYWN0aW9uLmRvd25Qb2ludGVyLCBwb2ludGVyKTtcclxuICB9XHJcbn0pO1xyXG5cclxuc2NvcGUuc2lnbmFscy5vbignYWRkLWRvY3VtZW50Jywgb25Eb2NTaWduYWwpO1xyXG5zY29wZS5zaWduYWxzLm9uKCdyZW1vdmUtZG9jdW1lbnQnLCBvbkRvY1NpZ25hbCk7XHJcblxyXG5JbnRlcmFjdGlvbi5wb2ludGVyTW92ZVRvbGVyYW5jZSA9IDE7XHJcbkludGVyYWN0aW9uLmRvT25JbnRlcmFjdGlvbnMgPSBkb09uSW50ZXJhY3Rpb25zO1xyXG5JbnRlcmFjdGlvbi5lbmRBbGwgPSBlbmRBbGw7XHJcbkludGVyYWN0aW9uLnNpZ25hbHMgPSBzaWduYWxzO1xyXG5JbnRlcmFjdGlvbi5kb2NFdmVudHMgPSBkb2NFdmVudHM7XHJcblxyXG5zY29wZS5lbmRBbGxJbnRlcmFjdGlvbnMgPSBlbmRBbGw7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uO1xyXG5cclxufSx7XCIuL3Njb3BlXCI6MzQsXCIuL3V0aWxzXCI6NDQsXCIuL3V0aWxzL1NpZ25hbHNcIjozNSxcIi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi91dGlscy9kb21PYmplY3RzXCI6MzgsXCIuL3V0aWxzL2V2ZW50c1wiOjQwLFwiLi91dGlscy9pbnRlcmFjdGlvbkZpbmRlclwiOjQ1fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4uL0ludGVyYWN0aW9uJyk7XHJcbnZhciBJbnRlcmFjdEV2ZW50ID0gcmVxdWlyZSgnLi4vSW50ZXJhY3RFdmVudCcpO1xyXG5cclxudmFyIGFjdGlvbnMgPSB7XHJcbiAgZmlyZVByZXBhcmVkOiBmaXJlUHJlcGFyZWQsXHJcbiAgbmFtZXM6IFtdLFxyXG4gIG1ldGhvZERpY3Q6IHt9XHJcbn07XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdhY3Rpb24tc3RhcnQnLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb24sXHJcbiAgICAgIGV2ZW50ID0gX3JlZi5ldmVudDtcclxuXHJcbiAgaW50ZXJhY3Rpb24uX2ludGVyYWN0aW5nID0gdHJ1ZTtcclxuICBmaXJlUHJlcGFyZWQoaW50ZXJhY3Rpb24sIGV2ZW50LCAnc3RhcnQnKTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdhY3Rpb24tbW92ZScsIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYyLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudCA9IF9yZWYyLmV2ZW50LFxyXG4gICAgICBwcmVFbmQgPSBfcmVmMi5wcmVFbmQ7XHJcblxyXG4gIGZpcmVQcmVwYXJlZChpbnRlcmFjdGlvbiwgZXZlbnQsICdtb3ZlJywgcHJlRW5kKTtcclxuXHJcbiAgLy8gaWYgdGhlIGFjdGlvbiB3YXMgZW5kZWQgaW4gYSBsaXN0ZW5lclxyXG4gIGlmICghaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdhY3Rpb24tZW5kJywgZnVuY3Rpb24gKF9yZWYzKSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjMuaW50ZXJhY3Rpb24sXHJcbiAgICAgIGV2ZW50ID0gX3JlZjMuZXZlbnQ7XHJcblxyXG4gIGZpcmVQcmVwYXJlZChpbnRlcmFjdGlvbiwgZXZlbnQsICdlbmQnKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBmaXJlUHJlcGFyZWQoaW50ZXJhY3Rpb24sIGV2ZW50LCBwaGFzZSwgcHJlRW5kKSB7XHJcbiAgdmFyIGFjdGlvbk5hbWUgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lO1xyXG5cclxuICB2YXIgbmV3RXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudChpbnRlcmFjdGlvbiwgZXZlbnQsIGFjdGlvbk5hbWUsIHBoYXNlLCBpbnRlcmFjdGlvbi5lbGVtZW50LCBudWxsLCBwcmVFbmQpO1xyXG5cclxuICBpbnRlcmFjdGlvbi50YXJnZXQuZmlyZShuZXdFdmVudCk7XHJcbiAgaW50ZXJhY3Rpb24ucHJldkV2ZW50ID0gbmV3RXZlbnQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYWN0aW9ucztcclxuXHJcbn0se1wiLi4vSW50ZXJhY3RFdmVudFwiOjMsXCIuLi9JbnRlcmFjdGlvblwiOjV9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGFjdGlvbnMgPSByZXF1aXJlKCcuL2Jhc2UnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIEludGVyYWN0RXZlbnQgPSByZXF1aXJlKCcuLi9JbnRlcmFjdEV2ZW50Jyk7XHJcbnZhciBJbnRlcmFjdGFibGUgPSByZXF1aXJlKCcuLi9JbnRlcmFjdGFibGUnKTtcclxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi4vSW50ZXJhY3Rpb24nKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxuXHJcbnZhciBkcmFnID0ge1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgIG1vdXNlQnV0dG9uczogbnVsbCxcclxuXHJcbiAgICBvcmlnaW46IG51bGwsXHJcbiAgICBzbmFwOiBudWxsLFxyXG4gICAgcmVzdHJpY3Q6IG51bGwsXHJcbiAgICBpbmVydGlhOiBudWxsLFxyXG4gICAgYXV0b1Njcm9sbDogbnVsbCxcclxuXHJcbiAgICBzdGFydEF4aXM6ICd4eScsXHJcbiAgICBsb2NrQXhpczogJ3h5J1xyXG4gIH0sXHJcblxyXG4gIGNoZWNrZXI6IGZ1bmN0aW9uIGNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGludGVyYWN0YWJsZSkge1xyXG4gICAgdmFyIGRyYWdPcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZztcclxuXHJcbiAgICByZXR1cm4gZHJhZ09wdGlvbnMuZW5hYmxlZCA/IHsgbmFtZTogJ2RyYWcnLCBheGlzOiBkcmFnT3B0aW9ucy5sb2NrQXhpcyA9PT0gJ3N0YXJ0JyA/IGRyYWdPcHRpb25zLnN0YXJ0QXhpcyA6IGRyYWdPcHRpb25zLmxvY2tBeGlzIH0gOiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIGdldEN1cnNvcjogZnVuY3Rpb24gZ2V0Q3Vyc29yKCkge1xyXG4gICAgcmV0dXJuICdtb3ZlJztcclxuICB9XHJcbn07XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdiZWZvcmUtYWN0aW9uLW1vdmUnLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb247XHJcblxyXG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAnZHJhZycpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBheGlzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQuYXhpcztcclxuXHJcbiAgaWYgKGF4aXMgPT09ICd4Jykge1xyXG4gICAgaW50ZXJhY3Rpb24uY3VyQ29vcmRzLnBhZ2UueSA9IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLnBhZ2UueTtcclxuICAgIGludGVyYWN0aW9uLmN1ckNvb3Jkcy5jbGllbnQueSA9IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLmNsaWVudC55O1xyXG5cclxuICAgIGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YS5wYWdlLnNwZWVkID0gTWF0aC5hYnMoaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhLnBhZ2UudngpO1xyXG4gICAgaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhLmNsaWVudC5zcGVlZCA9IE1hdGguYWJzKGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YS5jbGllbnQudngpO1xyXG4gICAgaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhLmNsaWVudC52eSA9IDA7XHJcbiAgICBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEucGFnZS52eSA9IDA7XHJcbiAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcclxuICAgIGludGVyYWN0aW9uLmN1ckNvb3Jkcy5wYWdlLnggPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLng7XHJcbiAgICBpbnRlcmFjdGlvbi5jdXJDb29yZHMuY2xpZW50LnggPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueDtcclxuXHJcbiAgICBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEucGFnZS5zcGVlZCA9IE1hdGguYWJzKGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YS5wYWdlLnZ5KTtcclxuICAgIGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YS5jbGllbnQuc3BlZWQgPSBNYXRoLmFicyhpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEuY2xpZW50LnZ5KTtcclxuICAgIGludGVyYWN0aW9uLnBvaW50ZXJEZWx0YS5jbGllbnQudnggPSAwO1xyXG4gICAgaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhLnBhZ2UudnggPSAwO1xyXG4gIH1cclxufSk7XHJcblxyXG4vLyBkcmFnbW92ZVxyXG5JbnRlcmFjdEV2ZW50LnNpZ25hbHMub24oJ25ldycsIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gIHZhciBpRXZlbnQgPSBfcmVmMi5pRXZlbnQsXHJcbiAgICAgIGludGVyYWN0aW9uID0gX3JlZjIuaW50ZXJhY3Rpb247XHJcblxyXG4gIGlmIChpRXZlbnQudHlwZSAhPT0gJ2RyYWdtb3ZlJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGF4aXMgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5heGlzO1xyXG5cclxuICBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICBpRXZlbnQucGFnZVkgPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnk7XHJcbiAgICBpRXZlbnQuY2xpZW50WSA9IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLmNsaWVudC55O1xyXG4gICAgaUV2ZW50LmR5ID0gMDtcclxuICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xyXG4gICAgaUV2ZW50LnBhZ2VYID0gaW50ZXJhY3Rpb24uc3RhcnRDb29yZHMucGFnZS54O1xyXG4gICAgaUV2ZW50LmNsaWVudFggPSBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5jbGllbnQueDtcclxuICAgIGlFdmVudC5keCA9IDA7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLmRyYWdnYWJsZVxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBHZXRzIG9yIHNldHMgd2hldGhlciBkcmFnIGFjdGlvbnMgY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGVcclxuICogSW50ZXJhY3RhYmxlXHJcbiAqXHJcbiA9IChib29sZWFuKSBJbmRpY2F0ZXMgaWYgdGhpcyBjYW4gYmUgdGhlIHRhcmdldCBvZiBkcmFnIGV2ZW50c1xyXG4gfCB2YXIgaXNEcmFnZ2FibGUgPSBpbnRlcmFjdCgndWwgbGknKS5kcmFnZ2FibGUoKTtcclxuICogb3JcclxuIC0gb3B0aW9ucyAoYm9vbGVhbiB8IG9iamVjdCkgI29wdGlvbmFsIHRydWUvZmFsc2Ugb3IgQW4gb2JqZWN0IHdpdGggZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGZpcmVkIG9uIGRyYWcgZXZlbnRzIChvYmplY3QgbWFrZXMgdGhlIEludGVyYWN0YWJsZSBkcmFnZ2FibGUpXHJcbiA9IChvYmplY3QpIFRoaXMgSW50ZXJhY3RhYmxlXHJcbiB8IGludGVyYWN0KGVsZW1lbnQpLmRyYWdnYWJsZSh7XHJcbiB8ICAgICBvbnN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxyXG4gfCAgICAgb25tb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcclxuIHwgICAgIG9uZW5kICA6IGZ1bmN0aW9uIChldmVudCkge30sXHJcbiB8XHJcbiB8ICAgICAvLyB0aGUgYXhpcyBpbiB3aGljaCB0aGUgZmlyc3QgbW92ZW1lbnQgbXVzdCBiZVxyXG4gfCAgICAgLy8gZm9yIHRoZSBkcmFnIHNlcXVlbmNlIHRvIHN0YXJ0XHJcbiB8ICAgICAvLyAneHknIGJ5IGRlZmF1bHQgLSBhbnkgZGlyZWN0aW9uXHJcbiB8ICAgICBzdGFydEF4aXM6ICd4JyB8fCAneScgfHwgJ3h5JyxcclxuIHxcclxuIHwgICAgIC8vICd4eScgYnkgZGVmYXVsdCAtIGRvbid0IHJlc3RyaWN0IHRvIG9uZSBheGlzIChtb3ZlIGluIGFueSBkaXJlY3Rpb24pXHJcbiB8ICAgICAvLyAneCcgb3IgJ3knIHRvIHJlc3RyaWN0IG1vdmVtZW50IHRvIGVpdGhlciBheGlzXHJcbiB8ICAgICAvLyAnc3RhcnQnIHRvIHJlc3RyaWN0IG1vdmVtZW50IHRvIHRoZSBheGlzIHRoZSBkcmFnIHN0YXJ0ZWQgaW5cclxuIHwgICAgIGxvY2tBeGlzOiAneCcgfHwgJ3knIHx8ICd4eScgfHwgJ3N0YXJ0JyxcclxuIHxcclxuIHwgICAgIC8vIG1heCBudW1iZXIgb2YgZHJhZ3MgdGhhdCBjYW4gaGFwcGVuIGNvbmN1cnJlbnRseVxyXG4gfCAgICAgLy8gd2l0aCBlbGVtZW50cyBvZiB0aGlzIEludGVyYWN0YWJsZS4gSW5maW5pdHkgYnkgZGVmYXVsdFxyXG4gfCAgICAgbWF4OiBJbmZpbml0eSxcclxuIHxcclxuIHwgICAgIC8vIG1heCBudW1iZXIgb2YgZHJhZ3MgdGhhdCBjYW4gdGFyZ2V0IHRoZSBzYW1lIGVsZW1lbnQrSW50ZXJhY3RhYmxlXHJcbiB8ICAgICAvLyAxIGJ5IGRlZmF1bHRcclxuIHwgICAgIG1heFBlckVsZW1lbnQ6IDJcclxuIHwgfSk7XHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5kcmFnZ2FibGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIGlmICh1dGlscy5pcy5vYmplY3Qob3B0aW9ucykpIHtcclxuICAgIHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgdGhpcy5zZXRQZXJBY3Rpb24oJ2RyYWcnLCBvcHRpb25zKTtcclxuICAgIHRoaXMuc2V0T25FdmVudHMoJ2RyYWcnLCBvcHRpb25zKTtcclxuXHJcbiAgICBpZiAoL14oeHl8eHx5fHN0YXJ0KSQvLnRlc3Qob3B0aW9ucy5sb2NrQXhpcykpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLmRyYWcubG9ja0F4aXMgPSBvcHRpb25zLmxvY2tBeGlzO1xyXG4gICAgfVxyXG4gICAgaWYgKC9eKHh5fHh8eSkkLy50ZXN0KG9wdGlvbnMuc3RhcnRBeGlzKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuZHJhZy5zdGFydEF4aXMgPSBvcHRpb25zLnN0YXJ0QXhpcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGlmICh1dGlscy5pcy5ib29sKG9wdGlvbnMpKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMuZHJhZy5lbmFibGVkID0gb3B0aW9ucztcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5vbmRyYWdzdGFydCA9IHRoaXMub25kcmFnc3RhcnQgPSB0aGlzLm9uZHJhZ2VuZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLmRyYWc7XHJcbn07XHJcblxyXG5hY3Rpb25zLmRyYWcgPSBkcmFnO1xyXG5hY3Rpb25zLm5hbWVzLnB1c2goJ2RyYWcnKTtcclxudXRpbHMubWVyZ2UoSW50ZXJhY3RhYmxlLmV2ZW50VHlwZXMsIFsnZHJhZ3N0YXJ0JywgJ2RyYWdtb3ZlJywgJ2RyYWdpbmVydGlhc3RhcnQnLCAnZHJhZ2luZXJ0aWFyZXN1bWUnLCAnZHJhZ2VuZCddKTtcclxuYWN0aW9ucy5tZXRob2REaWN0LmRyYWcgPSAnZHJhZ2dhYmxlJztcclxuXHJcbmRlZmF1bHRPcHRpb25zLmRyYWcgPSBkcmFnLmRlZmF1bHRzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkcmFnO1xyXG5cclxufSx7XCIuLi9JbnRlcmFjdEV2ZW50XCI6MyxcIi4uL0ludGVyYWN0YWJsZVwiOjQsXCIuLi9JbnRlcmFjdGlvblwiOjUsXCIuLi9kZWZhdWx0T3B0aW9uc1wiOjE4LFwiLi4vdXRpbHNcIjo0NCxcIi4vYmFzZVwiOjZ9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGFjdGlvbnMgPSByZXF1aXJlKCcuL2Jhc2UnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIHNjb3BlID0gcmVxdWlyZSgnLi4vc2NvcGUnKTtcclxudmFyIGludGVyYWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJhY3QnKTtcclxudmFyIEludGVyYWN0RXZlbnQgPSByZXF1aXJlKCcuLi9JbnRlcmFjdEV2ZW50Jyk7XHJcbnZhciBJbnRlcmFjdGFibGUgPSByZXF1aXJlKCcuLi9JbnRlcmFjdGFibGUnKTtcclxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi4vSW50ZXJhY3Rpb24nKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxuXHJcbnZhciBkcm9wID0ge1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgIGFjY2VwdDogbnVsbCxcclxuICAgIG92ZXJsYXA6ICdwb2ludGVyJ1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBkeW5hbWljRHJvcCA9IGZhbHNlO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignYWN0aW9uLXN0YXJ0JywgZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQ7XHJcblxyXG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAnZHJhZycpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIHJlc2V0IGFjdGl2ZSBkcm9wem9uZXNcclxuICBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5kcm9wem9uZXMgPSBbXTtcclxuICBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5lbGVtZW50cyA9IFtdO1xyXG4gIGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLnJlY3RzID0gW107XHJcblxyXG4gIGludGVyYWN0aW9uLmRyb3BFdmVudHMgPSBudWxsO1xyXG5cclxuICBpZiAoIWludGVyYWN0aW9uLmR5bmFtaWNEcm9wKSB7XHJcbiAgICBzZXRBY3RpdmVEcm9wcyhpbnRlcmFjdGlvbiwgaW50ZXJhY3Rpb24uZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICB2YXIgZHJhZ0V2ZW50ID0gaW50ZXJhY3Rpb24ucHJldkV2ZW50O1xyXG4gIHZhciBkcm9wRXZlbnRzID0gZ2V0RHJvcEV2ZW50cyhpbnRlcmFjdGlvbiwgZXZlbnQsIGRyYWdFdmVudCk7XHJcblxyXG4gIGlmIChkcm9wRXZlbnRzLmFjdGl2YXRlKSB7XHJcbiAgICBmaXJlQWN0aXZlRHJvcHMoaW50ZXJhY3Rpb24sIGRyb3BFdmVudHMuYWN0aXZhdGUpO1xyXG4gIH1cclxufSk7XHJcblxyXG5JbnRlcmFjdEV2ZW50LnNpZ25hbHMub24oJ25ldycsIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYyLmludGVyYWN0aW9uLFxyXG4gICAgICBpRXZlbnQgPSBfcmVmMi5pRXZlbnQsXHJcbiAgICAgIGV2ZW50ID0gX3JlZjIuZXZlbnQ7XHJcblxyXG4gIGlmIChpRXZlbnQudHlwZSAhPT0gJ2RyYWdtb3ZlJyAmJiBpRXZlbnQudHlwZSAhPT0gJ2RyYWdlbmQnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgZHJhZ2dhYmxlRWxlbWVudCA9IGludGVyYWN0aW9uLmVsZW1lbnQ7XHJcbiAgdmFyIGRyYWdFdmVudCA9IGlFdmVudDtcclxuICB2YXIgZHJvcFJlc3VsdCA9IGdldERyb3AoZHJhZ0V2ZW50LCBldmVudCwgZHJhZ2dhYmxlRWxlbWVudCk7XHJcblxyXG4gIGludGVyYWN0aW9uLmRyb3BUYXJnZXQgPSBkcm9wUmVzdWx0LmRyb3B6b25lO1xyXG4gIGludGVyYWN0aW9uLmRyb3BFbGVtZW50ID0gZHJvcFJlc3VsdC5lbGVtZW50O1xyXG5cclxuICBpbnRlcmFjdGlvbi5kcm9wRXZlbnRzID0gZ2V0RHJvcEV2ZW50cyhpbnRlcmFjdGlvbiwgZXZlbnQsIGRyYWdFdmVudCk7XHJcbn0pO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignYWN0aW9uLW1vdmUnLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbjtcclxuXHJcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgIT09ICdkcmFnJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZmlyZURyb3BFdmVudHMoaW50ZXJhY3Rpb24sIGludGVyYWN0aW9uLmRyb3BFdmVudHMpO1xyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ2FjdGlvbi1lbmQnLCBmdW5jdGlvbiAoX3JlZjQpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmNC5pbnRlcmFjdGlvbjtcclxuXHJcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgPT09ICdkcmFnJykge1xyXG4gICAgZmlyZURyb3BFdmVudHMoaW50ZXJhY3Rpb24sIGludGVyYWN0aW9uLmRyb3BFdmVudHMpO1xyXG4gIH1cclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdzdG9wLWRyYWcnLCBmdW5jdGlvbiAoX3JlZjUpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmNS5pbnRlcmFjdGlvbjtcclxuXHJcbiAgaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZHJvcHpvbmVzID0gaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZWxlbWVudHMgPSBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5yZWN0cyA9IGludGVyYWN0aW9uLmRyb3BFdmVudHMgPSBudWxsO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNvbGxlY3REcm9wcyhpbnRlcmFjdGlvbiwgZWxlbWVudCkge1xyXG4gIHZhciBkcm9wcyA9IFtdO1xyXG4gIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cclxuICBlbGVtZW50ID0gZWxlbWVudCB8fCBpbnRlcmFjdGlvbi5lbGVtZW50O1xyXG5cclxuICAvLyBjb2xsZWN0IGFsbCBkcm9wem9uZXMgYW5kIHRoZWlyIGVsZW1lbnRzIHdoaWNoIHF1YWxpZnkgZm9yIGEgZHJvcFxyXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IHNjb3BlLmludGVyYWN0YWJsZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICB2YXIgX3JlZjY7XHJcblxyXG4gICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgX3JlZjYgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgX3JlZjYgPSBfaS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3VycmVudCA9IF9yZWY2O1xyXG5cclxuICAgIGlmICghY3VycmVudC5vcHRpb25zLmRyb3AuZW5hYmxlZCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWNjZXB0ID0gY3VycmVudC5vcHRpb25zLmRyb3AuYWNjZXB0O1xyXG5cclxuICAgIC8vIHRlc3QgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGFnYWluc3QgdGhlIGRyb3B6b25lJ3MgYWNjZXB0IHNldHRpbmdcclxuICAgIGlmICh1dGlscy5pcy5lbGVtZW50KGFjY2VwdCkgJiYgYWNjZXB0ICE9PSBlbGVtZW50IHx8IHV0aWxzLmlzLnN0cmluZyhhY2NlcHQpICYmICF1dGlscy5tYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgYWNjZXB0KSkge1xyXG5cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcXVlcnkgZm9yIG5ldyBlbGVtZW50cyBpZiBuZWNlc3NhcnlcclxuICAgIHZhciBkcm9wRWxlbWVudHMgPSB1dGlscy5pcy5zdHJpbmcoY3VycmVudC50YXJnZXQpID8gY3VycmVudC5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKGN1cnJlbnQudGFyZ2V0KSA6IFtjdXJyZW50LnRhcmdldF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcm9wRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gZHJvcEVsZW1lbnRzW2ldO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XHJcbiAgICAgICAgZHJvcHMucHVzaChjdXJyZW50KTtcclxuICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnRFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcclxuICAgIGRyb3B6b25lczogZHJvcHNcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXJlQWN0aXZlRHJvcHMoaW50ZXJhY3Rpb24sIGV2ZW50KSB7XHJcbiAgdmFyIHByZXZFbGVtZW50ID0gdm9pZCAwO1xyXG5cclxuICAvLyBsb29wIHRocm91Z2ggYWxsIGFjdGl2ZSBkcm9wem9uZXMgYW5kIHRyaWdnZXIgZXZlbnRcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLmRyb3B6b25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGN1cnJlbnQgPSBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5kcm9wem9uZXNbaV07XHJcbiAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5lbGVtZW50c1tpXTtcclxuXHJcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXIgb2YgZHVwbGljYXRlIGV2ZW50cyBvbiBzYW1lIGVsZW1lbnRcclxuICAgIGlmIChjdXJyZW50RWxlbWVudCAhPT0gcHJldkVsZW1lbnQpIHtcclxuICAgICAgLy8gc2V0IGN1cnJlbnQgZWxlbWVudCBhcyBldmVudCB0YXJnZXRcclxuICAgICAgZXZlbnQudGFyZ2V0ID0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgIGN1cnJlbnQuZmlyZShldmVudCk7XHJcbiAgICB9XHJcbiAgICBwcmV2RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29sbGVjdCBhIG5ldyBzZXQgb2YgcG9zc2libGUgZHJvcHMgYW5kIHNhdmUgdGhlbSBpbiBhY3RpdmVEcm9wcy5cclxuLy8gc2V0QWN0aXZlRHJvcHMgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgd2hlbiBhIGRyYWcgaGFzIGp1c3Qgc3RhcnRlZCBvciBhXHJcbi8vIGRyYWcgZXZlbnQgaGFwcGVucyB3aGlsZSBkeW5hbWljRHJvcCBpcyB0cnVlXHJcbmZ1bmN0aW9uIHNldEFjdGl2ZURyb3BzKGludGVyYWN0aW9uLCBkcmFnRWxlbWVudCkge1xyXG4gIC8vIGdldCBkcm9wem9uZXMgYW5kIHRoZWlyIGVsZW1lbnRzIHRoYXQgY291bGQgcmVjZWl2ZSB0aGUgZHJhZ2dhYmxlXHJcbiAgdmFyIHBvc3NpYmxlRHJvcHMgPSBjb2xsZWN0RHJvcHMoaW50ZXJhY3Rpb24sIGRyYWdFbGVtZW50LCB0cnVlKTtcclxuXHJcbiAgaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZHJvcHpvbmVzID0gcG9zc2libGVEcm9wcy5kcm9wem9uZXM7XHJcbiAgaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZWxlbWVudHMgPSBwb3NzaWJsZURyb3BzLmVsZW1lbnRzO1xyXG4gIGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLnJlY3RzID0gW107XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZHJvcHpvbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5yZWN0c1tpXSA9IGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLmRyb3B6b25lc1tpXS5nZXRSZWN0KGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLmVsZW1lbnRzW2ldKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERyb3AoZHJhZ0V2ZW50LCBldmVudCwgZHJhZ0VsZW1lbnQpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBkcmFnRXZlbnQuaW50ZXJhY3Rpb247XHJcbiAgdmFyIHZhbGlkRHJvcHMgPSBbXTtcclxuXHJcbiAgaWYgKGR5bmFtaWNEcm9wKSB7XHJcbiAgICBzZXRBY3RpdmVEcm9wcyhpbnRlcmFjdGlvbiwgZHJhZ0VsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gY29sbGVjdCBhbGwgZHJvcHpvbmVzIGFuZCB0aGVpciBlbGVtZW50cyB3aGljaCBxdWFsaWZ5IGZvciBhIGRyb3BcclxuICBmb3IgKHZhciBqID0gMDsgaiA8IGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLmRyb3B6b25lcy5sZW5ndGg7IGorKykge1xyXG4gICAgdmFyIGN1cnJlbnQgPSBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5kcm9wem9uZXNbal07XHJcbiAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBpbnRlcmFjdGlvbi5hY3RpdmVEcm9wcy5lbGVtZW50c1tqXTtcclxuICAgIHZhciByZWN0ID0gaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMucmVjdHNbal07XHJcblxyXG4gICAgdmFsaWREcm9wcy5wdXNoKGN1cnJlbnQuZHJvcENoZWNrKGRyYWdFdmVudCwgZXZlbnQsIGludGVyYWN0aW9uLnRhcmdldCwgZHJhZ0VsZW1lbnQsIGN1cnJlbnRFbGVtZW50LCByZWN0KSA/IGN1cnJlbnRFbGVtZW50IDogbnVsbCk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZHJvcHpvbmUgYmFzZWQgb24gRE9NIGRlcHRoIGFuZCBvcmRlclxyXG4gIHZhciBkcm9wSW5kZXggPSB1dGlscy5pbmRleE9mRGVlcGVzdEVsZW1lbnQodmFsaWREcm9wcyk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkcm9wem9uZTogaW50ZXJhY3Rpb24uYWN0aXZlRHJvcHMuZHJvcHpvbmVzW2Ryb3BJbmRleF0gfHwgbnVsbCxcclxuICAgIGVsZW1lbnQ6IGludGVyYWN0aW9uLmFjdGl2ZURyb3BzLmVsZW1lbnRzW2Ryb3BJbmRleF0gfHwgbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERyb3BFdmVudHMoaW50ZXJhY3Rpb24sIHBvaW50ZXJFdmVudCwgZHJhZ0V2ZW50KSB7XHJcbiAgdmFyIGRyb3BFdmVudHMgPSB7XHJcbiAgICBlbnRlcjogbnVsbCxcclxuICAgIGxlYXZlOiBudWxsLFxyXG4gICAgYWN0aXZhdGU6IG51bGwsXHJcbiAgICBkZWFjdGl2YXRlOiBudWxsLFxyXG4gICAgbW92ZTogbnVsbCxcclxuICAgIGRyb3A6IG51bGxcclxuICB9O1xyXG5cclxuICB2YXIgdG1wbCA9IHtcclxuICAgIGRyYWdFdmVudDogZHJhZ0V2ZW50LFxyXG4gICAgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uLFxyXG4gICAgdGFyZ2V0OiBpbnRlcmFjdGlvbi5kcm9wRWxlbWVudCxcclxuICAgIGRyb3B6b25lOiBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0LFxyXG4gICAgcmVsYXRlZFRhcmdldDogZHJhZ0V2ZW50LnRhcmdldCxcclxuICAgIGRyYWdnYWJsZTogZHJhZ0V2ZW50LmludGVyYWN0YWJsZSxcclxuICAgIHRpbWVTdGFtcDogZHJhZ0V2ZW50LnRpbWVTdGFtcFxyXG4gIH07XHJcblxyXG4gIGlmIChpbnRlcmFjdGlvbi5kcm9wRWxlbWVudCAhPT0gaW50ZXJhY3Rpb24ucHJldkRyb3BFbGVtZW50KSB7XHJcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSBwcmV2RHJvcFRhcmdldCwgY3JlYXRlIGEgZHJhZ2xlYXZlIGV2ZW50XHJcbiAgICBpZiAoaW50ZXJhY3Rpb24ucHJldkRyb3BUYXJnZXQpIHtcclxuICAgICAgZHJvcEV2ZW50cy5sZWF2ZSA9IHV0aWxzLmV4dGVuZCh7IHR5cGU6ICdkcmFnbGVhdmUnIH0sIHRtcGwpO1xyXG5cclxuICAgICAgZHJhZ0V2ZW50LmRyYWdMZWF2ZSA9IGRyb3BFdmVudHMubGVhdmUudGFyZ2V0ID0gaW50ZXJhY3Rpb24ucHJldkRyb3BFbGVtZW50O1xyXG4gICAgICBkcmFnRXZlbnQucHJldkRyb3B6b25lID0gZHJvcEV2ZW50cy5sZWF2ZS5kcm9wem9uZSA9IGludGVyYWN0aW9uLnByZXZEcm9wVGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdGhlIGRyb3BUYXJnZXQgaXMgbm90IG51bGwsIGNyZWF0ZSBhIGRyYWdlbnRlciBldmVudFxyXG4gICAgaWYgKGludGVyYWN0aW9uLmRyb3BUYXJnZXQpIHtcclxuICAgICAgZHJvcEV2ZW50cy5lbnRlciA9IHtcclxuICAgICAgICBkcmFnRXZlbnQ6IGRyYWdFdmVudCxcclxuICAgICAgICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgdGFyZ2V0OiBpbnRlcmFjdGlvbi5kcm9wRWxlbWVudCxcclxuICAgICAgICBkcm9wem9uZTogaW50ZXJhY3Rpb24uZHJvcFRhcmdldCxcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBkcmFnRXZlbnQudGFyZ2V0LFxyXG4gICAgICAgIGRyYWdnYWJsZTogZHJhZ0V2ZW50LmludGVyYWN0YWJsZSxcclxuICAgICAgICB0aW1lU3RhbXA6IGRyYWdFdmVudC50aW1lU3RhbXAsXHJcbiAgICAgICAgdHlwZTogJ2RyYWdlbnRlcidcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRyYWdFdmVudC5kcmFnRW50ZXIgPSBpbnRlcmFjdGlvbi5kcm9wRWxlbWVudDtcclxuICAgICAgZHJhZ0V2ZW50LmRyb3B6b25lID0gaW50ZXJhY3Rpb24uZHJvcFRhcmdldDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChkcmFnRXZlbnQudHlwZSA9PT0gJ2RyYWdlbmQnICYmIGludGVyYWN0aW9uLmRyb3BUYXJnZXQpIHtcclxuICAgIGRyb3BFdmVudHMuZHJvcCA9IHV0aWxzLmV4dGVuZCh7IHR5cGU6ICdkcm9wJyB9LCB0bXBsKTtcclxuXHJcbiAgICBkcmFnRXZlbnQuZHJvcHpvbmUgPSBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0O1xyXG4gICAgZHJhZ0V2ZW50LnJlbGF0ZWRUYXJnZXQgPSBpbnRlcmFjdGlvbi5kcm9wRWxlbWVudDtcclxuICB9XHJcbiAgaWYgKGRyYWdFdmVudC50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xyXG4gICAgZHJvcEV2ZW50cy5hY3RpdmF0ZSA9IHV0aWxzLmV4dGVuZCh7IHR5cGU6ICdkcm9wYWN0aXZhdGUnIH0sIHRtcGwpO1xyXG5cclxuICAgIGRyb3BFdmVudHMuYWN0aXZhdGUudGFyZ2V0ID0gbnVsbDtcclxuICAgIGRyb3BFdmVudHMuYWN0aXZhdGUuZHJvcHpvbmUgPSBudWxsO1xyXG4gIH1cclxuICBpZiAoZHJhZ0V2ZW50LnR5cGUgPT09ICdkcmFnZW5kJykge1xyXG4gICAgZHJvcEV2ZW50cy5kZWFjdGl2YXRlID0gdXRpbHMuZXh0ZW5kKHsgdHlwZTogJ2Ryb3BkZWFjdGl2YXRlJyB9LCB0bXBsKTtcclxuXHJcbiAgICBkcm9wRXZlbnRzLmRlYWN0aXZhdGUudGFyZ2V0ID0gbnVsbDtcclxuICAgIGRyb3BFdmVudHMuZGVhY3RpdmF0ZS5kcm9wem9uZSA9IG51bGw7XHJcbiAgfVxyXG4gIGlmIChkcmFnRXZlbnQudHlwZSA9PT0gJ2RyYWdtb3ZlJyAmJiBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0KSB7XHJcbiAgICBkcm9wRXZlbnRzLm1vdmUgPSB1dGlscy5leHRlbmQoe1xyXG4gICAgICBkcmFnbW92ZTogZHJhZ0V2ZW50LFxyXG4gICAgICB0eXBlOiAnZHJvcG1vdmUnXHJcbiAgICB9LCB0bXBsKTtcclxuXHJcbiAgICBkcmFnRXZlbnQuZHJvcHpvbmUgPSBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRyb3BFdmVudHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpcmVEcm9wRXZlbnRzKGludGVyYWN0aW9uLCBkcm9wRXZlbnRzKSB7XHJcbiAgaWYgKGRyb3BFdmVudHMubGVhdmUpIHtcclxuICAgIGludGVyYWN0aW9uLnByZXZEcm9wVGFyZ2V0LmZpcmUoZHJvcEV2ZW50cy5sZWF2ZSk7XHJcbiAgfVxyXG4gIGlmIChkcm9wRXZlbnRzLm1vdmUpIHtcclxuICAgIGludGVyYWN0aW9uLmRyb3BUYXJnZXQuZmlyZShkcm9wRXZlbnRzLm1vdmUpO1xyXG4gIH1cclxuICBpZiAoZHJvcEV2ZW50cy5lbnRlcikge1xyXG4gICAgaW50ZXJhY3Rpb24uZHJvcFRhcmdldC5maXJlKGRyb3BFdmVudHMuZW50ZXIpO1xyXG4gIH1cclxuICBpZiAoZHJvcEV2ZW50cy5kcm9wKSB7XHJcbiAgICBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0LmZpcmUoZHJvcEV2ZW50cy5kcm9wKTtcclxuICB9XHJcbiAgaWYgKGRyb3BFdmVudHMuZGVhY3RpdmF0ZSkge1xyXG4gICAgZmlyZUFjdGl2ZURyb3BzKGludGVyYWN0aW9uLCBkcm9wRXZlbnRzLmRlYWN0aXZhdGUpO1xyXG4gIH1cclxuXHJcbiAgaW50ZXJhY3Rpb24ucHJldkRyb3BUYXJnZXQgPSBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0O1xyXG4gIGludGVyYWN0aW9uLnByZXZEcm9wRWxlbWVudCA9IGludGVyYWN0aW9uLmRyb3BFbGVtZW50O1xyXG59XHJcblxyXG4vKlxcXHJcbiAqIEludGVyYWN0YWJsZS5kcm9wem9uZVxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciBlbGVtZW50cyBjYW4gYmUgZHJvcHBlZCBvbnRvIHRoaXNcclxuICogSW50ZXJhY3RhYmxlIHRvIHRyaWdnZXIgZHJvcCBldmVudHNcclxuICpcclxuICogRHJvcHpvbmVzIGNhbiByZWNlaXZlIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxyXG4gKiAgLSBgZHJvcGFjdGl2YXRlYCBhbmQgYGRyb3BkZWFjdGl2YXRlYCB3aGVuIGFuIGFjY2VwdGFibGUgZHJhZyBzdGFydHMgYW5kIGVuZHNcclxuICogIC0gYGRyYWdlbnRlcmAgYW5kIGBkcmFnbGVhdmVgIHdoZW4gYSBkcmFnZ2FibGUgZW50ZXJzIGFuZCBsZWF2ZXMgdGhlIGRyb3B6b25lXHJcbiAqICAtIGBkcmFnbW92ZWAgd2hlbiBhIGRyYWdnYWJsZSB0aGF0IGhhcyBlbnRlcmVkIHRoZSBkcm9wem9uZSBpcyBtb3ZlZFxyXG4gKiAgLSBgZHJvcGAgd2hlbiBhIGRyYWdnYWJsZSBpcyBkcm9wcGVkIGludG8gdGhpcyBkcm9wem9uZVxyXG4gKlxyXG4gKiBVc2UgdGhlIGBhY2NlcHRgIG9wdGlvbiB0byBhbGxvdyBvbmx5IGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIENTU1xyXG4gKiBzZWxlY3RvciBvciBlbGVtZW50LiBUaGUgdmFsdWUgY2FuIGJlOlxyXG4gKlxyXG4gKiAgLSAqKmFuIEVsZW1lbnQqKiAtIG9ubHkgdGhhdCBlbGVtZW50IGNhbiBiZSBkcm9wcGVkIGludG8gdGhpcyBkcm9wem9uZS5cclxuICogIC0gKiphIHN0cmluZyoqLCAtIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWQgbXVzdCBtYXRjaCBpdCBhcyBhIENTUyBzZWxlY3Rvci5cclxuICogIC0gKipgbnVsbGAqKiAtIGFjY2VwdCBvcHRpb25zIGlzIGNsZWFyZWQgLSBpdCBhY2NlcHRzIGFueSBlbGVtZW50LlxyXG4gKlxyXG4gKiBVc2UgdGhlIGBvdmVybGFwYCBvcHRpb24gdG8gc2V0IGhvdyBkcm9wcyBhcmUgY2hlY2tlZCBmb3IuIFRoZSBhbGxvd2VkXHJcbiAqIHZhbHVlcyBhcmU6XHJcbiAqXHJcbiAqICAgLSBgJ3BvaW50ZXInYCwgdGhlIHBvaW50ZXIgbXVzdCBiZSBvdmVyIHRoZSBkcm9wem9uZSAoZGVmYXVsdClcclxuICogICAtIGAnY2VudGVyJ2AsIHRoZSBkcmFnZ2FibGUgZWxlbWVudCdzIGNlbnRlciBtdXN0IGJlIG92ZXIgdGhlIGRyb3B6b25lXHJcbiAqICAgLSBhIG51bWJlciBmcm9tIDAtMSB3aGljaCBpcyB0aGUgYChpbnRlcnNlY3Rpb24gYXJlYSkgLyAoZHJhZ2dhYmxlIGFyZWEpYC5cclxuICogICBlLmcuIGAwLjVgIGZvciBkcm9wIHRvIGhhcHBlbiB3aGVuIGhhbGYgb2YgdGhlIGFyZWEgb2YgdGhlIGRyYWdnYWJsZSBpc1xyXG4gKiAgIG92ZXIgdGhlIGRyb3B6b25lXHJcbiAqXHJcbiAqIFVzZSB0aGUgYGNoZWNrZXJgIG9wdGlvbiB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBkcmFnZ2VkXHJcbiAqIGVsZW1lbnQgaXMgb3ZlciB0aGlzIEludGVyYWN0YWJsZS5cclxuICpcclxuIHwgaW50ZXJhY3QodGFyZ2V0KVxyXG4gfCAuZHJvcENoZWNrZXIoZnVuY3Rpb24oZHJhZ0V2ZW50LCAgICAgICAgIC8vIHJlbGF0ZWQgZHJhZ21vdmUgb3IgZHJhZ2VuZCBldmVudFxyXG4gfCAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsICAgICAgICAgICAgIC8vIFRvdWNoRXZlbnQvUG9pbnRlckV2ZW50L01vdXNlRXZlbnRcclxuIHwgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwZWQsICAgICAgICAgICAvLyBib29sIHJlc3VsdCBvZiB0aGUgZGVmYXVsdCBjaGVja2VyXHJcbiB8ICAgICAgICAgICAgICAgICAgICAgICBkcm9wem9uZSwgICAgICAgICAgLy8gZHJvcHpvbmUgSW50ZXJhY3RhYmxlXHJcbiB8ICAgICAgICAgICAgICAgICAgICAgICBkcm9wRWxlbWVudCwgICAgICAgLy8gZHJvcHpvbmUgZWxlbW50XHJcbiB8ICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGUsICAgICAgICAgLy8gZHJhZ2dhYmxlIEludGVyYWN0YWJsZVxyXG4gfCAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlRWxlbWVudCkgey8vIGRyYWdnYWJsZSBlbGVtZW50XHJcbiB8XHJcbiB8ICAgcmV0dXJuIGRyb3BwZWQgJiYgZXZlbnQudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnYWxsb3ctZHJvcCcpO1xyXG4gfCB9XHJcbiAqXHJcbiAqXHJcbiAtIG9wdGlvbnMgKGJvb2xlYW4gfCBvYmplY3QgfCBudWxsKSAjb3B0aW9uYWwgVGhlIG5ldyB2YWx1ZSB0byBiZSBzZXQuXHJcbiB8IGludGVyYWN0KCcuZHJvcCcpLmRyb3B6b25lKHtcclxuIHwgICBhY2NlcHQ6ICcuY2FuLWRyb3AnIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5nbGUtZHJvcCcpLFxyXG4gfCAgIG92ZXJsYXA6ICdwb2ludGVyJyB8fCAnY2VudGVyJyB8fCB6ZXJvVG9PbmVcclxuIHwgfVxyXG4gPSAoYm9vbGVhbiB8IG9iamVjdCkgVGhlIGN1cnJlbnQgc2V0dGluZyBvciB0aGlzIEludGVyYWN0YWJsZVxyXG5cXCovXHJcbkludGVyYWN0YWJsZS5wcm90b3R5cGUuZHJvcHpvbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIGlmICh1dGlscy5pcy5vYmplY3Qob3B0aW9ucykpIHtcclxuICAgIHRoaXMub3B0aW9ucy5kcm9wLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xyXG5cclxuICAgIGlmICh1dGlscy5pcy5mdW5jdGlvbihvcHRpb25zLm9uZHJvcCkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub25kcm9wID0gb3B0aW9ucy5vbmRyb3A7XHJcbiAgICB9XHJcbiAgICBpZiAodXRpbHMuaXMuZnVuY3Rpb24ob3B0aW9ucy5vbmRyb3BhY3RpdmF0ZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub25kcm9wYWN0aXZhdGUgPSBvcHRpb25zLm9uZHJvcGFjdGl2YXRlO1xyXG4gICAgfVxyXG4gICAgaWYgKHV0aWxzLmlzLmZ1bmN0aW9uKG9wdGlvbnMub25kcm9wZGVhY3RpdmF0ZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub25kcm9wZGVhY3RpdmF0ZSA9IG9wdGlvbnMub25kcm9wZGVhY3RpdmF0ZTtcclxuICAgIH1cclxuICAgIGlmICh1dGlscy5pcy5mdW5jdGlvbihvcHRpb25zLm9uZHJhZ2VudGVyKSkge1xyXG4gICAgICB0aGlzLmV2ZW50cy5vbmRyYWdlbnRlciA9IG9wdGlvbnMub25kcmFnZW50ZXI7XHJcbiAgICB9XHJcbiAgICBpZiAodXRpbHMuaXMuZnVuY3Rpb24ob3B0aW9ucy5vbmRyYWdsZWF2ZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub25kcmFnbGVhdmUgPSBvcHRpb25zLm9uZHJhZ2xlYXZlO1xyXG4gICAgfVxyXG4gICAgaWYgKHV0aWxzLmlzLmZ1bmN0aW9uKG9wdGlvbnMub25kcm9wbW92ZSkpIHtcclxuICAgICAgdGhpcy5ldmVudHMub25kcm9wbW92ZSA9IG9wdGlvbnMub25kcm9wbW92ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoL14ocG9pbnRlcnxjZW50ZXIpJC8udGVzdChvcHRpb25zLm92ZXJsYXApKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5kcm9wLm92ZXJsYXAgPSBvcHRpb25zLm92ZXJsYXA7XHJcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzLm51bWJlcihvcHRpb25zLm92ZXJsYXApKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5kcm9wLm92ZXJsYXAgPSBNYXRoLm1heChNYXRoLm1pbigxLCBvcHRpb25zLm92ZXJsYXApLCAwKTtcclxuICAgIH1cclxuICAgIGlmICgnYWNjZXB0JyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5kcm9wLmFjY2VwdCA9IG9wdGlvbnMuYWNjZXB0O1xyXG4gICAgfVxyXG4gICAgaWYgKCdjaGVja2VyJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5kcm9wLmNoZWNrZXIgPSBvcHRpb25zLmNoZWNrZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZiAodXRpbHMuaXMuYm9vbChvcHRpb25zKSkge1xyXG4gICAgdGhpcy5vcHRpb25zLmRyb3AuZW5hYmxlZCA9IG9wdGlvbnM7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMub25kcmFnZW50ZXIgPSB0aGlzLm9uZHJhZ2xlYXZlID0gdGhpcy5vbmRyb3AgPSB0aGlzLm9uZHJvcGFjdGl2YXRlID0gdGhpcy5vbmRyb3BkZWFjdGl2YXRlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLm9wdGlvbnMuZHJvcDtcclxufTtcclxuXHJcbkludGVyYWN0YWJsZS5wcm90b3R5cGUuZHJvcENoZWNrID0gZnVuY3Rpb24gKGRyYWdFdmVudCwgZXZlbnQsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlRWxlbWVudCwgZHJvcEVsZW1lbnQsIHJlY3QpIHtcclxuICB2YXIgZHJvcHBlZCA9IGZhbHNlO1xyXG5cclxuICAvLyBpZiB0aGUgZHJvcHpvbmUgaGFzIG5vIHJlY3QgKGVnLiBkaXNwbGF5OiBub25lKVxyXG4gIC8vIGNhbGwgdGhlIGN1c3RvbSBkcm9wQ2hlY2tlciBvciBqdXN0IHJldHVybiBmYWxzZVxyXG4gIGlmICghKHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0UmVjdChkcm9wRWxlbWVudCkpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRyb3AuY2hlY2tlciA/IHRoaXMub3B0aW9ucy5kcm9wLmNoZWNrZXIoZHJhZ0V2ZW50LCBldmVudCwgZHJvcHBlZCwgdGhpcywgZHJvcEVsZW1lbnQsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlRWxlbWVudCkgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBkcm9wT3ZlcmxhcCA9IHRoaXMub3B0aW9ucy5kcm9wLm92ZXJsYXA7XHJcblxyXG4gIGlmIChkcm9wT3ZlcmxhcCA9PT0gJ3BvaW50ZXInKSB7XHJcbiAgICB2YXIgb3JpZ2luID0gdXRpbHMuZ2V0T3JpZ2luWFkoZHJhZ2dhYmxlLCBkcmFnZ2FibGVFbGVtZW50LCAnZHJhZycpO1xyXG4gICAgdmFyIHBhZ2UgPSB1dGlscy5nZXRQYWdlWFkoZHJhZ0V2ZW50KTtcclxuXHJcbiAgICBwYWdlLnggKz0gb3JpZ2luLng7XHJcbiAgICBwYWdlLnkgKz0gb3JpZ2luLnk7XHJcblxyXG4gICAgdmFyIGhvcml6b250YWwgPSBwYWdlLnggPiByZWN0LmxlZnQgJiYgcGFnZS54IDwgcmVjdC5yaWdodDtcclxuICAgIHZhciB2ZXJ0aWNhbCA9IHBhZ2UueSA+IHJlY3QudG9wICYmIHBhZ2UueSA8IHJlY3QuYm90dG9tO1xyXG5cclxuICAgIGRyb3BwZWQgPSBob3Jpem9udGFsICYmIHZlcnRpY2FsO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRyYWdSZWN0ID0gZHJhZ2dhYmxlLmdldFJlY3QoZHJhZ2dhYmxlRWxlbWVudCk7XHJcblxyXG4gIGlmIChkcmFnUmVjdCAmJiBkcm9wT3ZlcmxhcCA9PT0gJ2NlbnRlcicpIHtcclxuICAgIHZhciBjeCA9IGRyYWdSZWN0LmxlZnQgKyBkcmFnUmVjdC53aWR0aCAvIDI7XHJcbiAgICB2YXIgY3kgPSBkcmFnUmVjdC50b3AgKyBkcmFnUmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgIGRyb3BwZWQgPSBjeCA+PSByZWN0LmxlZnQgJiYgY3ggPD0gcmVjdC5yaWdodCAmJiBjeSA+PSByZWN0LnRvcCAmJiBjeSA8PSByZWN0LmJvdHRvbTtcclxuICB9XHJcblxyXG4gIGlmIChkcmFnUmVjdCAmJiB1dGlscy5pcy5udW1iZXIoZHJvcE92ZXJsYXApKSB7XHJcbiAgICB2YXIgb3ZlcmxhcEFyZWEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0LnJpZ2h0LCBkcmFnUmVjdC5yaWdodCkgLSBNYXRoLm1heChyZWN0LmxlZnQsIGRyYWdSZWN0LmxlZnQpKSAqIE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3QuYm90dG9tLCBkcmFnUmVjdC5ib3R0b20pIC0gTWF0aC5tYXgocmVjdC50b3AsIGRyYWdSZWN0LnRvcCkpO1xyXG5cclxuICAgIHZhciBvdmVybGFwUmF0aW8gPSBvdmVybGFwQXJlYSAvIChkcmFnUmVjdC53aWR0aCAqIGRyYWdSZWN0LmhlaWdodCk7XHJcblxyXG4gICAgZHJvcHBlZCA9IG92ZXJsYXBSYXRpbyA+PSBkcm9wT3ZlcmxhcDtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLm9wdGlvbnMuZHJvcC5jaGVja2VyKSB7XHJcbiAgICBkcm9wcGVkID0gdGhpcy5vcHRpb25zLmRyb3AuY2hlY2tlcihkcmFnRXZlbnQsIGV2ZW50LCBkcm9wcGVkLCB0aGlzLCBkcm9wRWxlbWVudCwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVFbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkcm9wcGVkO1xyXG59O1xyXG5cclxuSW50ZXJhY3RhYmxlLnNpZ25hbHMub24oJ3Vuc2V0JywgZnVuY3Rpb24gKF9yZWY3KSB7XHJcbiAgdmFyIGludGVyYWN0YWJsZSA9IF9yZWY3LmludGVyYWN0YWJsZTtcclxuXHJcbiAgaW50ZXJhY3RhYmxlLmRyb3B6b25lKGZhbHNlKTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGFibGUuc2V0dGluZ3NNZXRob2RzLnB1c2goJ2Ryb3BDaGVja2VyJyk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCduZXcnLCBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcclxuICBpbnRlcmFjdGlvbi5kcm9wVGFyZ2V0ID0gbnVsbDsgLy8gdGhlIGRyb3B6b25lIGEgZHJhZyB0YXJnZXQgbWlnaHQgYmUgZHJvcHBlZCBpbnRvXHJcbiAgaW50ZXJhY3Rpb24uZHJvcEVsZW1lbnQgPSBudWxsOyAvLyB0aGUgZWxlbWVudCBhdCB0aGUgdGltZSBvZiBjaGVja2luZ1xyXG4gIGludGVyYWN0aW9uLnByZXZEcm9wVGFyZ2V0ID0gbnVsbDsgLy8gdGhlIGRyb3B6b25lIHRoYXQgd2FzIHJlY2VudGx5IGRyYWdnZWQgYXdheSBmcm9tXHJcbiAgaW50ZXJhY3Rpb24ucHJldkRyb3BFbGVtZW50ID0gbnVsbDsgLy8gdGhlIGVsZW1lbnQgYXQgdGhlIHRpbWUgb2YgY2hlY2tpbmdcclxuICBpbnRlcmFjdGlvbi5kcm9wRXZlbnRzID0gbnVsbDsgLy8gdGhlIGRyb3BFdmVudHMgcmVsYXRlZCB0byB0aGUgY3VycmVudCBkcmFnIGV2ZW50XHJcblxyXG4gIGludGVyYWN0aW9uLmFjdGl2ZURyb3BzID0ge1xyXG4gICAgZHJvcHpvbmVzOiBbXSwgLy8gdGhlIGRyb3B6b25lcyB0aGF0IGFyZSBtZW50aW9uZWQgYmVsb3dcclxuICAgIGVsZW1lbnRzOiBbXSwgLy8gZWxlbWVudHMgb2YgZHJvcHpvbmVzIHRoYXQgYWNjZXB0IHRoZSB0YXJnZXQgZHJhZ2dhYmxlXHJcbiAgICByZWN0czogW10gLy8gdGhlIHJlY3RzIG9mIHRoZSBlbGVtZW50cyBtZW50aW9uZWQgYWJvdmVcclxuICB9O1xyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ3N0b3AnLCBmdW5jdGlvbiAoX3JlZjgpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmOC5pbnRlcmFjdGlvbjtcclxuXHJcbiAgaW50ZXJhY3Rpb24uZHJvcFRhcmdldCA9IGludGVyYWN0aW9uLmRyb3BFbGVtZW50ID0gaW50ZXJhY3Rpb24ucHJldkRyb3BUYXJnZXQgPSBpbnRlcmFjdGlvbi5wcmV2RHJvcEVsZW1lbnQgPSBudWxsO1xyXG59KTtcclxuXHJcbi8qXFxcclxuICogaW50ZXJhY3QuZHluYW1pY0Ryb3BcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogUmV0dXJucyBvciBzZXRzIHdoZXRoZXIgdGhlIGRpbWVuc2lvbnMgb2YgZHJvcHpvbmUgZWxlbWVudHMgYXJlXHJcbiAqIGNhbGN1bGF0ZWQgb24gZXZlcnkgZHJhZ21vdmUgb3Igb25seSBvbiBkcmFnc3RhcnQgZm9yIHRoZSBkZWZhdWx0XHJcbiAqIGRyb3BDaGVja2VyXHJcbiAqXHJcbiAtIG5ld1ZhbHVlIChib29sZWFuKSAjb3B0aW9uYWwgVHJ1ZSB0byBjaGVjayBvbiBlYWNoIG1vdmUuIEZhbHNlIHRvIGNoZWNrIG9ubHkgYmVmb3JlIHN0YXJ0XHJcbiA9IChib29sZWFuIHwgaW50ZXJhY3QpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgaW50ZXJhY3RcclxuXFwqL1xyXG5pbnRlcmFjdC5keW5hbWljRHJvcCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gIGlmICh1dGlscy5pcy5ib29sKG5ld1ZhbHVlKSkge1xyXG4gICAgLy9pZiAoZHJhZ2dpbmcgJiYgZHluYW1pY0Ryb3AgIT09IG5ld1ZhbHVlICYmICFuZXdWYWx1ZSkge1xyXG4gICAgLy9jYWxjUmVjdHMoZHJvcHpvbmVzKTtcclxuICAgIC8vfVxyXG5cclxuICAgIGR5bmFtaWNEcm9wID0gbmV3VmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIGludGVyYWN0O1xyXG4gIH1cclxuICByZXR1cm4gZHluYW1pY0Ryb3A7XHJcbn07XHJcblxyXG51dGlscy5tZXJnZShJbnRlcmFjdGFibGUuZXZlbnRUeXBlcywgWydkcmFnZW50ZXInLCAnZHJhZ2xlYXZlJywgJ2Ryb3BhY3RpdmF0ZScsICdkcm9wZGVhY3RpdmF0ZScsICdkcm9wbW92ZScsICdkcm9wJ10pO1xyXG5hY3Rpb25zLm1ldGhvZERpY3QuZHJvcCA9ICdkcm9wem9uZSc7XHJcblxyXG5kZWZhdWx0T3B0aW9ucy5kcm9wID0gZHJvcC5kZWZhdWx0cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZHJvcDtcclxuXHJcbn0se1wiLi4vSW50ZXJhY3RFdmVudFwiOjMsXCIuLi9JbnRlcmFjdGFibGVcIjo0LFwiLi4vSW50ZXJhY3Rpb25cIjo1LFwiLi4vZGVmYXVsdE9wdGlvbnNcIjoxOCxcIi4uL2ludGVyYWN0XCI6MjEsXCIuLi9zY29wZVwiOjM0LFwiLi4vdXRpbHNcIjo0NCxcIi4vYmFzZVwiOjZ9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGFjdGlvbnMgPSByZXF1aXJlKCcuL2Jhc2UnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIEludGVyYWN0RXZlbnQgPSByZXF1aXJlKCcuLi9JbnRlcmFjdEV2ZW50Jyk7XHJcbnZhciBJbnRlcmFjdGFibGUgPSByZXF1aXJlKCcuLi9JbnRlcmFjdGFibGUnKTtcclxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi4vSW50ZXJhY3Rpb24nKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxuXHJcbnZhciBnZXN0dXJlID0ge1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgIG9yaWdpbjogbnVsbCxcclxuICAgIHJlc3RyaWN0OiBudWxsXHJcbiAgfSxcclxuXHJcbiAgY2hlY2tlcjogZnVuY3Rpb24gY2hlY2tlcihwb2ludGVyLCBldmVudCwgaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBpbnRlcmFjdGlvbikge1xyXG4gICAgaWYgKGludGVyYWN0aW9uLnBvaW50ZXJJZHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgcmV0dXJuIHsgbmFtZTogJ2dlc3R1cmUnIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuXHJcbiAgZ2V0Q3Vyc29yOiBmdW5jdGlvbiBnZXRDdXJzb3IoKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59O1xyXG5cclxuSW50ZXJhY3RFdmVudC5zaWduYWxzLm9uKCduZXcnLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gIHZhciBpRXZlbnQgPSBfcmVmLmlFdmVudCxcclxuICAgICAgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uO1xyXG5cclxuICBpZiAoaUV2ZW50LnR5cGUgIT09ICdnZXN0dXJlc3RhcnQnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlFdmVudC5kcyA9IDA7XHJcblxyXG4gIGludGVyYWN0aW9uLmdlc3R1cmUuc3RhcnREaXN0YW5jZSA9IGludGVyYWN0aW9uLmdlc3R1cmUucHJldkRpc3RhbmNlID0gaUV2ZW50LmRpc3RhbmNlO1xyXG4gIGludGVyYWN0aW9uLmdlc3R1cmUuc3RhcnRBbmdsZSA9IGludGVyYWN0aW9uLmdlc3R1cmUucHJldkFuZ2xlID0gaUV2ZW50LmFuZ2xlO1xyXG4gIGludGVyYWN0aW9uLmdlc3R1cmUuc2NhbGUgPSAxO1xyXG59KTtcclxuXHJcbkludGVyYWN0RXZlbnQuc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKF9yZWYyKSB7XHJcbiAgdmFyIGlFdmVudCA9IF9yZWYyLmlFdmVudCxcclxuICAgICAgaW50ZXJhY3Rpb24gPSBfcmVmMi5pbnRlcmFjdGlvbjtcclxuXHJcbiAgaWYgKGlFdmVudC50eXBlICE9PSAnZ2VzdHVyZW1vdmUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpRXZlbnQuZHMgPSBpRXZlbnQuc2NhbGUgLSBpbnRlcmFjdGlvbi5nZXN0dXJlLnNjYWxlO1xyXG5cclxuICBpbnRlcmFjdGlvbi50YXJnZXQuZmlyZShpRXZlbnQpO1xyXG5cclxuICBpbnRlcmFjdGlvbi5nZXN0dXJlLnByZXZBbmdsZSA9IGlFdmVudC5hbmdsZTtcclxuICBpbnRlcmFjdGlvbi5nZXN0dXJlLnByZXZEaXN0YW5jZSA9IGlFdmVudC5kaXN0YW5jZTtcclxuXHJcbiAgaWYgKGlFdmVudC5zY2FsZSAhPT0gSW5maW5pdHkgJiYgaUV2ZW50LnNjYWxlICE9PSBudWxsICYmIGlFdmVudC5zY2FsZSAhPT0gdW5kZWZpbmVkICYmICFpc05hTihpRXZlbnQuc2NhbGUpKSB7XHJcblxyXG4gICAgaW50ZXJhY3Rpb24uZ2VzdHVyZS5zY2FsZSA9IGlFdmVudC5zY2FsZTtcclxuICB9XHJcbn0pO1xyXG5cclxuLypcXFxyXG4gKiBJbnRlcmFjdGFibGUuZ2VzdHVyYWJsZVxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBHZXRzIG9yIHNldHMgd2hldGhlciBtdWx0aXRvdWNoIGdlc3R1cmVzIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhlXHJcbiAqIEludGVyYWN0YWJsZSdzIGVsZW1lbnRcclxuICpcclxuID0gKGJvb2xlYW4pIEluZGljYXRlcyBpZiB0aGlzIGNhbiBiZSB0aGUgdGFyZ2V0IG9mIGdlc3R1cmUgZXZlbnRzXHJcbiAgIHwgdmFyIGlzR2VzdHVyZWFibGUgPSBpbnRlcmFjdChlbGVtZW50KS5nZXN0dXJhYmxlKCk7XHJcbiAqIG9yXHJcbiAtIG9wdGlvbnMgKGJvb2xlYW4gfCBvYmplY3QpICNvcHRpb25hbCB0cnVlL2ZhbHNlIG9yIEFuIG9iamVjdCB3aXRoIGV2ZW50IGxpc3RlbmVycyB0byBiZSBmaXJlZCBvbiBnZXN0dXJlIGV2ZW50cyAobWFrZXMgdGhlIEludGVyYWN0YWJsZSBnZXN0dXJhYmxlKVxyXG4gPSAob2JqZWN0KSB0aGlzIEludGVyYWN0YWJsZVxyXG4gfCBpbnRlcmFjdChlbGVtZW50KS5nZXN0dXJhYmxlKHtcclxuIHwgICAgIG9uc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge30sXHJcbiB8ICAgICBvbm1vdmUgOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxyXG4gfCAgICAgb25lbmQgIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcclxuIHxcclxuIHwgICAgIC8vIGxpbWl0IG11bHRpcGxlIGdlc3R1cmVzLlxyXG4gfCAgICAgLy8gU2VlIHRoZSBleHBsYW5hdGlvbiBpbiBASW50ZXJhY3RhYmxlLmRyYWdnYWJsZSBleGFtcGxlXHJcbiB8ICAgICBtYXg6IEluZmluaXR5LFxyXG4gfCAgICAgbWF4UGVyRWxlbWVudDogMSxcclxuIHwgfSk7XHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5nZXN0dXJhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBpZiAodXRpbHMuaXMub2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkID0gb3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcclxuICAgIHRoaXMuc2V0UGVyQWN0aW9uKCdnZXN0dXJlJywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLnNldE9uRXZlbnRzKCdnZXN0dXJlJywgb3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZiAodXRpbHMuaXMuYm9vbChvcHRpb25zKSkge1xyXG4gICAgdGhpcy5vcHRpb25zLmdlc3R1cmUuZW5hYmxlZCA9IG9wdGlvbnM7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMub25nZXN0dXJlc3RhcnQgPSB0aGlzLm9uZ2VzdHVyZXN0YXJ0ID0gdGhpcy5vbmdlc3R1cmVlbmQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5nZXN0dXJlO1xyXG59O1xyXG5cclxuSW50ZXJhY3RFdmVudC5zaWduYWxzLm9uKCdzZXQtZGVsdGEnLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbixcclxuICAgICAgaUV2ZW50ID0gX3JlZjMuaUV2ZW50LFxyXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb24sXHJcbiAgICAgIGV2ZW50ID0gX3JlZjMuZXZlbnQsXHJcbiAgICAgIHN0YXJ0aW5nID0gX3JlZjMuc3RhcnRpbmcsXHJcbiAgICAgIGVuZGluZyA9IF9yZWYzLmVuZGluZyxcclxuICAgICAgZGVsdGFTb3VyY2UgPSBfcmVmMy5kZWx0YVNvdXJjZTtcclxuXHJcbiAgaWYgKGFjdGlvbiAhPT0gJ2dlc3R1cmUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgcG9pbnRlcnMgPSBpbnRlcmFjdGlvbi5wb2ludGVycztcclxuXHJcbiAgaUV2ZW50LnRvdWNoZXMgPSBbcG9pbnRlcnNbMF0sIHBvaW50ZXJzWzFdXTtcclxuXHJcbiAgaWYgKHN0YXJ0aW5nKSB7XHJcbiAgICBpRXZlbnQuZGlzdGFuY2UgPSB1dGlscy50b3VjaERpc3RhbmNlKHBvaW50ZXJzLCBkZWx0YVNvdXJjZSk7XHJcbiAgICBpRXZlbnQuYm94ID0gdXRpbHMudG91Y2hCQm94KHBvaW50ZXJzKTtcclxuICAgIGlFdmVudC5zY2FsZSA9IDE7XHJcbiAgICBpRXZlbnQuZHMgPSAwO1xyXG4gICAgaUV2ZW50LmFuZ2xlID0gdXRpbHMudG91Y2hBbmdsZShwb2ludGVycywgdW5kZWZpbmVkLCBkZWx0YVNvdXJjZSk7XHJcbiAgICBpRXZlbnQuZGEgPSAwO1xyXG4gIH0gZWxzZSBpZiAoZW5kaW5nIHx8IGV2ZW50IGluc3RhbmNlb2YgSW50ZXJhY3RFdmVudCkge1xyXG4gICAgaUV2ZW50LmRpc3RhbmNlID0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LmRpc3RhbmNlO1xyXG4gICAgaUV2ZW50LmJveCA9IGludGVyYWN0aW9uLnByZXZFdmVudC5ib3g7XHJcbiAgICBpRXZlbnQuc2NhbGUgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQuc2NhbGU7XHJcbiAgICBpRXZlbnQuZHMgPSBpRXZlbnQuc2NhbGUgLSAxO1xyXG4gICAgaUV2ZW50LmFuZ2xlID0gaW50ZXJhY3Rpb24ucHJldkV2ZW50LmFuZ2xlO1xyXG4gICAgaUV2ZW50LmRhID0gaUV2ZW50LmFuZ2xlIC0gaW50ZXJhY3Rpb24uZ2VzdHVyZS5zdGFydEFuZ2xlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpRXZlbnQuZGlzdGFuY2UgPSB1dGlscy50b3VjaERpc3RhbmNlKHBvaW50ZXJzLCBkZWx0YVNvdXJjZSk7XHJcbiAgICBpRXZlbnQuYm94ID0gdXRpbHMudG91Y2hCQm94KHBvaW50ZXJzKTtcclxuICAgIGlFdmVudC5zY2FsZSA9IGlFdmVudC5kaXN0YW5jZSAvIGludGVyYWN0aW9uLmdlc3R1cmUuc3RhcnREaXN0YW5jZTtcclxuICAgIGlFdmVudC5hbmdsZSA9IHV0aWxzLnRvdWNoQW5nbGUocG9pbnRlcnMsIGludGVyYWN0aW9uLmdlc3R1cmUucHJldkFuZ2xlLCBkZWx0YVNvdXJjZSk7XHJcblxyXG4gICAgaUV2ZW50LmRzID0gaUV2ZW50LnNjYWxlIC0gaW50ZXJhY3Rpb24uZ2VzdHVyZS5wcmV2U2NhbGU7XHJcbiAgICBpRXZlbnQuZGEgPSBpRXZlbnQuYW5nbGUgLSBpbnRlcmFjdGlvbi5nZXN0dXJlLnByZXZBbmdsZTtcclxuICB9XHJcbn0pO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgaW50ZXJhY3Rpb24uZ2VzdHVyZSA9IHtcclxuICAgIHN0YXJ0OiB7IHg6IDAsIHk6IDAgfSxcclxuXHJcbiAgICBzdGFydERpc3RhbmNlOiAwLCAvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzIG9mIHRvdWNoU3RhcnRcclxuICAgIHByZXZEaXN0YW5jZTogMCxcclxuICAgIGRpc3RhbmNlOiAwLFxyXG5cclxuICAgIHNjYWxlOiAxLCAvLyBnZXN0dXJlLmRpc3RhbmNlIC8gZ2VzdHVyZS5zdGFydERpc3RhbmNlXHJcblxyXG4gICAgc3RhcnRBbmdsZTogMCwgLy8gYW5nbGUgb2YgbGluZSBqb2luaW5nIHR3byB0b3VjaGVzXHJcbiAgICBwcmV2QW5nbGU6IDAgLy8gYW5nbGUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUgZXZlbnRcclxuICB9O1xyXG59KTtcclxuXHJcbmFjdGlvbnMuZ2VzdHVyZSA9IGdlc3R1cmU7XHJcbmFjdGlvbnMubmFtZXMucHVzaCgnZ2VzdHVyZScpO1xyXG51dGlscy5tZXJnZShJbnRlcmFjdGFibGUuZXZlbnRUeXBlcywgWydnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZW1vdmUnLCAnZ2VzdHVyZWVuZCddKTtcclxuYWN0aW9ucy5tZXRob2REaWN0Lmdlc3R1cmUgPSAnZ2VzdHVyYWJsZSc7XHJcblxyXG5kZWZhdWx0T3B0aW9ucy5nZXN0dXJlID0gZ2VzdHVyZS5kZWZhdWx0cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2VzdHVyZTtcclxuXHJcbn0se1wiLi4vSW50ZXJhY3RFdmVudFwiOjMsXCIuLi9JbnRlcmFjdGFibGVcIjo0LFwiLi4vSW50ZXJhY3Rpb25cIjo1LFwiLi4vZGVmYXVsdE9wdGlvbnNcIjoxOCxcIi4uL3V0aWxzXCI6NDQsXCIuL2Jhc2VcIjo2fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYWN0aW9ucyA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKTtcclxudmFyIEludGVyYWN0RXZlbnQgPSByZXF1aXJlKCcuLi9JbnRlcmFjdEV2ZW50Jyk7XHJcbnZhciBJbnRlcmFjdGFibGUgPSByZXF1aXJlKCcuLi9JbnRlcmFjdGFibGUnKTtcclxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi4vSW50ZXJhY3Rpb24nKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxuXHJcbi8vIExlc3MgUHJlY2lzaW9uIHdpdGggdG91Y2ggaW5wdXRcclxudmFyIGRlZmF1bHRNYXJnaW4gPSBicm93c2VyLnN1cHBvcnRzVG91Y2ggfHwgYnJvd3Nlci5zdXBwb3J0c1BvaW50ZXJFdmVudCA/IDIwIDogMTA7XHJcblxyXG52YXIgcmVzaXplID0ge1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgIG1vdXNlQnV0dG9uczogbnVsbCxcclxuXHJcbiAgICBvcmlnaW46IG51bGwsXHJcbiAgICBzbmFwOiBudWxsLFxyXG4gICAgcmVzdHJpY3Q6IG51bGwsXHJcbiAgICBpbmVydGlhOiBudWxsLFxyXG4gICAgYXV0b1Njcm9sbDogbnVsbCxcclxuXHJcbiAgICBzcXVhcmU6IGZhbHNlLFxyXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICBheGlzOiAneHknLFxyXG5cclxuICAgIC8vIHVzZSBkZWZhdWx0IG1hcmdpblxyXG4gICAgbWFyZ2luOiBOYU4sXHJcblxyXG4gICAgLy8gb2JqZWN0IHdpdGggcHJvcHMgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIHdoaWNoIGFyZVxyXG4gICAgLy8gdHJ1ZS9mYWxzZSB2YWx1ZXMgdG8gcmVzaXplIHdoZW4gdGhlIHBvaW50ZXIgaXMgb3ZlciB0aGF0IGVkZ2UsXHJcbiAgICAvLyBDU1Mgc2VsZWN0b3JzIHRvIG1hdGNoIHRoZSBoYW5kbGVzIGZvciBlYWNoIGRpcmVjdGlvblxyXG4gICAgLy8gb3IgdGhlIEVsZW1lbnRzIGZvciBlYWNoIGhhbmRsZVxyXG4gICAgZWRnZXM6IG51bGwsXHJcblxyXG4gICAgLy8gYSB2YWx1ZSBvZiAnbm9uZScgd2lsbCBsaW1pdCB0aGUgcmVzaXplIHJlY3QgdG8gYSBtaW5pbXVtIG9mIDB4MFxyXG4gICAgLy8gJ25lZ2F0ZScgd2lsbCBhbG93IHRoZSByZWN0IHRvIGhhdmUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0XHJcbiAgICAvLyAncmVwb3NpdGlvbicgd2lsbCBrZWVwIHRoZSB3aWR0aC9oZWlnaHQgcG9zaXRpdmUgYnkgc3dhcHBpbmdcclxuICAgIC8vIHRoZSB0b3AgYW5kIGJvdHRvbSBlZGdlcyBhbmQvb3Igc3dhcHBpbmcgdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzXHJcbiAgICBpbnZlcnQ6ICdub25lJ1xyXG4gIH0sXHJcblxyXG4gIGNoZWNrZXI6IGZ1bmN0aW9uIGNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGludGVyYWN0YWJsZSwgZWxlbWVudCwgaW50ZXJhY3Rpb24sIHJlY3QpIHtcclxuICAgIGlmICghcmVjdCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFnZSA9IHV0aWxzLmV4dGVuZCh7fSwgaW50ZXJhY3Rpb24uY3VyQ29vcmRzLnBhZ2UpO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBpbnRlcmFjdGFibGUub3B0aW9ucztcclxuXHJcbiAgICBpZiAob3B0aW9ucy5yZXNpemUuZW5hYmxlZCkge1xyXG4gICAgICB2YXIgcmVzaXplT3B0aW9ucyA9IG9wdGlvbnMucmVzaXplO1xyXG4gICAgICB2YXIgcmVzaXplRWRnZXMgPSB7IGxlZnQ6IGZhbHNlLCByaWdodDogZmFsc2UsIHRvcDogZmFsc2UsIGJvdHRvbTogZmFsc2UgfTtcclxuXHJcbiAgICAgIC8vIGlmIHVzaW5nIHJlc2l6ZS5lZGdlc1xyXG4gICAgICBpZiAodXRpbHMuaXMub2JqZWN0KHJlc2l6ZU9wdGlvbnMuZWRnZXMpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgZWRnZSBpbiByZXNpemVFZGdlcykge1xyXG4gICAgICAgICAgcmVzaXplRWRnZXNbZWRnZV0gPSBjaGVja1Jlc2l6ZUVkZ2UoZWRnZSwgcmVzaXplT3B0aW9ucy5lZGdlc1tlZGdlXSwgcGFnZSwgaW50ZXJhY3Rpb24uX2V2ZW50VGFyZ2V0LCBlbGVtZW50LCByZWN0LCByZXNpemVPcHRpb25zLm1hcmdpbiB8fCBkZWZhdWx0TWFyZ2luKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc2l6ZUVkZ2VzLmxlZnQgPSByZXNpemVFZGdlcy5sZWZ0ICYmICFyZXNpemVFZGdlcy5yaWdodDtcclxuICAgICAgICByZXNpemVFZGdlcy50b3AgPSByZXNpemVFZGdlcy50b3AgJiYgIXJlc2l6ZUVkZ2VzLmJvdHRvbTtcclxuXHJcbiAgICAgICAgaWYgKHJlc2l6ZUVkZ2VzLmxlZnQgfHwgcmVzaXplRWRnZXMucmlnaHQgfHwgcmVzaXplRWRnZXMudG9wIHx8IHJlc2l6ZUVkZ2VzLmJvdHRvbSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogJ3Jlc2l6ZScsXHJcbiAgICAgICAgICAgIGVkZ2VzOiByZXNpemVFZGdlc1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gb3B0aW9ucy5yZXNpemUuYXhpcyAhPT0gJ3knICYmIHBhZ2UueCA+IHJlY3QucmlnaHQgLSBkZWZhdWx0TWFyZ2luO1xyXG4gICAgICAgIHZhciBib3R0b20gPSBvcHRpb25zLnJlc2l6ZS5heGlzICE9PSAneCcgJiYgcGFnZS55ID4gcmVjdC5ib3R0b20gLSBkZWZhdWx0TWFyZ2luO1xyXG5cclxuICAgICAgICBpZiAocmlnaHQgfHwgYm90dG9tKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiAncmVzaXplJyxcclxuICAgICAgICAgICAgYXhlczogKHJpZ2h0ID8gJ3gnIDogJycpICsgKGJvdHRvbSA/ICd5JyA6ICcnKVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9LFxyXG5cclxuICBjdXJzb3JzOiBicm93c2VyLmlzSWU5T3JPbGRlciA/IHtcclxuICAgIHg6ICdlLXJlc2l6ZScsXHJcbiAgICB5OiAncy1yZXNpemUnLFxyXG4gICAgeHk6ICdzZS1yZXNpemUnLFxyXG5cclxuICAgIHRvcDogJ24tcmVzaXplJyxcclxuICAgIGxlZnQ6ICd3LXJlc2l6ZScsXHJcbiAgICBib3R0b206ICdzLXJlc2l6ZScsXHJcbiAgICByaWdodDogJ2UtcmVzaXplJyxcclxuICAgIHRvcGxlZnQ6ICdzZS1yZXNpemUnLFxyXG4gICAgYm90dG9tcmlnaHQ6ICdzZS1yZXNpemUnLFxyXG4gICAgdG9wcmlnaHQ6ICduZS1yZXNpemUnLFxyXG4gICAgYm90dG9tbGVmdDogJ25lLXJlc2l6ZSdcclxuICB9IDoge1xyXG4gICAgeDogJ2V3LXJlc2l6ZScsXHJcbiAgICB5OiAnbnMtcmVzaXplJyxcclxuICAgIHh5OiAnbndzZS1yZXNpemUnLFxyXG5cclxuICAgIHRvcDogJ25zLXJlc2l6ZScsXHJcbiAgICBsZWZ0OiAnZXctcmVzaXplJyxcclxuICAgIGJvdHRvbTogJ25zLXJlc2l6ZScsXHJcbiAgICByaWdodDogJ2V3LXJlc2l6ZScsXHJcbiAgICB0b3BsZWZ0OiAnbndzZS1yZXNpemUnLFxyXG4gICAgYm90dG9tcmlnaHQ6ICdud3NlLXJlc2l6ZScsXHJcbiAgICB0b3ByaWdodDogJ25lc3ctcmVzaXplJyxcclxuICAgIGJvdHRvbWxlZnQ6ICduZXN3LXJlc2l6ZSdcclxuICB9LFxyXG5cclxuICBnZXRDdXJzb3I6IGZ1bmN0aW9uIGdldEN1cnNvcihhY3Rpb24pIHtcclxuICAgIGlmIChhY3Rpb24uYXhpcykge1xyXG4gICAgICByZXR1cm4gcmVzaXplLmN1cnNvcnNbYWN0aW9uLm5hbWUgKyBhY3Rpb24uYXhpc107XHJcbiAgICB9IGVsc2UgaWYgKGFjdGlvbi5lZGdlcykge1xyXG4gICAgICB2YXIgY3Vyc29yS2V5ID0gJyc7XHJcbiAgICAgIHZhciBlZGdlTmFtZXMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICBpZiAoYWN0aW9uLmVkZ2VzW2VkZ2VOYW1lc1tpXV0pIHtcclxuICAgICAgICAgIGN1cnNvcktleSArPSBlZGdlTmFtZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzaXplLmN1cnNvcnNbY3Vyc29yS2V5XTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyByZXNpemVzdGFydFxyXG5JbnRlcmFjdEV2ZW50LnNpZ25hbHMub24oJ25ldycsIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgdmFyIGlFdmVudCA9IF9yZWYuaUV2ZW50LFxyXG4gICAgICBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb247XHJcblxyXG4gIGlmIChpRXZlbnQudHlwZSAhPT0gJ3Jlc2l6ZXN0YXJ0JyB8fCAhaW50ZXJhY3Rpb24ucHJlcGFyZWQuZWRnZXMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBzdGFydFJlY3QgPSBpbnRlcmFjdGlvbi50YXJnZXQuZ2V0UmVjdChpbnRlcmFjdGlvbi5lbGVtZW50KTtcclxuICB2YXIgcmVzaXplT3B0aW9ucyA9IGludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zLnJlc2l6ZTtcclxuXHJcbiAgLypcclxuICAgKiBXaGVuIHVzaW5nIHRoZSBgcmVzaXphYmxlLnNxdWFyZWAgb3IgYHJlc2l6YWJsZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvYCBvcHRpb25zLCByZXNpemluZyBmcm9tIG9uZSBlZGdlXHJcbiAgICogd2lsbCBhZmZlY3QgYW5vdGhlci4gRS5nLiB3aXRoIGByZXNpemFibGUuc3F1YXJlYCwgcmVzaXppbmcgdG8gbWFrZSB0aGUgcmlnaHQgZWRnZSBsYXJnZXIgd2lsbCBtYWtlXHJcbiAgICogdGhlIGJvdHRvbSBlZGdlIGxhcmdlciBieSB0aGUgc2FtZSBhbW91bnQuIFdlIGNhbGwgdGhlc2UgJ2xpbmtlZCcgZWRnZXMuIEFueSBsaW5rZWQgZWRnZXMgd2lsbCBkZXBlbmRcclxuICAgKiBvbiB0aGUgYWN0aXZlIGVkZ2VzIGFuZCB0aGUgZWRnZSBiZWluZyBpbnRlcmFjdGVkIHdpdGguXHJcbiAgICovXHJcbiAgaWYgKHJlc2l6ZU9wdGlvbnMuc3F1YXJlIHx8IHJlc2l6ZU9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbykge1xyXG4gICAgdmFyIGxpbmtlZEVkZ2VzID0gdXRpbHMuZXh0ZW5kKHt9LCBpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcyk7XHJcblxyXG4gICAgbGlua2VkRWRnZXMudG9wID0gbGlua2VkRWRnZXMudG9wIHx8IGxpbmtlZEVkZ2VzLmxlZnQgJiYgIWxpbmtlZEVkZ2VzLmJvdHRvbTtcclxuICAgIGxpbmtlZEVkZ2VzLmxlZnQgPSBsaW5rZWRFZGdlcy5sZWZ0IHx8IGxpbmtlZEVkZ2VzLnRvcCAmJiAhbGlua2VkRWRnZXMucmlnaHQ7XHJcbiAgICBsaW5rZWRFZGdlcy5ib3R0b20gPSBsaW5rZWRFZGdlcy5ib3R0b20gfHwgbGlua2VkRWRnZXMucmlnaHQgJiYgIWxpbmtlZEVkZ2VzLnRvcDtcclxuICAgIGxpbmtlZEVkZ2VzLnJpZ2h0ID0gbGlua2VkRWRnZXMucmlnaHQgfHwgbGlua2VkRWRnZXMuYm90dG9tICYmICFsaW5rZWRFZGdlcy5sZWZ0O1xyXG5cclxuICAgIGludGVyYWN0aW9uLnByZXBhcmVkLl9saW5rZWRFZGdlcyA9IGxpbmtlZEVkZ2VzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbnRlcmFjdGlvbi5wcmVwYXJlZC5fbGlua2VkRWRnZXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYgdXNpbmcgYHJlc2l6YWJsZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvYCBvcHRpb24sIHJlY29yZCBhc3BlY3QgcmF0aW8gYXQgdGhlIHN0YXJ0IG9mIHRoZSByZXNpemVcclxuICBpZiAocmVzaXplT3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XHJcbiAgICBpbnRlcmFjdGlvbi5yZXNpemVTdGFydEFzcGVjdFJhdGlvID0gc3RhcnRSZWN0LndpZHRoIC8gc3RhcnRSZWN0LmhlaWdodDtcclxuICB9XHJcblxyXG4gIGludGVyYWN0aW9uLnJlc2l6ZVJlY3RzID0ge1xyXG4gICAgc3RhcnQ6IHN0YXJ0UmVjdCxcclxuICAgIGN1cnJlbnQ6IHV0aWxzLmV4dGVuZCh7fSwgc3RhcnRSZWN0KSxcclxuICAgIGludmVydGVkOiB1dGlscy5leHRlbmQoe30sIHN0YXJ0UmVjdCksXHJcbiAgICBwcmV2aW91czogdXRpbHMuZXh0ZW5kKHt9LCBzdGFydFJlY3QpLFxyXG4gICAgZGVsdGE6IHtcclxuICAgICAgbGVmdDogMCwgcmlnaHQ6IDAsIHdpZHRoOiAwLFxyXG4gICAgICB0b3A6IDAsIGJvdHRvbTogMCwgaGVpZ2h0OiAwXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgaUV2ZW50LnJlY3QgPSBpbnRlcmFjdGlvbi5yZXNpemVSZWN0cy5pbnZlcnRlZDtcclxuICBpRXZlbnQuZGVsdGFSZWN0ID0gaW50ZXJhY3Rpb24ucmVzaXplUmVjdHMuZGVsdGE7XHJcbn0pO1xyXG5cclxuLy8gcmVzaXplbW92ZVxyXG5JbnRlcmFjdEV2ZW50LnNpZ25hbHMub24oJ25ldycsIGZ1bmN0aW9uIChfcmVmMikge1xyXG4gIHZhciBpRXZlbnQgPSBfcmVmMi5pRXZlbnQsXHJcbiAgICAgIHBoYXNlID0gX3JlZjIucGhhc2UsXHJcbiAgICAgIGludGVyYWN0aW9uID0gX3JlZjIuaW50ZXJhY3Rpb247XHJcblxyXG4gIGlmIChwaGFzZSAhPT0gJ21vdmUnIHx8ICFpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlc2l6ZU9wdGlvbnMgPSBpbnRlcmFjdGlvbi50YXJnZXQub3B0aW9ucy5yZXNpemU7XHJcbiAgdmFyIGludmVydCA9IHJlc2l6ZU9wdGlvbnMuaW52ZXJ0O1xyXG4gIHZhciBpbnZlcnRpYmxlID0gaW52ZXJ0ID09PSAncmVwb3NpdGlvbicgfHwgaW52ZXJ0ID09PSAnbmVnYXRlJztcclxuXHJcbiAgdmFyIGVkZ2VzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQuZWRnZXM7XHJcblxyXG4gIHZhciBzdGFydCA9IGludGVyYWN0aW9uLnJlc2l6ZVJlY3RzLnN0YXJ0O1xyXG4gIHZhciBjdXJyZW50ID0gaW50ZXJhY3Rpb24ucmVzaXplUmVjdHMuY3VycmVudDtcclxuICB2YXIgaW52ZXJ0ZWQgPSBpbnRlcmFjdGlvbi5yZXNpemVSZWN0cy5pbnZlcnRlZDtcclxuICB2YXIgZGVsdGEgPSBpbnRlcmFjdGlvbi5yZXNpemVSZWN0cy5kZWx0YTtcclxuICB2YXIgcHJldmlvdXMgPSB1dGlscy5leHRlbmQoaW50ZXJhY3Rpb24ucmVzaXplUmVjdHMucHJldmlvdXMsIGludmVydGVkKTtcclxuICB2YXIgb3JpZ2luYWxFZGdlcyA9IGVkZ2VzO1xyXG5cclxuICB2YXIgZHggPSBpRXZlbnQuZHg7XHJcbiAgdmFyIGR5ID0gaUV2ZW50LmR5O1xyXG5cclxuICBpZiAocmVzaXplT3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8IHJlc2l6ZU9wdGlvbnMuc3F1YXJlKSB7XHJcbiAgICAvLyBgcmVzaXplLnByZXNlcnZlQXNwZWN0UmF0aW9gIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgcmVzaXplLnNxdWFyZWBcclxuICAgIHZhciBzdGFydEFzcGVjdFJhdGlvID0gcmVzaXplT3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID8gaW50ZXJhY3Rpb24ucmVzaXplU3RhcnRBc3BlY3RSYXRpbyA6IDE7XHJcblxyXG4gICAgZWRnZXMgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5fbGlua2VkRWRnZXM7XHJcblxyXG4gICAgaWYgKG9yaWdpbmFsRWRnZXMubGVmdCAmJiBvcmlnaW5hbEVkZ2VzLmJvdHRvbSB8fCBvcmlnaW5hbEVkZ2VzLnJpZ2h0ICYmIG9yaWdpbmFsRWRnZXMudG9wKSB7XHJcbiAgICAgIGR5ID0gLWR4IC8gc3RhcnRBc3BlY3RSYXRpbztcclxuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxFZGdlcy5sZWZ0IHx8IG9yaWdpbmFsRWRnZXMucmlnaHQpIHtcclxuICAgICAgZHkgPSBkeCAvIHN0YXJ0QXNwZWN0UmF0aW87XHJcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRWRnZXMudG9wIHx8IG9yaWdpbmFsRWRnZXMuYm90dG9tKSB7XHJcbiAgICAgIGR4ID0gZHkgKiBzdGFydEFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gdXBkYXRlIHRoZSAnY3VycmVudCcgcmVjdCB3aXRob3V0IG1vZGlmaWNhdGlvbnNcclxuICBpZiAoZWRnZXMudG9wKSB7XHJcbiAgICBjdXJyZW50LnRvcCArPSBkeTtcclxuICB9XHJcbiAgaWYgKGVkZ2VzLmJvdHRvbSkge1xyXG4gICAgY3VycmVudC5ib3R0b20gKz0gZHk7XHJcbiAgfVxyXG4gIGlmIChlZGdlcy5sZWZ0KSB7XHJcbiAgICBjdXJyZW50LmxlZnQgKz0gZHg7XHJcbiAgfVxyXG4gIGlmIChlZGdlcy5yaWdodCkge1xyXG4gICAgY3VycmVudC5yaWdodCArPSBkeDtcclxuICB9XHJcblxyXG4gIGlmIChpbnZlcnRpYmxlKSB7XHJcbiAgICAvLyBpZiBpbnZlcnRpYmxlLCBjb3B5IHRoZSBjdXJyZW50IHJlY3RcclxuICAgIHV0aWxzLmV4dGVuZChpbnZlcnRlZCwgY3VycmVudCk7XHJcblxyXG4gICAgaWYgKGludmVydCA9PT0gJ3JlcG9zaXRpb24nKSB7XHJcbiAgICAgIC8vIHN3YXAgZWRnZSB2YWx1ZXMgaWYgbmVjZXNzYXJ5IHRvIGtlZXAgd2lkdGgvaGVpZ2h0IHBvc2l0aXZlXHJcbiAgICAgIHZhciBzd2FwID0gdm9pZCAwO1xyXG5cclxuICAgICAgaWYgKGludmVydGVkLnRvcCA+IGludmVydGVkLmJvdHRvbSkge1xyXG4gICAgICAgIHN3YXAgPSBpbnZlcnRlZC50b3A7XHJcblxyXG4gICAgICAgIGludmVydGVkLnRvcCA9IGludmVydGVkLmJvdHRvbTtcclxuICAgICAgICBpbnZlcnRlZC5ib3R0b20gPSBzd2FwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnZlcnRlZC5sZWZ0ID4gaW52ZXJ0ZWQucmlnaHQpIHtcclxuICAgICAgICBzd2FwID0gaW52ZXJ0ZWQubGVmdDtcclxuXHJcbiAgICAgICAgaW52ZXJ0ZWQubGVmdCA9IGludmVydGVkLnJpZ2h0O1xyXG4gICAgICAgIGludmVydGVkLnJpZ2h0ID0gc3dhcDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpZiBub3QgaW52ZXJ0aWJsZSwgcmVzdHJpY3QgdG8gbWluaW11bSBvZiAweDAgcmVjdFxyXG4gICAgaW52ZXJ0ZWQudG9wID0gTWF0aC5taW4oY3VycmVudC50b3AsIHN0YXJ0LmJvdHRvbSk7XHJcbiAgICBpbnZlcnRlZC5ib3R0b20gPSBNYXRoLm1heChjdXJyZW50LmJvdHRvbSwgc3RhcnQudG9wKTtcclxuICAgIGludmVydGVkLmxlZnQgPSBNYXRoLm1pbihjdXJyZW50LmxlZnQsIHN0YXJ0LnJpZ2h0KTtcclxuICAgIGludmVydGVkLnJpZ2h0ID0gTWF0aC5tYXgoY3VycmVudC5yaWdodCwgc3RhcnQubGVmdCk7XHJcbiAgfVxyXG5cclxuICBpbnZlcnRlZC53aWR0aCA9IGludmVydGVkLnJpZ2h0IC0gaW52ZXJ0ZWQubGVmdDtcclxuICBpbnZlcnRlZC5oZWlnaHQgPSBpbnZlcnRlZC5ib3R0b20gLSBpbnZlcnRlZC50b3A7XHJcblxyXG4gIGZvciAodmFyIGVkZ2UgaW4gaW52ZXJ0ZWQpIHtcclxuICAgIGRlbHRhW2VkZ2VdID0gaW52ZXJ0ZWRbZWRnZV0gLSBwcmV2aW91c1tlZGdlXTtcclxuICB9XHJcblxyXG4gIGlFdmVudC5lZGdlcyA9IGludGVyYWN0aW9uLnByZXBhcmVkLmVkZ2VzO1xyXG4gIGlFdmVudC5yZWN0ID0gaW52ZXJ0ZWQ7XHJcbiAgaUV2ZW50LmRlbHRhUmVjdCA9IGRlbHRhO1xyXG59KTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLnJlc2l6YWJsZVxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBHZXRzIG9yIHNldHMgd2hldGhlciByZXNpemUgYWN0aW9ucyBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoZVxyXG4gKiBJbnRlcmFjdGFibGVcclxuICpcclxuID0gKGJvb2xlYW4pIEluZGljYXRlcyBpZiB0aGlzIGNhbiBiZSB0aGUgdGFyZ2V0IG9mIHJlc2l6ZSBlbGVtZW50c1xyXG4gICB8IHZhciBpc1Jlc2l6ZWFibGUgPSBpbnRlcmFjdCgnaW5wdXRbdHlwZT10ZXh0XScpLnJlc2l6YWJsZSgpO1xyXG4gKiBvclxyXG4gLSBvcHRpb25zIChib29sZWFuIHwgb2JqZWN0KSAjb3B0aW9uYWwgdHJ1ZS9mYWxzZSBvciBBbiBvYmplY3Qgd2l0aCBldmVudCBsaXN0ZW5lcnMgdG8gYmUgZmlyZWQgb24gcmVzaXplIGV2ZW50cyAob2JqZWN0IG1ha2VzIHRoZSBJbnRlcmFjdGFibGUgcmVzaXphYmxlKVxyXG4gPSAob2JqZWN0KSBUaGlzIEludGVyYWN0YWJsZVxyXG4gICB8IGludGVyYWN0KGVsZW1lbnQpLnJlc2l6YWJsZSh7XHJcbiAgIHwgICBvbnN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxyXG4gICB8ICAgb25tb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcclxuICAgfCAgIG9uZW5kICA6IGZ1bmN0aW9uIChldmVudCkge30sXHJcbiAgIHxcclxuICAgfCAgIGVkZ2VzOiB7XHJcbiAgIHwgICAgIHRvcCAgIDogdHJ1ZSwgICAgICAgLy8gVXNlIHBvaW50ZXIgY29vcmRzIHRvIGNoZWNrIGZvciByZXNpemUuXHJcbiAgIHwgICAgIGxlZnQgIDogZmFsc2UsICAgICAgLy8gRGlzYWJsZSByZXNpemluZyBmcm9tIGxlZnQgZWRnZS5cclxuICAgfCAgICAgYm90dG9tOiAnLnJlc2l6ZS1zJywvLyBSZXNpemUgaWYgcG9pbnRlciB0YXJnZXQgbWF0Y2hlcyBzZWxlY3RvclxyXG4gICB8ICAgICByaWdodCA6IGhhbmRsZUVsICAgIC8vIFJlc2l6ZSBpZiBwb2ludGVyIHRhcmdldCBpcyB0aGUgZ2l2ZW4gRWxlbWVudFxyXG4gICB8ICAgfSxcclxuICAgfFxyXG4gICB8ICAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBhZGp1c3RlZCBpbmRlcGVuZGVudGx5LiBXaGVuIGB0cnVlYCwgd2lkdGggYW5kXHJcbiAgIHwgICAgIC8vIGhlaWdodCBhcmUgYWRqdXN0ZWQgYXQgYSAxOjEgcmF0aW8uXHJcbiAgIHwgICAgIHNxdWFyZTogZmFsc2UsXHJcbiAgIHxcclxuICAgfCAgICAgLy8gV2lkdGggYW5kIGhlaWdodCBjYW4gYmUgYWRqdXN0ZWQgaW5kZXBlbmRlbnRseS4gV2hlbiBgdHJ1ZWAsIHdpZHRoIGFuZFxyXG4gICB8ICAgICAvLyBoZWlnaHQgbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpbyB0aGV5IGhhZCB3aGVuIHJlc2l6aW5nIHN0YXJ0ZWQuXHJcbiAgIHwgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4gICB8XHJcbiAgIHwgICAvLyBhIHZhbHVlIG9mICdub25lJyB3aWxsIGxpbWl0IHRoZSByZXNpemUgcmVjdCB0byBhIG1pbmltdW0gb2YgMHgwXHJcbiAgIHwgICAvLyAnbmVnYXRlJyB3aWxsIGFsbG93IHRoZSByZWN0IHRvIGhhdmUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0XHJcbiAgIHwgICAvLyAncmVwb3NpdGlvbicgd2lsbCBrZWVwIHRoZSB3aWR0aC9oZWlnaHQgcG9zaXRpdmUgYnkgc3dhcHBpbmdcclxuICAgfCAgIC8vIHRoZSB0b3AgYW5kIGJvdHRvbSBlZGdlcyBhbmQvb3Igc3dhcHBpbmcgdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2VzXHJcbiAgIHwgICBpbnZlcnQ6ICdub25lJyB8fCAnbmVnYXRlJyB8fCAncmVwb3NpdGlvbidcclxuICAgfFxyXG4gICB8ICAgLy8gbGltaXQgbXVsdGlwbGUgcmVzaXplcy5cclxuICAgfCAgIC8vIFNlZSB0aGUgZXhwbGFuYXRpb24gaW4gdGhlIEBJbnRlcmFjdGFibGUuZHJhZ2dhYmxlIGV4YW1wbGVcclxuICAgfCAgIG1heDogSW5maW5pdHksXHJcbiAgIHwgICBtYXhQZXJFbGVtZW50OiAxLFxyXG4gICB8IH0pO1xyXG4gIFxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5yZXNpemFibGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIGlmICh1dGlscy5pcy5vYmplY3Qob3B0aW9ucykpIHtcclxuICAgIHRoaXMub3B0aW9ucy5yZXNpemUuZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XHJcbiAgICB0aGlzLnNldFBlckFjdGlvbigncmVzaXplJywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLnNldE9uRXZlbnRzKCdyZXNpemUnLCBvcHRpb25zKTtcclxuXHJcbiAgICBpZiAoL154JHxeeSR8Xnh5JC8udGVzdChvcHRpb25zLmF4aXMpKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5yZXNpemUuYXhpcyA9IG9wdGlvbnMuYXhpcztcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5heGlzID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5yZXNpemUuYXhpcyA9IGRlZmF1bHRPcHRpb25zLnJlc2l6ZS5heGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1dGlscy5pcy5ib29sKG9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbykpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5wcmVzZXJ2ZUFzcGVjdFJhdGlvID0gb3B0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvO1xyXG4gICAgfSBlbHNlIGlmICh1dGlscy5pcy5ib29sKG9wdGlvbnMuc3F1YXJlKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMucmVzaXplLnNxdWFyZSA9IG9wdGlvbnMuc3F1YXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBpZiAodXRpbHMuaXMuYm9vbChvcHRpb25zKSkge1xyXG4gICAgdGhpcy5vcHRpb25zLnJlc2l6ZS5lbmFibGVkID0gb3B0aW9ucztcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgdGhpcy5vbnJlc2l6ZXN0YXJ0ID0gdGhpcy5vbnJlc2l6ZXN0YXJ0ID0gdGhpcy5vbnJlc2l6ZWVuZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzLm9wdGlvbnMucmVzaXplO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tSZXNpemVFZGdlKG5hbWUsIHZhbHVlLCBwYWdlLCBlbGVtZW50LCBpbnRlcmFjdGFibGVFbGVtZW50LCByZWN0LCBtYXJnaW4pIHtcclxuICAvLyBmYWxzZSwgJycsIHVuZGVmaW5lZCwgbnVsbFxyXG4gIGlmICghdmFsdWUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIHRydWUgdmFsdWUsIHVzZSBwb2ludGVyIGNvb3JkcyBhbmQgZWxlbWVudCByZWN0XHJcbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAvLyBpZiBkaW1lbnNpb25zIGFyZSBuZWdhdGl2ZSwgXCJzd2l0Y2hcIiBlZGdlc1xyXG4gICAgdmFyIHdpZHRoID0gdXRpbHMuaXMubnVtYmVyKHJlY3Qud2lkdGgpID8gcmVjdC53aWR0aCA6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdXRpbHMuaXMubnVtYmVyKHJlY3QuaGVpZ2h0KSA/IHJlY3QuaGVpZ2h0IDogcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcclxuXHJcbiAgICBpZiAod2lkdGggPCAwKSB7XHJcbiAgICAgIGlmIChuYW1lID09PSAnbGVmdCcpIHtcclxuICAgICAgICBuYW1lID0gJ3JpZ2h0JztcclxuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgbmFtZSA9ICdsZWZ0JztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhlaWdodCA8IDApIHtcclxuICAgICAgaWYgKG5hbWUgPT09ICd0b3AnKSB7XHJcbiAgICAgICAgbmFtZSA9ICdib3R0b20nO1xyXG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgbmFtZSA9ICd0b3AnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hbWUgPT09ICdsZWZ0Jykge1xyXG4gICAgICByZXR1cm4gcGFnZS54IDwgKHdpZHRoID49IDAgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSArIG1hcmdpbjtcclxuICAgIH1cclxuICAgIGlmIChuYW1lID09PSAndG9wJykge1xyXG4gICAgICByZXR1cm4gcGFnZS55IDwgKGhlaWdodCA+PSAwID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbSkgKyBtYXJnaW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hbWUgPT09ICdyaWdodCcpIHtcclxuICAgICAgcmV0dXJuIHBhZ2UueCA+ICh3aWR0aCA+PSAwID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBtYXJnaW47XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgcmV0dXJuIHBhZ2UueSA+IChoZWlnaHQgPj0gMCA/IHJlY3QuYm90dG9tIDogcmVjdC50b3ApIC0gbWFyZ2luO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gdGhlIHJlbWFpbmluZyBjaGVja3MgcmVxdWlyZSBhbiBlbGVtZW50XHJcbiAgaWYgKCF1dGlscy5pcy5lbGVtZW50KGVsZW1lbnQpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdXRpbHMuaXMuZWxlbWVudCh2YWx1ZSlcclxuICAvLyB0aGUgdmFsdWUgaXMgYW4gZWxlbWVudCB0byB1c2UgYXMgYSByZXNpemUgaGFuZGxlXHJcbiAgPyB2YWx1ZSA9PT0gZWxlbWVudFxyXG4gIC8vIG90aGVyd2lzZSBjaGVjayBpZiBlbGVtZW50IG1hdGNoZXMgdmFsdWUgYXMgc2VsZWN0b3JcclxuICA6IHV0aWxzLm1hdGNoZXNVcFRvKGVsZW1lbnQsIHZhbHVlLCBpbnRlcmFjdGFibGVFbGVtZW50KTtcclxufVxyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9ICd4eSc7XHJcbn0pO1xyXG5cclxuSW50ZXJhY3RFdmVudC5zaWduYWxzLm9uKCdzZXQtZGVsdGEnLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbixcclxuICAgICAgaUV2ZW50ID0gX3JlZjMuaUV2ZW50LFxyXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XHJcblxyXG4gIGlmIChhY3Rpb24gIT09ICdyZXNpemUnIHx8ICFpbnRlcmFjdGlvbi5yZXNpemVBeGVzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgb3B0aW9ucyA9IGludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zO1xyXG5cclxuICBpZiAob3B0aW9ucy5yZXNpemUuc3F1YXJlKSB7XHJcbiAgICBpZiAoaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9PT0gJ3knKSB7XHJcbiAgICAgIGlFdmVudC5keCA9IGlFdmVudC5keTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlFdmVudC5keSA9IGlFdmVudC5keDtcclxuICAgIH1cclxuICAgIGlFdmVudC5heGVzID0gJ3h5JztcclxuICB9IGVsc2Uge1xyXG4gICAgaUV2ZW50LmF4ZXMgPSBpbnRlcmFjdGlvbi5yZXNpemVBeGVzO1xyXG5cclxuICAgIGlmIChpbnRlcmFjdGlvbi5yZXNpemVBeGVzID09PSAneCcpIHtcclxuICAgICAgaUV2ZW50LmR5ID0gMDtcclxuICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9PT0gJ3knKSB7XHJcbiAgICAgIGlFdmVudC5keCA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmFjdGlvbnMucmVzaXplID0gcmVzaXplO1xyXG5hY3Rpb25zLm5hbWVzLnB1c2goJ3Jlc2l6ZScpO1xyXG51dGlscy5tZXJnZShJbnRlcmFjdGFibGUuZXZlbnRUeXBlcywgWydyZXNpemVzdGFydCcsICdyZXNpemVtb3ZlJywgJ3Jlc2l6ZWluZXJ0aWFzdGFydCcsICdyZXNpemVpbmVydGlhcmVzdW1lJywgJ3Jlc2l6ZWVuZCddKTtcclxuYWN0aW9ucy5tZXRob2REaWN0LnJlc2l6ZSA9ICdyZXNpemFibGUnO1xyXG5cclxuZGVmYXVsdE9wdGlvbnMucmVzaXplID0gcmVzaXplLmRlZmF1bHRzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXNpemU7XHJcblxyXG59LHtcIi4uL0ludGVyYWN0RXZlbnRcIjozLFwiLi4vSW50ZXJhY3RhYmxlXCI6NCxcIi4uL0ludGVyYWN0aW9uXCI6NSxcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi91dGlsc1wiOjQ0LFwiLi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi9iYXNlXCI6Nn1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJhZiA9IHJlcXVpcmUoJy4vdXRpbHMvcmFmJyk7XHJcbnZhciBnZXRXaW5kb3cgPSByZXF1aXJlKCcuL3V0aWxzL3dpbmRvdycpLmdldFdpbmRvdztcclxudmFyIGlzID0gcmVxdWlyZSgnLi91dGlscy9pcycpO1xyXG52YXIgZG9tVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2RvbVV0aWxzJyk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb24nKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi9kZWZhdWx0T3B0aW9ucycpO1xyXG5cclxudmFyIGF1dG9TY3JvbGwgPSB7XHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgY29udGFpbmVyOiBudWxsLCAvLyB0aGUgaXRlbSB0aGF0IGlzIHNjcm9sbGVkIChXaW5kb3cgb3IgSFRNTEVsZW1lbnQpXHJcbiAgICBtYXJnaW46IDYwLFxyXG4gICAgc3BlZWQ6IDMwMCAvLyB0aGUgc2Nyb2xsIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kXHJcbiAgfSxcclxuXHJcbiAgaW50ZXJhY3Rpb246IG51bGwsXHJcbiAgaTogbnVsbCwgLy8gdGhlIGhhbmRsZSByZXR1cm5lZCBieSB3aW5kb3cuc2V0SW50ZXJ2YWxcclxuICB4OiAwLCB5OiAwLCAvLyBEaXJlY3Rpb24gZWFjaCBwdWxzZSBpcyB0byBzY3JvbGwgaW5cclxuXHJcbiAgaXNTY3JvbGxpbmc6IGZhbHNlLFxyXG4gIHByZXZUaW1lOiAwLFxyXG5cclxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoaW50ZXJhY3Rpb24pIHtcclxuICAgIGF1dG9TY3JvbGwuaXNTY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgcmFmLmNhbmNlbChhdXRvU2Nyb2xsLmkpO1xyXG5cclxuICAgIGF1dG9TY3JvbGwuaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbjtcclxuICAgIGF1dG9TY3JvbGwucHJldlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGF1dG9TY3JvbGwuaSA9IHJhZi5yZXF1ZXN0KGF1dG9TY3JvbGwuc2Nyb2xsKTtcclxuICB9LFxyXG5cclxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xyXG4gICAgYXV0b1Njcm9sbC5pc1Njcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgcmFmLmNhbmNlbChhdXRvU2Nyb2xsLmkpO1xyXG4gIH0sXHJcblxyXG4gIC8vIHNjcm9sbCB0aGUgd2luZG93IGJ5IHRoZSB2YWx1ZXMgaW4gc2Nyb2xsLngveVxyXG4gIHNjcm9sbDogZnVuY3Rpb24gc2Nyb2xsKCkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhdXRvU2Nyb2xsLmludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zW2F1dG9TY3JvbGwuaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV0uYXV0b1Njcm9sbDtcclxuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBnZXRXaW5kb3coYXV0b1Njcm9sbC5pbnRlcmFjdGlvbi5lbGVtZW50KTtcclxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIC8vIGNoYW5nZSBpbiB0aW1lIGluIHNlY29uZHNcclxuICAgIHZhciBkdCA9IChub3cgLSBhdXRvU2Nyb2xsLnByZXZUaW1lKSAvIDEwMDA7XHJcbiAgICAvLyBkaXNwbGFjZW1lbnRcclxuICAgIHZhciBzID0gb3B0aW9ucy5zcGVlZCAqIGR0O1xyXG5cclxuICAgIGlmIChzID49IDEpIHtcclxuICAgICAgaWYgKGlzLndpbmRvdyhjb250YWluZXIpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbEJ5KGF1dG9TY3JvbGwueCAqIHMsIGF1dG9TY3JvbGwueSAqIHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IGF1dG9TY3JvbGwueCAqIHM7XHJcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBhdXRvU2Nyb2xsLnkgKiBzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhdXRvU2Nyb2xsLnByZXZUaW1lID0gbm93O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdXRvU2Nyb2xsLmlzU2Nyb2xsaW5nKSB7XHJcbiAgICAgIHJhZi5jYW5jZWwoYXV0b1Njcm9sbC5pKTtcclxuICAgICAgYXV0b1Njcm9sbC5pID0gcmFmLnJlcXVlc3QoYXV0b1Njcm9sbC5zY3JvbGwpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY2hlY2s6IGZ1bmN0aW9uIGNoZWNrKGludGVyYWN0YWJsZSwgYWN0aW9uTmFtZSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBpbnRlcmFjdGFibGUub3B0aW9ucztcclxuXHJcbiAgICByZXR1cm4gb3B0aW9uc1thY3Rpb25OYW1lXS5hdXRvU2Nyb2xsICYmIG9wdGlvbnNbYWN0aW9uTmFtZV0uYXV0b1Njcm9sbC5lbmFibGVkO1xyXG4gIH0sXHJcbiAgb25JbnRlcmFjdGlvbk1vdmU6IGZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25Nb3ZlKF9yZWYpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgcG9pbnRlciA9IF9yZWYucG9pbnRlcjtcclxuXHJcbiAgICBpZiAoIShpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpICYmIGF1dG9TY3JvbGwuY2hlY2soaW50ZXJhY3Rpb24udGFyZ2V0LCBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnRlcmFjdGlvbi5zaW11bGF0aW9uKSB7XHJcbiAgICAgIGF1dG9TY3JvbGwueCA9IGF1dG9TY3JvbGwueSA9IDA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG9wID0gdm9pZCAwO1xyXG4gICAgdmFyIHJpZ2h0ID0gdm9pZCAwO1xyXG4gICAgdmFyIGJvdHRvbSA9IHZvaWQgMDtcclxuICAgIHZhciBsZWZ0ID0gdm9pZCAwO1xyXG5cclxuICAgIHZhciBvcHRpb25zID0gaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnNbaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV0uYXV0b1Njcm9sbDtcclxuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBnZXRXaW5kb3coaW50ZXJhY3Rpb24uZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKGlzLndpbmRvdyhjb250YWluZXIpKSB7XHJcbiAgICAgIGxlZnQgPSBwb2ludGVyLmNsaWVudFggPCBhdXRvU2Nyb2xsLm1hcmdpbjtcclxuICAgICAgdG9wID0gcG9pbnRlci5jbGllbnRZIDwgYXV0b1Njcm9sbC5tYXJnaW47XHJcbiAgICAgIHJpZ2h0ID0gcG9pbnRlci5jbGllbnRYID4gY29udGFpbmVyLmlubmVyV2lkdGggLSBhdXRvU2Nyb2xsLm1hcmdpbjtcclxuICAgICAgYm90dG9tID0gcG9pbnRlci5jbGllbnRZID4gY29udGFpbmVyLmlubmVySGVpZ2h0IC0gYXV0b1Njcm9sbC5tYXJnaW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgcmVjdCA9IGRvbVV0aWxzLmdldEVsZW1lbnRDbGllbnRSZWN0KGNvbnRhaW5lcik7XHJcblxyXG4gICAgICBsZWZ0ID0gcG9pbnRlci5jbGllbnRYIDwgcmVjdC5sZWZ0ICsgYXV0b1Njcm9sbC5tYXJnaW47XHJcbiAgICAgIHRvcCA9IHBvaW50ZXIuY2xpZW50WSA8IHJlY3QudG9wICsgYXV0b1Njcm9sbC5tYXJnaW47XHJcbiAgICAgIHJpZ2h0ID0gcG9pbnRlci5jbGllbnRYID4gcmVjdC5yaWdodCAtIGF1dG9TY3JvbGwubWFyZ2luO1xyXG4gICAgICBib3R0b20gPSBwb2ludGVyLmNsaWVudFkgPiByZWN0LmJvdHRvbSAtIGF1dG9TY3JvbGwubWFyZ2luO1xyXG4gICAgfVxyXG5cclxuICAgIGF1dG9TY3JvbGwueCA9IHJpZ2h0ID8gMSA6IGxlZnQgPyAtMSA6IDA7XHJcbiAgICBhdXRvU2Nyb2xsLnkgPSBib3R0b20gPyAxIDogdG9wID8gLTEgOiAwO1xyXG5cclxuICAgIGlmICghYXV0b1Njcm9sbC5pc1Njcm9sbGluZykge1xyXG4gICAgICAvLyBzZXQgdGhlIGF1dG9TY3JvbGwgcHJvcGVydGllcyB0byB0aG9zZSBvZiB0aGUgdGFyZ2V0XHJcbiAgICAgIGF1dG9TY3JvbGwubWFyZ2luID0gb3B0aW9ucy5tYXJnaW47XHJcbiAgICAgIGF1dG9TY3JvbGwuc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xyXG5cclxuICAgICAgYXV0b1Njcm9sbC5zdGFydChpbnRlcmFjdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignc3RvcC1hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgYXV0b1Njcm9sbC5zdG9wKCk7XHJcbn0pO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignYWN0aW9uLW1vdmUnLCBhdXRvU2Nyb2xsLm9uSW50ZXJhY3Rpb25Nb3ZlKTtcclxuXHJcbmRlZmF1bHRPcHRpb25zLnBlckFjdGlvbi5hdXRvU2Nyb2xsID0gYXV0b1Njcm9sbC5kZWZhdWx0cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYXV0b1Njcm9sbDtcclxuXHJcbn0se1wiLi9JbnRlcmFjdGlvblwiOjUsXCIuL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuL3V0aWxzL2RvbVV0aWxzXCI6MzksXCIuL3V0aWxzL2lzXCI6NDYsXCIuL3V0aWxzL3JhZlwiOjUwLFwiLi91dGlscy93aW5kb3dcIjo1Mn1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEludGVyYWN0YWJsZSA9IHJlcXVpcmUoJy4uL0ludGVyYWN0YWJsZScpO1xyXG52YXIgYWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvYmFzZScpO1xyXG52YXIgaXMgPSByZXF1aXJlKCcuLi91dGlscy9pcycpO1xyXG52YXIgZG9tVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9kb21VdGlscycpO1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5nZXRBY3Rpb24gPSBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGludGVyYWN0aW9uLCBlbGVtZW50KSB7XHJcbiAgdmFyIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbkNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGludGVyYWN0aW9uLCBlbGVtZW50KTtcclxuXHJcbiAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGFjdGlvbiwgdGhpcywgZWxlbWVudCwgaW50ZXJhY3Rpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLmlnbm9yZUZyb21cclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogSWYgdGhlIHRhcmdldCBvZiB0aGUgYG1vdXNlZG93bmAsIGBwb2ludGVyZG93bmAgb3IgYHRvdWNoc3RhcnRgXHJcbiAqIGV2ZW50IG9yIGFueSBvZiBpdCdzIHBhcmVudHMgbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvclxyXG4gKiBFbGVtZW50LCBubyBkcmFnL3Jlc2l6ZS9nZXN0dXJlIGlzIHN0YXJ0ZWQuXHJcbiAqXHJcbiAtIG5ld1ZhbHVlIChzdHJpbmcgfCBFbGVtZW50IHwgbnVsbCkgI29wdGlvbmFsIGEgQ1NTIHNlbGVjdG9yIHN0cmluZywgYW4gRWxlbWVudCBvciBgbnVsbGAgdG8gbm90IGlnbm9yZSBhbnkgZWxlbWVudHNcclxuID0gKHN0cmluZyB8IEVsZW1lbnQgfCBvYmplY3QpIFRoZSBjdXJyZW50IGlnbm9yZUZyb20gdmFsdWUgb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICoqXHJcbiB8IGludGVyYWN0KGVsZW1lbnQsIHsgaWdub3JlRnJvbTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vLWFjdGlvbicpIH0pO1xyXG4gfCAvLyBvclxyXG4gfCBpbnRlcmFjdChlbGVtZW50KS5pZ25vcmVGcm9tKCdpbnB1dCwgdGV4dGFyZWEsIGEnKTtcclxuXFwqL1xyXG5JbnRlcmFjdGFibGUucHJvdG90eXBlLmlnbm9yZUZyb20gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICByZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbignaWdub3JlRnJvbScsIG5ld1ZhbHVlKTtcclxufTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLmFsbG93RnJvbVxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBBIGRyYWcvcmVzaXplL2dlc3R1cmUgaXMgc3RhcnRlZCBvbmx5IElmIHRoZSB0YXJnZXQgb2YgdGhlXHJcbiAqIGBtb3VzZWRvd25gLCBgcG9pbnRlcmRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCBvciBhbnkgb2YgaXQnc1xyXG4gKiBwYXJlbnRzIG1hdGNoIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudC5cclxuICpcclxuIC0gbmV3VmFsdWUgKHN0cmluZyB8IEVsZW1lbnQgfCBudWxsKSAjb3B0aW9uYWwgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nLCBhbiBFbGVtZW50IG9yIGBudWxsYCB0byBhbGxvdyBmcm9tIGFueSBlbGVtZW50XHJcbiA9IChzdHJpbmcgfCBFbGVtZW50IHwgb2JqZWN0KSBUaGUgY3VycmVudCBhbGxvd0Zyb20gdmFsdWUgb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICoqXHJcbiB8IGludGVyYWN0KGVsZW1lbnQsIHsgYWxsb3dGcm9tOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJhZy1oYW5kbGUnKSB9KTtcclxuIHwgLy8gb3JcclxuIHwgaW50ZXJhY3QoZWxlbWVudCkuYWxsb3dGcm9tKCcuaGFuZGxlJyk7XHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5hbGxvd0Zyb20gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICByZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbignYWxsb3dGcm9tJywgbmV3VmFsdWUpO1xyXG59O1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS50ZXN0SWdub3JlID0gZnVuY3Rpb24gKGlnbm9yZUZyb20sIGludGVyYWN0YWJsZUVsZW1lbnQsIGVsZW1lbnQpIHtcclxuICBpZiAoIWlnbm9yZUZyb20gfHwgIWlzLmVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChpcy5zdHJpbmcoaWdub3JlRnJvbSkpIHtcclxuICAgIHJldHVybiBkb21VdGlscy5tYXRjaGVzVXBUbyhlbGVtZW50LCBpZ25vcmVGcm9tLCBpbnRlcmFjdGFibGVFbGVtZW50KTtcclxuICB9IGVsc2UgaWYgKGlzLmVsZW1lbnQoaWdub3JlRnJvbSkpIHtcclxuICAgIHJldHVybiBkb21VdGlscy5ub2RlQ29udGFpbnMoaWdub3JlRnJvbSwgZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5JbnRlcmFjdGFibGUucHJvdG90eXBlLnRlc3RBbGxvdyA9IGZ1bmN0aW9uIChhbGxvd0Zyb20sIGludGVyYWN0YWJsZUVsZW1lbnQsIGVsZW1lbnQpIHtcclxuICBpZiAoIWFsbG93RnJvbSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzLmVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChpcy5zdHJpbmcoYWxsb3dGcm9tKSkge1xyXG4gICAgcmV0dXJuIGRvbVV0aWxzLm1hdGNoZXNVcFRvKGVsZW1lbnQsIGFsbG93RnJvbSwgaW50ZXJhY3RhYmxlRWxlbWVudCk7XHJcbiAgfSBlbHNlIGlmIChpcy5lbGVtZW50KGFsbG93RnJvbSkpIHtcclxuICAgIHJldHVybiBkb21VdGlscy5ub2RlQ29udGFpbnMoYWxsb3dGcm9tLCBlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkludGVyYWN0YWJsZS5wcm90b3R5cGUudGVzdElnbm9yZUFsbG93ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGludGVyYWN0YWJsZUVsZW1lbnQsIGV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuICF0aGlzLnRlc3RJZ25vcmUob3B0aW9ucy5pZ25vcmVGcm9tLCBpbnRlcmFjdGFibGVFbGVtZW50LCBldmVudFRhcmdldCkgJiYgdGhpcy50ZXN0QWxsb3cob3B0aW9ucy5hbGxvd0Zyb20sIGludGVyYWN0YWJsZUVsZW1lbnQsIGV2ZW50VGFyZ2V0KTtcclxufTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLmFjdGlvbkNoZWNrZXJcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogR2V0cyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgb25cclxuICogcG9pbnRlckRvd25cclxuICpcclxuIC0gY2hlY2tlciAoZnVuY3Rpb24gfCBudWxsKSAjb3B0aW9uYWwgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHBvaW50ZXIgZXZlbnQsIGRlZmF1bHRBY3Rpb24gc3RyaW5nLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQgYW5kIGludGVyYWN0aW9uIGFzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggbmFtZSBwcm9wZXJ0eSAnZHJhZycgJ3Jlc2l6ZScgb3IgJ2dlc3R1cmUnIGFuZCBvcHRpb25hbGx5IGFuIGBlZGdlc2Agb2JqZWN0IHdpdGggYm9vbGVhbiAndG9wJywgJ2xlZnQnLCAnYm90dG9tJyBhbmQgcmlnaHQgcHJvcHMuXHJcbiA9IChGdW5jdGlvbiB8IEludGVyYWN0YWJsZSkgVGhlIGNoZWNrZXIgZnVuY3Rpb24gb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICpcclxuIHwgaW50ZXJhY3QoJy5yZXNpemUtZHJhZycpXHJcbiB8ICAgLnJlc2l6YWJsZSh0cnVlKVxyXG4gfCAgIC5kcmFnZ2FibGUodHJ1ZSlcclxuIHwgICAuYWN0aW9uQ2hlY2tlcihmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGFjdGlvbiwgaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBpbnRlcmFjdGlvbikge1xyXG4gfFxyXG4gfCAgIGlmIChpbnRlcmFjdC5tYXRjaGVzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCAnLmRyYWctaGFuZGxlJykge1xyXG4gfCAgICAgLy8gZm9yY2UgZHJhZyB3aXRoIGhhbmRsZSB0YXJnZXRcclxuIHwgICAgIGFjdGlvbi5uYW1lID0gZHJhZztcclxuIHwgICB9XHJcbiB8ICAgZWxzZSB7XHJcbiB8ICAgICAvLyByZXNpemUgZnJvbSB0aGUgdG9wIGFuZCByaWdodCBlZGdlc1xyXG4gfCAgICAgYWN0aW9uLm5hbWUgID0gJ3Jlc2l6ZSc7XHJcbiB8ICAgICBhY3Rpb24uZWRnZXMgPSB7IHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUgfTtcclxuIHwgICB9XHJcbiB8XHJcbiB8ICAgcmV0dXJuIGFjdGlvbjtcclxuIHwgfSk7XHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5hY3Rpb25DaGVja2VyID0gZnVuY3Rpb24gKGNoZWNrZXIpIHtcclxuICBpZiAoaXMuZnVuY3Rpb24oY2hlY2tlcikpIHtcclxuICAgIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyID0gY2hlY2tlcjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGlmIChjaGVja2VyID09PSBudWxsKSB7XHJcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI7XHJcbn07XHJcblxyXG4vKlxcXHJcbiAqIEludGVyYWN0YWJsZS5zdHlsZUN1cnNvclxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciB0aGUgdGhlIGN1cnNvciBzaG91bGQgYmUgY2hhbmdlZCBkZXBlbmRpbmcgb24gdGhlXHJcbiAqIGFjdGlvbiB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBpZiB0aGUgbW91c2Ugd2VyZSBwcmVzc2VkIGFuZCBkcmFnZ2VkLlxyXG4gKlxyXG4gLSBuZXdWYWx1ZSAoYm9vbGVhbikgI29wdGlvbmFsXHJcbiA9IChib29sZWFuIHwgSW50ZXJhY3RhYmxlKSBUaGUgY3VycmVudCBzZXR0aW5nIG9yIHRoaXMgSW50ZXJhY3RhYmxlXHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5zdHlsZUN1cnNvciA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gIGlmIChpcy5ib29sKG5ld1ZhbHVlKSkge1xyXG4gICAgdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yID0gbmV3VmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcclxuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3I7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yO1xyXG59O1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5kZWZhdWx0QWN0aW9uQ2hlY2tlciA9IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgaW50ZXJhY3Rpb24sIGVsZW1lbnQpIHtcclxuICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdChlbGVtZW50KTtcclxuICB2YXIgYWN0aW9uID0gbnVsbDtcclxuXHJcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gYWN0aW9ucy5uYW1lcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgIHZhciBfcmVmO1xyXG5cclxuICAgIGlmIChfaXNBcnJheSkge1xyXG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhY3Rpb25OYW1lID0gX3JlZjtcclxuXHJcbiAgICAvLyBjaGVjayBtb3VzZUJ1dHRvbiBzZXR0aW5nIGlmIHRoZSBwb2ludGVyIGlzIGRvd25cclxuICAgIGlmIChpbnRlcmFjdGlvbi5wb2ludGVySXNEb3duICYmIGludGVyYWN0aW9uLm1vdXNlICYmIChldmVudC5idXR0b25zICYgdGhpcy5vcHRpb25zW2FjdGlvbk5hbWVdLm1vdXNlQnV0dG9ucykgPT09IDApIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aW9uID0gYWN0aW9uc1thY3Rpb25OYW1lXS5jaGVja2VyKHBvaW50ZXIsIGV2ZW50LCB0aGlzLCBlbGVtZW50LCBpbnRlcmFjdGlvbiwgcmVjdCk7XHJcblxyXG4gICAgaWYgKGFjdGlvbikge1xyXG4gICAgICByZXR1cm4gYWN0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbn0se1wiLi4vSW50ZXJhY3RhYmxlXCI6NCxcIi4uL2FjdGlvbnMvYmFzZVwiOjYsXCIuLi91dGlscy9kb21VdGlsc1wiOjM5LFwiLi4vdXRpbHMvaXNcIjo0Nn1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGludGVyYWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJhY3QnKTtcclxudmFyIEludGVyYWN0YWJsZSA9IHJlcXVpcmUoJy4uL0ludGVyYWN0YWJsZScpO1xyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuLi9JbnRlcmFjdGlvbicpO1xyXG52YXIgYWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvYmFzZScpO1xyXG52YXIgZGVmYXVsdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9kZWZhdWx0T3B0aW9ucycpO1xyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKTtcclxudmFyIHNjb3BlID0gcmVxdWlyZSgnLi4vc2NvcGUnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIHNpZ25hbHMgPSByZXF1aXJlKCcuLi91dGlscy9TaWduYWxzJykubmV3KCk7XHJcblxyXG5yZXF1aXJlKCcuL0ludGVyYWN0YWJsZU1ldGhvZHMnKTtcclxuXHJcbnZhciBhdXRvU3RhcnQgPSB7XHJcbiAgc2lnbmFsczogc2lnbmFscyxcclxuICB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0OiB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0LFxyXG4gIC8vIEFsbG93IHRoaXMgbWFueSBpbnRlcmFjdGlvbnMgdG8gaGFwcGVuIHNpbXVsdGFuZW91c2x5XHJcbiAgbWF4SW50ZXJhY3Rpb25zOiBJbmZpbml0eSxcclxuICBkZWZhdWx0czoge1xyXG4gICAgcGVyQWN0aW9uOiB7XHJcbiAgICAgIG1hbnVhbFN0YXJ0OiBmYWxzZSxcclxuICAgICAgbWF4OiBJbmZpbml0eSxcclxuICAgICAgbWF4UGVyRWxlbWVudDogMSxcclxuICAgICAgYWxsb3dGcm9tOiBudWxsLFxyXG4gICAgICBpZ25vcmVGcm9tOiBudWxsXHJcbiAgICB9XHJcbiAgfSxcclxuICBzZXRBY3Rpb25EZWZhdWx0czogZnVuY3Rpb24gc2V0QWN0aW9uRGVmYXVsdHMoYWN0aW9uKSB7XHJcbiAgICB1dGlscy5leHRlbmQoYWN0aW9uLmRlZmF1bHRzLCBhdXRvU3RhcnQuZGVmYXVsdHMucGVyQWN0aW9uKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBzZXQgY3Vyc29yIHN0eWxlIG9uIG1vdXNlZG93blxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdkb3duJywgZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBwb2ludGVyID0gX3JlZi5wb2ludGVyLFxyXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0ID0gX3JlZi5ldmVudFRhcmdldDtcclxuXHJcbiAgaWYgKGludGVyYWN0aW9uLmludGVyYWN0aW5nKCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBhY3Rpb25JbmZvID0gZ2V0QWN0aW9uSW5mbyhpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0KTtcclxuICBwcmVwYXJlKGludGVyYWN0aW9uLCBhY3Rpb25JbmZvKTtcclxufSk7XHJcblxyXG4vLyBzZXQgY3Vyc29yIHN0eWxlIG9uIG1vdXNlbW92ZVxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdtb3ZlJywgZnVuY3Rpb24gKF9yZWYyKSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjIuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXIgPSBfcmVmMi5wb2ludGVyLFxyXG4gICAgICBldmVudCA9IF9yZWYyLmV2ZW50LFxyXG4gICAgICBldmVudFRhcmdldCA9IF9yZWYyLmV2ZW50VGFyZ2V0O1xyXG5cclxuICBpZiAoIWludGVyYWN0aW9uLm1vdXNlIHx8IGludGVyYWN0aW9uLnBvaW50ZXJJc0Rvd24gfHwgaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGFjdGlvbkluZm8gPSBnZXRBY3Rpb25JbmZvKGludGVyYWN0aW9uLCBwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpO1xyXG4gIHByZXBhcmUoaW50ZXJhY3Rpb24sIGFjdGlvbkluZm8pO1xyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ21vdmUnLCBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gYXJnLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudCA9IGFyZy5ldmVudDtcclxuXHJcblxyXG4gIGlmICghaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93biB8fCBpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpIHx8ICFpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQgfHwgIWludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHNpZ25hbHMuZmlyZSgnYmVmb3JlLXN0YXJ0JywgYXJnKTtcclxuXHJcbiAgdmFyIHRhcmdldCA9IGludGVyYWN0aW9uLnRhcmdldDtcclxuXHJcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgJiYgdGFyZ2V0KSB7XHJcbiAgICAvLyBjaGVjayBtYW51YWxTdGFydCBhbmQgaW50ZXJhY3Rpb24gbGltaXRcclxuICAgIGlmICh0YXJnZXQub3B0aW9uc1tpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lXS5tYW51YWxTdGFydCB8fCAhd2l0aGluSW50ZXJhY3Rpb25MaW1pdCh0YXJnZXQsIGludGVyYWN0aW9uLmVsZW1lbnQsIGludGVyYWN0aW9uLnByZXBhcmVkKSkge1xyXG4gICAgICBpbnRlcmFjdGlvbi5zdG9wKGV2ZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGludGVyYWN0aW9uLnN0YXJ0KGludGVyYWN0aW9uLnByZXBhcmVkLCB0YXJnZXQsIGludGVyYWN0aW9uLmVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBDaGVjayBpZiB0aGUgY3VycmVudCB0YXJnZXQgc3VwcG9ydHMgdGhlIGFjdGlvbi5cclxuLy8gSWYgc28sIHJldHVybiB0aGUgdmFsaWRhdGVkIGFjdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gbnVsbFxyXG5mdW5jdGlvbiB2YWxpZGF0ZUFjdGlvbihhY3Rpb24sIGludGVyYWN0YWJsZSwgZWxlbWVudCwgZXZlbnRUYXJnZXQpIHtcclxuICBpZiAodXRpbHMuaXMub2JqZWN0KGFjdGlvbikgJiYgaW50ZXJhY3RhYmxlLnRlc3RJZ25vcmVBbGxvdyhpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb24ubmFtZV0sIGVsZW1lbnQsIGV2ZW50VGFyZ2V0KSAmJiBpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb24ubmFtZV0uZW5hYmxlZCAmJiB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0KGludGVyYWN0YWJsZSwgZWxlbWVudCwgYWN0aW9uKSkge1xyXG4gICAgcmV0dXJuIGFjdGlvbjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVNlbGVjdG9yKGludGVyYWN0aW9uLCBwb2ludGVyLCBldmVudCwgbWF0Y2hlcywgbWF0Y2hFbGVtZW50cywgZXZlbnRUYXJnZXQpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tpXTtcclxuICAgIHZhciBtYXRjaEVsZW1lbnQgPSBtYXRjaEVsZW1lbnRzW2ldO1xyXG4gICAgdmFyIGFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uKG1hdGNoLmdldEFjdGlvbihwb2ludGVyLCBldmVudCwgaW50ZXJhY3Rpb24sIG1hdGNoRWxlbWVudCksIG1hdGNoLCBtYXRjaEVsZW1lbnQsIGV2ZW50VGFyZ2V0KTtcclxuXHJcbiAgICBpZiAoYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXHJcbiAgICAgICAgdGFyZ2V0OiBtYXRjaCxcclxuICAgICAgICBlbGVtZW50OiBtYXRjaEVsZW1lbnRcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QWN0aW9uSW5mbyhpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0KSB7XHJcbiAgdmFyIG1hdGNoZXMgPSBbXTtcclxuICB2YXIgbWF0Y2hFbGVtZW50cyA9IFtdO1xyXG5cclxuICB2YXIgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xyXG4gIHZhciBhY3Rpb24gPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiBwdXNoTWF0Y2hlcyhpbnRlcmFjdGFibGUsIHNlbGVjdG9yLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgZWxlbWVudHMgPSBicm93c2VyLnVzZU1hdGNoZXNTZWxlY3RvclBvbHlmaWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodXRpbHMubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yLCBlbGVtZW50cykpIHtcclxuXHJcbiAgICAgIG1hdGNoZXMucHVzaChpbnRlcmFjdGFibGUpO1xyXG4gICAgICBtYXRjaEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3aGlsZSAodXRpbHMuaXMuZWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgbWF0Y2hlcyA9IFtdO1xyXG4gICAgbWF0Y2hFbGVtZW50cyA9IFtdO1xyXG5cclxuICAgIHZhciBlbGVtZW50SW50ZXJhY3RhYmxlID0gc2NvcGUuaW50ZXJhY3RhYmxlcy5nZXQoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKGVsZW1lbnRJbnRlcmFjdGFibGUgJiYgKGFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uKGVsZW1lbnRJbnRlcmFjdGFibGUuZ2V0QWN0aW9uKHBvaW50ZXIsIGV2ZW50LCBpbnRlcmFjdGlvbiwgZWxlbWVudCwgZXZlbnRUYXJnZXQpLCBlbGVtZW50SW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldCkpICYmICFlbGVtZW50SW50ZXJhY3RhYmxlLm9wdGlvbnNbYWN0aW9uLm5hbWVdLm1hbnVhbFN0YXJ0KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICBhY3Rpb246IGFjdGlvbixcclxuICAgICAgICB0YXJnZXQ6IGVsZW1lbnRJbnRlcmFjdGFibGVcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNjb3BlLmludGVyYWN0YWJsZXMuZm9yRWFjaFNlbGVjdG9yKHB1c2hNYXRjaGVzLCBlbGVtZW50KTtcclxuXHJcbiAgICAgIHZhciBhY3Rpb25JbmZvID0gdmFsaWRhdGVTZWxlY3RvcihpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIG1hdGNoZXMsIG1hdGNoRWxlbWVudHMsIGV2ZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25JbmZvLmFjdGlvbiAmJiAhYWN0aW9uSW5mby50YXJnZXQub3B0aW9uc1thY3Rpb25JbmZvLmFjdGlvbi5uYW1lXS5tYW51YWxTdGFydCkge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb25JbmZvO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudCA9IHV0aWxzLnBhcmVudE5vZGUoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge307XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmUoaW50ZXJhY3Rpb24sIF9yZWYzKSB7XHJcbiAgdmFyIGFjdGlvbiA9IF9yZWYzLmFjdGlvbixcclxuICAgICAgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0LFxyXG4gICAgICBlbGVtZW50ID0gX3JlZjMuZWxlbWVudDtcclxuXHJcbiAgYWN0aW9uID0gYWN0aW9uIHx8IHt9O1xyXG5cclxuICBpZiAoaW50ZXJhY3Rpb24udGFyZ2V0ICYmIGludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zLnN0eWxlQ3Vyc29yKSB7XHJcbiAgICBpbnRlcmFjdGlvbi50YXJnZXQuX2RvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJyc7XHJcbiAgfVxyXG5cclxuICBpbnRlcmFjdGlvbi50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgaW50ZXJhY3Rpb24uZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgdXRpbHMuY29weUFjdGlvbihpbnRlcmFjdGlvbi5wcmVwYXJlZCwgYWN0aW9uKTtcclxuXHJcbiAgaWYgKHRhcmdldCAmJiB0YXJnZXQub3B0aW9ucy5zdHlsZUN1cnNvcikge1xyXG4gICAgdmFyIGN1cnNvciA9IGFjdGlvbiA/IGFjdGlvbnNbYWN0aW9uLm5hbWVdLmdldEN1cnNvcihhY3Rpb24pIDogJyc7XHJcbiAgICBpbnRlcmFjdGlvbi50YXJnZXQuX2RvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xyXG4gIH1cclxuXHJcbiAgc2lnbmFscy5maXJlKCdwcmVwYXJlZCcsIHsgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uIH0pO1xyXG59XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdzdG9wJywgZnVuY3Rpb24gKF9yZWY0KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjQuaW50ZXJhY3Rpb247XHJcblxyXG4gIHZhciB0YXJnZXQgPSBpbnRlcmFjdGlvbi50YXJnZXQ7XHJcblxyXG4gIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm9wdGlvbnMuc3R5bGVDdXJzb3IpIHtcclxuICAgIHRhcmdldC5fZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnJztcclxuICB9XHJcbn0pO1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5nZXRBY3Rpb24gPSBmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGludGVyYWN0aW9uLCBlbGVtZW50KSB7XHJcbiAgdmFyIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbkNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGludGVyYWN0aW9uLCBlbGVtZW50KTtcclxuXHJcbiAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGFjdGlvbiwgdGhpcywgZWxlbWVudCwgaW50ZXJhY3Rpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFjdGlvbjtcclxufTtcclxuXHJcbi8qXFxcclxuICogSW50ZXJhY3RhYmxlLmFjdGlvbkNoZWNrZXJcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogR2V0cyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgb25cclxuICogcG9pbnRlckRvd25cclxuICpcclxuIC0gY2hlY2tlciAoZnVuY3Rpb24gfCBudWxsKSAjb3B0aW9uYWwgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHBvaW50ZXIgZXZlbnQsIGRlZmF1bHRBY3Rpb24gc3RyaW5nLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQgYW5kIGludGVyYWN0aW9uIGFzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggbmFtZSBwcm9wZXJ0eSAnZHJhZycgJ3Jlc2l6ZScgb3IgJ2dlc3R1cmUnIGFuZCBvcHRpb25hbGx5IGFuIGBlZGdlc2Agb2JqZWN0IHdpdGggYm9vbGVhbiAndG9wJywgJ2xlZnQnLCAnYm90dG9tJyBhbmQgcmlnaHQgcHJvcHMuXHJcbiA9IChGdW5jdGlvbiB8IEludGVyYWN0YWJsZSkgVGhlIGNoZWNrZXIgZnVuY3Rpb24gb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuICpcclxuIHwgaW50ZXJhY3QoJy5yZXNpemUtZHJhZycpXHJcbiB8ICAgLnJlc2l6YWJsZSh0cnVlKVxyXG4gfCAgIC5kcmFnZ2FibGUodHJ1ZSlcclxuIHwgICAuYWN0aW9uQ2hlY2tlcihmdW5jdGlvbiAocG9pbnRlciwgZXZlbnQsIGFjdGlvbiwgaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBpbnRlcmFjdGlvbikge1xyXG4gfFxyXG4gfCAgIGlmIChpbnRlcmFjdC5tYXRjaGVzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCAnLmRyYWctaGFuZGxlJykge1xyXG4gfCAgICAgLy8gZm9yY2UgZHJhZyB3aXRoIGhhbmRsZSB0YXJnZXRcclxuIHwgICAgIGFjdGlvbi5uYW1lID0gZHJhZztcclxuIHwgICB9XHJcbiB8ICAgZWxzZSB7XHJcbiB8ICAgICAvLyByZXNpemUgZnJvbSB0aGUgdG9wIGFuZCByaWdodCBlZGdlc1xyXG4gfCAgICAgYWN0aW9uLm5hbWUgID0gJ3Jlc2l6ZSc7XHJcbiB8ICAgICBhY3Rpb24uZWRnZXMgPSB7IHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUgfTtcclxuIHwgICB9XHJcbiB8XHJcbiB8ICAgcmV0dXJuIGFjdGlvbjtcclxuIHwgfSk7XHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5hY3Rpb25DaGVja2VyID0gZnVuY3Rpb24gKGNoZWNrZXIpIHtcclxuICBpZiAodXRpbHMuaXMuZnVuY3Rpb24oY2hlY2tlcikpIHtcclxuICAgIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyID0gY2hlY2tlcjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGlmIChjaGVja2VyID09PSBudWxsKSB7XHJcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI7XHJcbn07XHJcblxyXG4vKlxcXHJcbiAqIEludGVyYWN0YWJsZS5zdHlsZUN1cnNvclxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBSZXR1cm5zIG9yIHNldHMgd2hldGhlciB0aGUgdGhlIGN1cnNvciBzaG91bGQgYmUgY2hhbmdlZCBkZXBlbmRpbmcgb24gdGhlXHJcbiAqIGFjdGlvbiB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBpZiB0aGUgbW91c2Ugd2VyZSBwcmVzc2VkIGFuZCBkcmFnZ2VkLlxyXG4gKlxyXG4gLSBuZXdWYWx1ZSAoYm9vbGVhbikgI29wdGlvbmFsXHJcbiA9IChib29sZWFuIHwgSW50ZXJhY3RhYmxlKSBUaGUgY3VycmVudCBzZXR0aW5nIG9yIHRoaXMgSW50ZXJhY3RhYmxlXHJcblxcKi9cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5zdHlsZUN1cnNvciA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gIGlmICh1dGlscy5pcy5ib29sKG5ld1ZhbHVlKSkge1xyXG4gICAgdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yID0gbmV3VmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcclxuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3I7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLnN0eWxlQ3Vyc29yO1xyXG59O1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5kZWZhdWx0QWN0aW9uQ2hlY2tlciA9IGZ1bmN0aW9uIChwb2ludGVyLCBldmVudCwgaW50ZXJhY3Rpb24sIGVsZW1lbnQpIHtcclxuICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdChlbGVtZW50KTtcclxuICB2YXIgYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnMgfHwge1xyXG4gICAgMDogMSxcclxuICAgIDE6IDQsXHJcbiAgICAzOiA4LFxyXG4gICAgNDogMTZcclxuICB9W2V2ZW50LmJ1dHRvbl07XHJcbiAgdmFyIGFjdGlvbiA9IG51bGw7XHJcblxyXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IGFjdGlvbnMubmFtZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICB2YXIgX3JlZjU7XHJcblxyXG4gICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgX3JlZjUgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgX3JlZjUgPSBfaS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWN0aW9uTmFtZSA9IF9yZWY1O1xyXG5cclxuICAgIC8vIGNoZWNrIG1vdXNlQnV0dG9uIHNldHRpbmcgaWYgdGhlIHBvaW50ZXIgaXMgZG93blxyXG4gICAgaWYgKGludGVyYWN0aW9uLnBvaW50ZXJJc0Rvd24gJiYgaW50ZXJhY3Rpb24ubW91c2UgJiYgKGJ1dHRvbnMgJiB0aGlzLm9wdGlvbnNbYWN0aW9uTmFtZV0ubW91c2VCdXR0b25zKSA9PT0gMCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBhY3Rpb24gPSBhY3Rpb25zW2FjdGlvbk5hbWVdLmNoZWNrZXIocG9pbnRlciwgZXZlbnQsIHRoaXMsIGVsZW1lbnQsIGludGVyYWN0aW9uLCByZWN0KTtcclxuXHJcbiAgICBpZiAoYWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBhY3Rpb247XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gd2l0aGluSW50ZXJhY3Rpb25MaW1pdChpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGFjdGlvbikge1xyXG4gIHZhciBvcHRpb25zID0gaW50ZXJhY3RhYmxlLm9wdGlvbnM7XHJcbiAgdmFyIG1heEFjdGlvbnMgPSBvcHRpb25zW2FjdGlvbi5uYW1lXS5tYXg7XHJcbiAgdmFyIG1heFBlckVsZW1lbnQgPSBvcHRpb25zW2FjdGlvbi5uYW1lXS5tYXhQZXJFbGVtZW50O1xyXG4gIHZhciBhY3RpdmVJbnRlcmFjdGlvbnMgPSAwO1xyXG4gIHZhciB0YXJnZXRDb3VudCA9IDA7XHJcbiAgdmFyIHRhcmdldEVsZW1lbnRDb3VudCA9IDA7XHJcblxyXG4gIC8vIG5vIGFjdGlvbnMgaWYgYW55IG9mIHRoZXNlIHZhbHVlcyA9PSAwXHJcbiAgaWYgKCEobWF4QWN0aW9ucyAmJiBtYXhQZXJFbGVtZW50ICYmIGF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnMpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2NvcGUuaW50ZXJhY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBzY29wZS5pbnRlcmFjdGlvbnNbaV07XHJcbiAgICB2YXIgb3RoZXJBY3Rpb24gPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lO1xyXG5cclxuICAgIGlmICghaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmVJbnRlcmFjdGlvbnMrKztcclxuXHJcbiAgICBpZiAoYWN0aXZlSW50ZXJhY3Rpb25zID49IGF1dG9TdGFydC5tYXhJbnRlcmFjdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnRlcmFjdGlvbi50YXJnZXQgIT09IGludGVyYWN0YWJsZSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXRDb3VudCArPSBvdGhlckFjdGlvbiA9PT0gYWN0aW9uLm5hbWUgfCAwO1xyXG5cclxuICAgIGlmICh0YXJnZXRDb3VudCA+PSBtYXhBY3Rpb25zKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW50ZXJhY3Rpb24uZWxlbWVudCA9PT0gZWxlbWVudCkge1xyXG4gICAgICB0YXJnZXRFbGVtZW50Q291bnQrKztcclxuXHJcbiAgICAgIGlmIChvdGhlckFjdGlvbiAhPT0gYWN0aW9uLm5hbWUgfHwgdGFyZ2V0RWxlbWVudENvdW50ID49IG1heFBlckVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBhdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zID4gMDtcclxufVxyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5tYXhJbnRlcmFjdGlvbnNcclxuIFsgbWV0aG9kIF1cclxuICoqXHJcbiAqIFJldHVybnMgb3Igc2V0cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBpbnRlcmFjdGlvbnMgYWxsb3dlZC5cclxuICogQnkgZGVmYXVsdCBvbmx5IDEgaW50ZXJhY3Rpb24gaXMgYWxsb3dlZCBhdCBhIHRpbWUgKGZvciBiYWNrd2FyZHNcclxuICogY29tcGF0aWJpbGl0eSkuIFRvIGFsbG93IG11bHRpcGxlIGludGVyYWN0aW9ucyBvbiB0aGUgc2FtZSBJbnRlcmFjdGFibGVzXHJcbiAqIGFuZCBlbGVtZW50cywgeW91IG5lZWQgdG8gZW5hYmxlIGl0IGluIHRoZSBkcmFnZ2FibGUsIHJlc2l6YWJsZSBhbmRcclxuICogZ2VzdHVyYWJsZSBgJ21heCdgIGFuZCBgJ21heFBlckVsZW1lbnQnYCBvcHRpb25zLlxyXG4gKipcclxuIC0gbmV3VmFsdWUgKG51bWJlcikgI29wdGlvbmFsIEFueSBudW1iZXIuIG5ld1ZhbHVlIDw9IDAgbWVhbnMgbm8gaW50ZXJhY3Rpb25zLlxyXG5cXCovXHJcbmludGVyYWN0Lm1heEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gIGlmICh1dGlscy5pcy5udW1iZXIobmV3VmFsdWUpKSB7XHJcbiAgICBhdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zID0gbmV3VmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucztcclxufTtcclxuXHJcbkludGVyYWN0YWJsZS5zZXR0aW5nc01ldGhvZHMucHVzaCgnc3R5bGVDdXJzb3InKTtcclxuSW50ZXJhY3RhYmxlLnNldHRpbmdzTWV0aG9kcy5wdXNoKCdhY3Rpb25DaGVja2VyJyk7XHJcbkludGVyYWN0YWJsZS5zZXR0aW5nc01ldGhvZHMucHVzaCgnaWdub3JlRnJvbScpO1xyXG5JbnRlcmFjdGFibGUuc2V0dGluZ3NNZXRob2RzLnB1c2goJ2FsbG93RnJvbScpO1xyXG5cclxuZGVmYXVsdE9wdGlvbnMuYmFzZS5hY3Rpb25DaGVja2VyID0gbnVsbDtcclxuZGVmYXVsdE9wdGlvbnMuYmFzZS5zdHlsZUN1cnNvciA9IHRydWU7XHJcblxyXG51dGlscy5leHRlbmQoZGVmYXVsdE9wdGlvbnMucGVyQWN0aW9uLCBhdXRvU3RhcnQuZGVmYXVsdHMucGVyQWN0aW9uKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYXV0b1N0YXJ0O1xyXG5cclxufSx7XCIuLi9JbnRlcmFjdGFibGVcIjo0LFwiLi4vSW50ZXJhY3Rpb25cIjo1LFwiLi4vYWN0aW9ucy9iYXNlXCI6NixcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi9pbnRlcmFjdFwiOjIxLFwiLi4vc2NvcGVcIjozNCxcIi4uL3V0aWxzXCI6NDQsXCIuLi91dGlscy9TaWduYWxzXCI6MzUsXCIuLi91dGlscy9icm93c2VyXCI6MzcsXCIuL0ludGVyYWN0YWJsZU1ldGhvZHNcIjoxMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGF1dG9TdGFydCA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuLi9JbnRlcmFjdGlvbicpO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgaW50ZXJhY3Rpb24uZGVsYXlUaW1lciA9IG51bGw7XHJcbn0pO1xyXG5cclxuYXV0b1N0YXJ0LnNpZ25hbHMub24oJ3ByZXBhcmVkJywgZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uO1xyXG5cclxuICB2YXIgYWN0aW9uTmFtZSA9IGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWU7XHJcblxyXG4gIGlmICghYWN0aW9uTmFtZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGRlbGF5ID0gaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnNbYWN0aW9uTmFtZV0uZGVsYXk7XHJcblxyXG4gIGlmIChkZWxheSA+IDApIHtcclxuICAgIGludGVyYWN0aW9uLmRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgaW50ZXJhY3Rpb24uc3RhcnQoaW50ZXJhY3Rpb24ucHJlcGFyZWQsIGludGVyYWN0aW9uLnRhcmdldCwgaW50ZXJhY3Rpb24uZWxlbWVudCk7XHJcbiAgICB9LCBkZWxheSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ21vdmUnLCBmdW5jdGlvbiAoX3JlZjIpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMi5pbnRlcmFjdGlvbixcclxuICAgICAgZHVwbGljYXRlID0gX3JlZjIuZHVwbGljYXRlO1xyXG5cclxuICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlcldhc01vdmVkICYmICFkdXBsaWNhdGUpIHtcclxuICAgIGNsZWFyVGltZW91dChpbnRlcmFjdGlvbi5kZWxheVRpbWVyKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gcHJldmVudCByZWd1bGFyIGRvd24tPm1vdmUgYXV0b1N0YXJ0XHJcbmF1dG9TdGFydC5zaWduYWxzLm9uKCdiZWZvcmUtc3RhcnQnLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbjtcclxuXHJcbiAgdmFyIGFjdGlvbk5hbWUgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lO1xyXG5cclxuICBpZiAoIWFjdGlvbk5hbWUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBkZWxheSA9IGludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zW2FjdGlvbk5hbWVdLmRlbGF5O1xyXG5cclxuICBpZiAoZGVsYXkgPiAwKSB7XHJcbiAgICBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lID0gbnVsbDtcclxuICB9XHJcbn0pO1xyXG5cclxufSx7XCIuLi9JbnRlcmFjdGlvblwiOjUsXCIuL2Jhc2VcIjoxM31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGF1dG9TdGFydCA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG52YXIgc2NvcGUgPSByZXF1aXJlKCcuLi9zY29wZScpO1xyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKTtcclxudmFyIGlzID0gcmVxdWlyZSgnLi4vdXRpbHMvaXMnKTtcclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2RvbVV0aWxzJyksXHJcbiAgICBtYXRjaGVzU2VsZWN0b3IgPSBfcmVxdWlyZS5tYXRjaGVzU2VsZWN0b3IsXHJcbiAgICBwYXJlbnROb2RlID0gX3JlcXVpcmUucGFyZW50Tm9kZTtcclxuXHJcbmF1dG9TdGFydC5zZXRBY3Rpb25EZWZhdWx0cyhyZXF1aXJlKCcuLi9hY3Rpb25zL2RyYWcnKSk7XHJcblxyXG5hdXRvU3RhcnQuc2lnbmFscy5vbignYmVmb3JlLXN0YXJ0JywgZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudFRhcmdldCA9IF9yZWYuZXZlbnRUYXJnZXQsXHJcbiAgICAgIGR4ID0gX3JlZi5keCxcclxuICAgICAgZHkgPSBfcmVmLmR5O1xyXG5cclxuICBpZiAoaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSAhPT0gJ2RyYWcnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBhIGRyYWcgaXMgaW4gdGhlIGNvcnJlY3QgYXhpc1xyXG4gIHZhciBhYnNYID0gTWF0aC5hYnMoZHgpO1xyXG4gIHZhciBhYnNZID0gTWF0aC5hYnMoZHkpO1xyXG4gIHZhciBvcHRpb25zID0gaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnMuZHJhZztcclxuICB2YXIgc3RhcnRBeGlzID0gb3B0aW9ucy5zdGFydEF4aXM7XHJcbiAgdmFyIGN1cnJlbnRBeGlzID0gYWJzWCA+IGFic1kgPyAneCcgOiBhYnNYIDwgYWJzWSA/ICd5JyA6ICd4eSc7XHJcblxyXG4gIGludGVyYWN0aW9uLnByZXBhcmVkLmF4aXMgPSBvcHRpb25zLmxvY2tBeGlzID09PSAnc3RhcnQnID8gY3VycmVudEF4aXNbMF0gLy8gYWx3YXlzIGxvY2sgdG8gb25lIGF4aXMgZXZlbiBpZiBjdXJyZW50QXhpcyA9PT0gJ3h5J1xyXG4gIDogb3B0aW9ucy5sb2NrQXhpcztcclxuXHJcbiAgLy8gaWYgdGhlIG1vdmVtZW50IGlzbid0IGluIHRoZSBzdGFydEF4aXMgb2YgdGhlIGludGVyYWN0YWJsZVxyXG4gIGlmIChjdXJyZW50QXhpcyAhPT0gJ3h5JyAmJiBzdGFydEF4aXMgIT09ICd4eScgJiYgc3RhcnRBeGlzICE9PSBjdXJyZW50QXhpcykge1xyXG4gICAgLy8gY2FuY2VsIHRoZSBwcmVwYXJlZCBhY3Rpb25cclxuICAgIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgPSBudWxsO1xyXG5cclxuICAgIC8vIHRoZW4gdHJ5IHRvIGdldCBhIGRyYWcgZnJvbSBhbm90aGVyIGluZXJhY3RhYmxlXHJcblxyXG4gICAgaWYgKCFpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKSB7XHJcblxyXG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xyXG5cclxuICAgICAgdmFyIGdldERyYWdnYWJsZSA9IGZ1bmN0aW9uIGdldERyYWdnYWJsZShpbnRlcmFjdGFibGUsIHNlbGVjdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gYnJvd3Nlci51c2VNYXRjaGVzU2VsZWN0b3JQb2x5ZmlsbCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcmFjdGFibGUgPT09IGludGVyYWN0aW9uLnRhcmdldCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLm1hbnVhbFN0YXJ0ICYmICFpbnRlcmFjdGFibGUudGVzdElnbm9yZUFsbG93KG9wdGlvbnMsIGVsZW1lbnQsIGV2ZW50VGFyZ2V0KSAmJiBtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIGVsZW1lbnRzKSkge1xyXG5cclxuICAgICAgICAgIHZhciBfYWN0aW9uID0gaW50ZXJhY3RhYmxlLmdldEFjdGlvbihpbnRlcmFjdGlvbi5kb3duUG9pbnRlciwgaW50ZXJhY3Rpb24uZG93bkV2ZW50LCBpbnRlcmFjdGlvbiwgZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKF9hY3Rpb24gJiYgX2FjdGlvbi5uYW1lID09PSAnZHJhZycgJiYgY2hlY2tTdGFydEF4aXMoY3VycmVudEF4aXMsIGludGVyYWN0YWJsZSkgJiYgYXV0b1N0YXJ0LnZhbGlkYXRlQWN0aW9uKF9hY3Rpb24sIGludGVyYWN0YWJsZSwgZWxlbWVudCwgZXZlbnRUYXJnZXQpKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3RhYmxlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xyXG5cclxuICAgICAgLy8gY2hlY2sgYWxsIGludGVyYWN0YWJsZXNcclxuICAgICAgd2hpbGUgKGlzLmVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgICB2YXIgZWxlbWVudEludGVyYWN0YWJsZSA9IHNjb3BlLmludGVyYWN0YWJsZXMuZ2V0KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudEludGVyYWN0YWJsZSAmJiBlbGVtZW50SW50ZXJhY3RhYmxlICE9PSBpbnRlcmFjdGlvbi50YXJnZXQgJiYgIWVsZW1lbnRJbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLm1hbnVhbFN0YXJ0KSB7XHJcblxyXG4gICAgICAgICAgYWN0aW9uID0gZWxlbWVudEludGVyYWN0YWJsZS5nZXRBY3Rpb24oaW50ZXJhY3Rpb24uZG93blBvaW50ZXIsIGludGVyYWN0aW9uLmRvd25FdmVudCwgaW50ZXJhY3Rpb24sIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi5uYW1lID09PSAnZHJhZycgJiYgY2hlY2tTdGFydEF4aXMoY3VycmVudEF4aXMsIGVsZW1lbnRJbnRlcmFjdGFibGUpKSB7XHJcblxyXG4gICAgICAgICAgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSA9ICdkcmFnJztcclxuICAgICAgICAgIGludGVyYWN0aW9uLnRhcmdldCA9IGVsZW1lbnRJbnRlcmFjdGFibGU7XHJcbiAgICAgICAgICBpbnRlcmFjdGlvbi5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGVjdG9ySW50ZXJhY3RhYmxlID0gc2NvcGUuaW50ZXJhY3RhYmxlcy5mb3JFYWNoU2VsZWN0b3IoZ2V0RHJhZ2dhYmxlLCBlbGVtZW50KTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdG9ySW50ZXJhY3RhYmxlKSB7XHJcbiAgICAgICAgICBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lID0gJ2RyYWcnO1xyXG4gICAgICAgICAgaW50ZXJhY3Rpb24udGFyZ2V0ID0gc2VsZWN0b3JJbnRlcmFjdGFibGU7XHJcbiAgICAgICAgICBpbnRlcmFjdGlvbi5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudCA9IHBhcmVudE5vZGUoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tTdGFydEF4aXMoc3RhcnRBeGlzLCBpbnRlcmFjdGFibGUpIHtcclxuICBpZiAoIWludGVyYWN0YWJsZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRoaXNBeGlzID0gaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZy5zdGFydEF4aXM7XHJcblxyXG4gIHJldHVybiBzdGFydEF4aXMgPT09ICd4eScgfHwgdGhpc0F4aXMgPT09ICd4eScgfHwgdGhpc0F4aXMgPT09IHN0YXJ0QXhpcztcclxufVxyXG5cclxufSx7XCIuLi9hY3Rpb25zL2RyYWdcIjo3LFwiLi4vc2NvcGVcIjozNCxcIi4uL3V0aWxzL2Jyb3dzZXJcIjozNyxcIi4uL3V0aWxzL2RvbVV0aWxzXCI6MzksXCIuLi91dGlscy9pc1wiOjQ2LFwiLi9iYXNlXCI6MTN9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnJlcXVpcmUoJy4vYmFzZScpLnNldEFjdGlvbkRlZmF1bHRzKHJlcXVpcmUoJy4uL2FjdGlvbnMvZ2VzdHVyZScpKTtcclxuXHJcbn0se1wiLi4vYWN0aW9ucy9nZXN0dXJlXCI6OSxcIi4vYmFzZVwiOjEzfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5yZXF1aXJlKCcuL2Jhc2UnKS5zZXRBY3Rpb25EZWZhdWx0cyhyZXF1aXJlKCcuLi9hY3Rpb25zL3Jlc2l6ZScpKTtcclxuXHJcbn0se1wiLi4vYWN0aW9ucy9yZXNpemVcIjoxMCxcIi4vYmFzZVwiOjEzfV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBiYXNlOiB7XHJcbiAgICBhY2NlcHQ6IG51bGwsXHJcbiAgICBwcmV2ZW50RGVmYXVsdDogJ2F1dG8nLFxyXG4gICAgZGVsdGFTb3VyY2U6ICdwYWdlJ1xyXG4gIH0sXHJcblxyXG4gIHBlckFjdGlvbjoge1xyXG4gICAgb3JpZ2luOiB7IHg6IDAsIHk6IDAgfSxcclxuXHJcbiAgICAvLyBvbmx5IGFsbG93IGxlZnQgYnV0dG9uIGJ5IGRlZmF1bHRcclxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25zI1JldHVybl92YWx1ZVxyXG4gICAgbW91c2VCdXR0b25zOiAxLFxyXG5cclxuICAgIGluZXJ0aWE6IHtcclxuICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgIHJlc2lzdGFuY2U6IDEwLCAvLyB0aGUgbGFtYmRhIGluIGV4cG9uZW50aWFsIGRlY2F5XHJcbiAgICAgIG1pblNwZWVkOiAxMDAsIC8vIHRhcmdldCBzcGVlZCBtdXN0IGJlIGFib3ZlIHRoaXMgZm9yIGluZXJ0aWEgdG8gc3RhcnRcclxuICAgICAgZW5kU3BlZWQ6IDEwLCAvLyB0aGUgc3BlZWQgYXQgd2hpY2ggaW5lcnRpYSBpcyBzbG93IGVub3VnaCB0byBzdG9wXHJcbiAgICAgIGFsbG93UmVzdW1lOiB0cnVlLCAvLyBhbGxvdyByZXN1bWluZyBhbiBhY3Rpb24gaW4gaW5lcnRpYSBwaGFzZVxyXG4gICAgICBzbW9vdGhFbmREdXJhdGlvbjogMzAwIC8vIGFuaW1hdGUgdG8gc25hcC9yZXN0cmljdCBlbmRPbmx5IGlmIHRoZXJlJ3Mgbm8gaW5lcnRpYVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogYnJvd3NlciBlbnRyeSBwb2ludCAqL1xyXG5cclxuLy8gTGVnYWN5IGJyb3dzZXIgc3VwcG9ydFxyXG5yZXF1aXJlKCcuL2xlZ2FjeUJyb3dzZXJzJyk7XHJcblxyXG4vLyBpbmVydGlhXHJcbnJlcXVpcmUoJy4vaW5lcnRpYScpO1xyXG5cclxuLy8gbW9kaWZpZXJzXHJcbnJlcXVpcmUoJy4vbW9kaWZpZXJzL3NuYXAnKTtcclxucmVxdWlyZSgnLi9tb2RpZmllcnMvcmVzdHJpY3QnKTtcclxuXHJcbi8vIHBvaW50ZXJFdmVudHNcclxucmVxdWlyZSgnLi9wb2ludGVyRXZlbnRzL2Jhc2UnKTtcclxucmVxdWlyZSgnLi9wb2ludGVyRXZlbnRzL2hvbGRSZXBlYXQnKTtcclxucmVxdWlyZSgnLi9wb2ludGVyRXZlbnRzL2ludGVyYWN0YWJsZVRhcmdldHMnKTtcclxuXHJcbi8vIGRlbGF5XHJcbnJlcXVpcmUoJy4vYXV0b1N0YXJ0L2RlbGF5Jyk7XHJcblxyXG4vLyBhY3Rpb25zXHJcbnJlcXVpcmUoJy4vYWN0aW9ucy9nZXN0dXJlJyk7XHJcbnJlcXVpcmUoJy4vYWN0aW9ucy9yZXNpemUnKTtcclxucmVxdWlyZSgnLi9hY3Rpb25zL2RyYWcnKTtcclxucmVxdWlyZSgnLi9hY3Rpb25zL2Ryb3AnKTtcclxuXHJcbi8vIGxvYWQgdGhlc2UgbW9kaWZpZXJzIGFmdGVyIHJlc2l6ZSBpcyBsb2FkZWRcclxucmVxdWlyZSgnLi9tb2RpZmllcnMvc25hcFNpemUnKTtcclxucmVxdWlyZSgnLi9tb2RpZmllcnMvcmVzdHJpY3RFZGdlcycpO1xyXG5yZXF1aXJlKCcuL21vZGlmaWVycy9yZXN0cmljdFNpemUnKTtcclxuXHJcbi8vIGF1dG9TdGFydCBhY3Rpb25zXHJcbnJlcXVpcmUoJy4vYXV0b1N0YXJ0L2dlc3R1cmUnKTtcclxucmVxdWlyZSgnLi9hdXRvU3RhcnQvcmVzaXplJyk7XHJcbnJlcXVpcmUoJy4vYXV0b1N0YXJ0L2RyYWcnKTtcclxuXHJcbi8vIEludGVyYWN0YWJsZSBwcmV2ZW50RGVmYXVsdCBzZXR0aW5nXHJcbnJlcXVpcmUoJy4vaW50ZXJhY3RhYmxlUHJldmVudERlZmF1bHQuanMnKTtcclxuXHJcbi8vIGF1dG9TY3JvbGxcclxucmVxdWlyZSgnLi9hdXRvU2Nyb2xsJyk7XHJcblxyXG4vLyBleHBvcnQgaW50ZXJhY3RcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ludGVyYWN0Jyk7XHJcblxyXG59LHtcIi4vYWN0aW9ucy9kcmFnXCI6NyxcIi4vYWN0aW9ucy9kcm9wXCI6OCxcIi4vYWN0aW9ucy9nZXN0dXJlXCI6OSxcIi4vYWN0aW9ucy9yZXNpemVcIjoxMCxcIi4vYXV0b1Njcm9sbFwiOjExLFwiLi9hdXRvU3RhcnQvZGVsYXlcIjoxNCxcIi4vYXV0b1N0YXJ0L2RyYWdcIjoxNSxcIi4vYXV0b1N0YXJ0L2dlc3R1cmVcIjoxNixcIi4vYXV0b1N0YXJ0L3Jlc2l6ZVwiOjE3LFwiLi9pbmVydGlhXCI6MjAsXCIuL2ludGVyYWN0XCI6MjEsXCIuL2ludGVyYWN0YWJsZVByZXZlbnREZWZhdWx0LmpzXCI6MjIsXCIuL2xlZ2FjeUJyb3dzZXJzXCI6MjMsXCIuL21vZGlmaWVycy9yZXN0cmljdFwiOjI1LFwiLi9tb2RpZmllcnMvcmVzdHJpY3RFZGdlc1wiOjI2LFwiLi9tb2RpZmllcnMvcmVzdHJpY3RTaXplXCI6MjcsXCIuL21vZGlmaWVycy9zbmFwXCI6MjgsXCIuL21vZGlmaWVycy9zbmFwU2l6ZVwiOjI5LFwiLi9wb2ludGVyRXZlbnRzL2Jhc2VcIjozMSxcIi4vcG9pbnRlckV2ZW50cy9ob2xkUmVwZWF0XCI6MzIsXCIuL3BvaW50ZXJFdmVudHMvaW50ZXJhY3RhYmxlVGFyZ2V0c1wiOjMzfV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSW50ZXJhY3RFdmVudCA9IHJlcXVpcmUoJy4vSW50ZXJhY3RFdmVudCcpO1xyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuL0ludGVyYWN0aW9uJyk7XHJcbnZhciBtb2RpZmllcnMgPSByZXF1aXJlKCcuL21vZGlmaWVycycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBhbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFmJyk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCduZXcnLCBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcclxuICBpbnRlcmFjdGlvbi5pbmVydGlhU3RhdHVzID0ge1xyXG4gICAgYWN0aXZlOiBmYWxzZSxcclxuICAgIHNtb290aEVuZDogZmFsc2UsXHJcbiAgICBhbGxvd1Jlc3VtZTogZmFsc2UsXHJcblxyXG4gICAgc3RhcnRFdmVudDogbnVsbCxcclxuICAgIHVwQ29vcmRzOiB7fSxcclxuXHJcbiAgICB4ZTogMCwgeWU6IDAsXHJcbiAgICBzeDogMCwgc3k6IDAsXHJcblxyXG4gICAgdDA6IDAsXHJcbiAgICB2eDA6IDAsIHZ5czogMCxcclxuICAgIGR1cmF0aW9uOiAwLFxyXG5cclxuICAgIGxhbWJkYV92MDogMCxcclxuICAgIG9uZV92ZV92MDogMCxcclxuICAgIGk6IG51bGxcclxuICB9O1xyXG5cclxuICBpbnRlcmFjdGlvbi5ib3VuZEluZXJ0aWFGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBpbmVydGlhRnJhbWUuYXBwbHkoaW50ZXJhY3Rpb24pO1xyXG4gIH07XHJcbiAgaW50ZXJhY3Rpb24uYm91bmRTbW9vdGhFbmRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzbW9vdGhFbmRGcmFtZS5hcHBseShpbnRlcmFjdGlvbik7XHJcbiAgfTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdkb3duJywgZnVuY3Rpb24gKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQsXHJcbiAgICAgIHBvaW50ZXIgPSBfcmVmLnBvaW50ZXIsXHJcbiAgICAgIGV2ZW50VGFyZ2V0ID0gX3JlZi5ldmVudFRhcmdldDtcclxuXHJcbiAgdmFyIHN0YXR1cyA9IGludGVyYWN0aW9uLmluZXJ0aWFTdGF0dXM7XHJcblxyXG4gIC8vIENoZWNrIGlmIHRoZSBkb3duIGV2ZW50IGhpdHMgdGhlIGN1cnJlbnQgaW5lcnRpYSB0YXJnZXRcclxuICBpZiAoc3RhdHVzLmFjdGl2ZSkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudFRhcmdldDtcclxuXHJcbiAgICAvLyBjbGltYiB1cCB0aGUgRE9NIHRyZWUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0XHJcbiAgICB3aGlsZSAodXRpbHMuaXMuZWxlbWVudChlbGVtZW50KSkge1xyXG5cclxuICAgICAgLy8gaWYgaW50ZXJhY3Rpb24gZWxlbWVudCBpcyB0aGUgY3VycmVudCBpbmVydGlhIHRhcmdldCBlbGVtZW50XHJcbiAgICAgIGlmIChlbGVtZW50ID09PSBpbnRlcmFjdGlvbi5lbGVtZW50KSB7XHJcbiAgICAgICAgLy8gc3RvcCBpbmVydGlhXHJcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUuY2FuY2VsKHN0YXR1cy5pKTtcclxuICAgICAgICBzdGF0dXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgaW50ZXJhY3Rpb24uc2ltdWxhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwb2ludGVycyB0byB0aGUgZG93biBldmVudCdzIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgaW50ZXJhY3Rpb24udXBkYXRlUG9pbnRlcihwb2ludGVyKTtcclxuICAgICAgICB1dGlscy5zZXRDb29yZHMoaW50ZXJhY3Rpb24uY3VyQ29vcmRzLCBpbnRlcmFjdGlvbi5wb2ludGVycyk7XHJcblxyXG4gICAgICAgIC8vIGZpcmUgYXBwcm9wcmlhdGUgc2lnbmFsc1xyXG4gICAgICAgIHZhciBzaWduYWxBcmcgPSB7IGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbiB9O1xyXG4gICAgICAgIEludGVyYWN0aW9uLnNpZ25hbHMuZmlyZSgnYmVmb3JlLWFjdGlvbi1tb3ZlJywgc2lnbmFsQXJnKTtcclxuICAgICAgICBJbnRlcmFjdGlvbi5zaWduYWxzLmZpcmUoJ2FjdGlvbi1yZXN1bWUnLCBzaWduYWxBcmcpO1xyXG5cclxuICAgICAgICAvLyBmaXJlIGEgcmV1bWUgZXZlbnRcclxuICAgICAgICB2YXIgcmVzdW1lRXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudChpbnRlcmFjdGlvbiwgZXZlbnQsIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUsICdpbmVydGlhcmVzdW1lJywgaW50ZXJhY3Rpb24uZWxlbWVudCk7XHJcblxyXG4gICAgICAgIGludGVyYWN0aW9uLnRhcmdldC5maXJlKHJlc3VtZUV2ZW50KTtcclxuICAgICAgICBpbnRlcmFjdGlvbi5wcmV2RXZlbnQgPSByZXN1bWVFdmVudDtcclxuICAgICAgICBtb2RpZmllcnMucmVzZXRTdGF0dXNlcyhpbnRlcmFjdGlvbi5tb2RpZmllclN0YXR1c2VzKTtcclxuXHJcbiAgICAgICAgdXRpbHMuY29weUNvb3JkcyhpbnRlcmFjdGlvbi5wcmV2Q29vcmRzLCBpbnRlcmFjdGlvbi5jdXJDb29yZHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50ID0gdXRpbHMucGFyZW50Tm9kZShlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbigndXAnLCBmdW5jdGlvbiAoX3JlZjIpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMi5pbnRlcmFjdGlvbixcclxuICAgICAgZXZlbnQgPSBfcmVmMi5ldmVudDtcclxuXHJcbiAgdmFyIHN0YXR1cyA9IGludGVyYWN0aW9uLmluZXJ0aWFTdGF0dXM7XHJcblxyXG4gIGlmICghaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSB8fCBzdGF0dXMuYWN0aXZlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgdGFyZ2V0ID0gaW50ZXJhY3Rpb24udGFyZ2V0O1xyXG4gIHZhciBvcHRpb25zID0gdGFyZ2V0ICYmIHRhcmdldC5vcHRpb25zO1xyXG4gIHZhciBpbmVydGlhT3B0aW9ucyA9IG9wdGlvbnMgJiYgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSAmJiBvcHRpb25zW2ludGVyYWN0aW9uLnByZXBhcmVkLm5hbWVdLmluZXJ0aWE7XHJcblxyXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICB2YXIgc3RhdHVzZXMgPSB7fTtcclxuICB2YXIgcGFnZSA9IHV0aWxzLmV4dGVuZCh7fSwgaW50ZXJhY3Rpb24uY3VyQ29vcmRzLnBhZ2UpO1xyXG4gIHZhciBwb2ludGVyU3BlZWQgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEuY2xpZW50LnNwZWVkO1xyXG5cclxuICB2YXIgc21vb3RoRW5kID0gZmFsc2U7XHJcbiAgdmFyIG1vZGlmaWVyUmVzdWx0ID0gdm9pZCAwO1xyXG5cclxuICAvLyBjaGVjayBpZiBpbmVydGlhIHNob3VsZCBiZSBzdGFydGVkXHJcbiAgdmFyIGluZXJ0aWFQb3NzaWJsZSA9IGluZXJ0aWFPcHRpb25zICYmIGluZXJ0aWFPcHRpb25zLmVuYWJsZWQgJiYgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSAhPT0gJ2dlc3R1cmUnICYmIGV2ZW50ICE9PSBzdGF0dXMuc3RhcnRFdmVudDtcclxuXHJcbiAgdmFyIGluZXJ0aWEgPSBpbmVydGlhUG9zc2libGUgJiYgbm93IC0gaW50ZXJhY3Rpb24uY3VyQ29vcmRzLnRpbWVTdGFtcCA8IDUwICYmIHBvaW50ZXJTcGVlZCA+IGluZXJ0aWFPcHRpb25zLm1pblNwZWVkICYmIHBvaW50ZXJTcGVlZCA+IGluZXJ0aWFPcHRpb25zLmVuZFNwZWVkO1xyXG5cclxuICB2YXIgbW9kaWZpZXJBcmcgPSB7XHJcbiAgICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sXHJcbiAgICBwYWdlQ29vcmRzOiBwYWdlLFxyXG4gICAgc3RhdHVzZXM6IHN0YXR1c2VzLFxyXG4gICAgcHJlRW5kOiB0cnVlLFxyXG4gICAgcmVxdWlyZUVuZE9ubHk6IHRydWVcclxuICB9O1xyXG5cclxuICAvLyBzbW9vdGhFbmRcclxuICBpZiAoaW5lcnRpYVBvc3NpYmxlICYmICFpbmVydGlhKSB7XHJcbiAgICBtb2RpZmllcnMucmVzZXRTdGF0dXNlcyhzdGF0dXNlcyk7XHJcblxyXG4gICAgbW9kaWZpZXJSZXN1bHQgPSBtb2RpZmllcnMuc2V0QWxsKG1vZGlmaWVyQXJnKTtcclxuXHJcbiAgICBpZiAobW9kaWZpZXJSZXN1bHQuc2hvdWxkTW92ZSAmJiBtb2RpZmllclJlc3VsdC5sb2NrZWQpIHtcclxuICAgICAgc21vb3RoRW5kID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghKGluZXJ0aWEgfHwgc21vb3RoRW5kKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdXRpbHMuY29weUNvb3JkcyhzdGF0dXMudXBDb29yZHMsIGludGVyYWN0aW9uLmN1ckNvb3Jkcyk7XHJcblxyXG4gIGludGVyYWN0aW9uLnBvaW50ZXJzWzBdID0gc3RhdHVzLnN0YXJ0RXZlbnQgPSBuZXcgSW50ZXJhY3RFdmVudChpbnRlcmFjdGlvbiwgZXZlbnQsIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUsICdpbmVydGlhc3RhcnQnLCBpbnRlcmFjdGlvbi5lbGVtZW50KTtcclxuXHJcbiAgc3RhdHVzLnQwID0gbm93O1xyXG5cclxuICBzdGF0dXMuYWN0aXZlID0gdHJ1ZTtcclxuICBzdGF0dXMuYWxsb3dSZXN1bWUgPSBpbmVydGlhT3B0aW9ucy5hbGxvd1Jlc3VtZTtcclxuICBpbnRlcmFjdGlvbi5zaW11bGF0aW9uID0gc3RhdHVzO1xyXG5cclxuICB0YXJnZXQuZmlyZShzdGF0dXMuc3RhcnRFdmVudCk7XHJcblxyXG4gIGlmIChpbmVydGlhKSB7XHJcbiAgICBzdGF0dXMudngwID0gaW50ZXJhY3Rpb24ucG9pbnRlckRlbHRhLmNsaWVudC52eDtcclxuICAgIHN0YXR1cy52eTAgPSBpbnRlcmFjdGlvbi5wb2ludGVyRGVsdGEuY2xpZW50LnZ5O1xyXG4gICAgc3RhdHVzLnYwID0gcG9pbnRlclNwZWVkO1xyXG5cclxuICAgIGNhbGNJbmVydGlhKGludGVyYWN0aW9uLCBzdGF0dXMpO1xyXG5cclxuICAgIHV0aWxzLmV4dGVuZChwYWdlLCBpbnRlcmFjdGlvbi5jdXJDb29yZHMucGFnZSk7XHJcblxyXG4gICAgcGFnZS54ICs9IHN0YXR1cy54ZTtcclxuICAgIHBhZ2UueSArPSBzdGF0dXMueWU7XHJcblxyXG4gICAgbW9kaWZpZXJzLnJlc2V0U3RhdHVzZXMoc3RhdHVzZXMpO1xyXG5cclxuICAgIG1vZGlmaWVyUmVzdWx0ID0gbW9kaWZpZXJzLnNldEFsbChtb2RpZmllckFyZyk7XHJcblxyXG4gICAgc3RhdHVzLm1vZGlmaWVkWGUgKz0gbW9kaWZpZXJSZXN1bHQuZHg7XHJcbiAgICBzdGF0dXMubW9kaWZpZWRZZSArPSBtb2RpZmllclJlc3VsdC5keTtcclxuXHJcbiAgICBzdGF0dXMuaSA9IGFuaW1hdGlvbkZyYW1lLnJlcXVlc3QoaW50ZXJhY3Rpb24uYm91bmRJbmVydGlhRnJhbWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGF0dXMuc21vb3RoRW5kID0gdHJ1ZTtcclxuICAgIHN0YXR1cy54ZSA9IG1vZGlmaWVyUmVzdWx0LmR4O1xyXG4gICAgc3RhdHVzLnllID0gbW9kaWZpZXJSZXN1bHQuZHk7XHJcblxyXG4gICAgc3RhdHVzLnN4ID0gc3RhdHVzLnN5ID0gMDtcclxuXHJcbiAgICBzdGF0dXMuaSA9IGFuaW1hdGlvbkZyYW1lLnJlcXVlc3QoaW50ZXJhY3Rpb24uYm91bmRTbW9vdGhFbmRGcmFtZSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ3N0b3AtYWN0aXZlJywgZnVuY3Rpb24gKF9yZWYzKSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjMuaW50ZXJhY3Rpb247XHJcblxyXG4gIHZhciBzdGF0dXMgPSBpbnRlcmFjdGlvbi5pbmVydGlhU3RhdHVzO1xyXG5cclxuICBpZiAoc3RhdHVzLmFjdGl2ZSkge1xyXG4gICAgYW5pbWF0aW9uRnJhbWUuY2FuY2VsKHN0YXR1cy5pKTtcclxuICAgIHN0YXR1cy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIGludGVyYWN0aW9uLnNpbXVsYXRpb24gPSBudWxsO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBjYWxjSW5lcnRpYShpbnRlcmFjdGlvbiwgc3RhdHVzKSB7XHJcbiAgdmFyIGluZXJ0aWFPcHRpb25zID0gaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnNbaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV0uaW5lcnRpYTtcclxuICB2YXIgbGFtYmRhID0gaW5lcnRpYU9wdGlvbnMucmVzaXN0YW5jZTtcclxuICB2YXIgaW5lcnRpYUR1ciA9IC1NYXRoLmxvZyhpbmVydGlhT3B0aW9ucy5lbmRTcGVlZCAvIHN0YXR1cy52MCkgLyBsYW1iZGE7XHJcblxyXG4gIHN0YXR1cy54MCA9IGludGVyYWN0aW9uLnByZXZFdmVudC5wYWdlWDtcclxuICBzdGF0dXMueTAgPSBpbnRlcmFjdGlvbi5wcmV2RXZlbnQucGFnZVk7XHJcbiAgc3RhdHVzLnQwID0gc3RhdHVzLnN0YXJ0RXZlbnQudGltZVN0YW1wIC8gMTAwMDtcclxuICBzdGF0dXMuc3ggPSBzdGF0dXMuc3kgPSAwO1xyXG5cclxuICBzdGF0dXMubW9kaWZpZWRYZSA9IHN0YXR1cy54ZSA9IChzdGF0dXMudngwIC0gaW5lcnRpYUR1cikgLyBsYW1iZGE7XHJcbiAgc3RhdHVzLm1vZGlmaWVkWWUgPSBzdGF0dXMueWUgPSAoc3RhdHVzLnZ5MCAtIGluZXJ0aWFEdXIpIC8gbGFtYmRhO1xyXG4gIHN0YXR1cy50ZSA9IGluZXJ0aWFEdXI7XHJcblxyXG4gIHN0YXR1cy5sYW1iZGFfdjAgPSBsYW1iZGEgLyBzdGF0dXMudjA7XHJcbiAgc3RhdHVzLm9uZV92ZV92MCA9IDEgLSBpbmVydGlhT3B0aW9ucy5lbmRTcGVlZCAvIHN0YXR1cy52MDtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5lcnRpYUZyYW1lKCkge1xyXG4gIHVwZGF0ZUluZXJ0aWFDb29yZHModGhpcyk7XHJcbiAgdXRpbHMuc2V0Q29vcmREZWx0YXModGhpcy5wb2ludGVyRGVsdGEsIHRoaXMucHJldkNvb3JkcywgdGhpcy5jdXJDb29yZHMpO1xyXG5cclxuICB2YXIgc3RhdHVzID0gdGhpcy5pbmVydGlhU3RhdHVzO1xyXG4gIHZhciBvcHRpb25zID0gdGhpcy50YXJnZXQub3B0aW9uc1t0aGlzLnByZXBhcmVkLm5hbWVdLmluZXJ0aWE7XHJcbiAgdmFyIGxhbWJkYSA9IG9wdGlvbnMucmVzaXN0YW5jZTtcclxuICB2YXIgdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCAtIHN0YXR1cy50MDtcclxuXHJcbiAgaWYgKHQgPCBzdGF0dXMudGUpIHtcclxuXHJcbiAgICB2YXIgcHJvZ3Jlc3MgPSAxIC0gKE1hdGguZXhwKC1sYW1iZGEgKiB0KSAtIHN0YXR1cy5sYW1iZGFfdjApIC8gc3RhdHVzLm9uZV92ZV92MDtcclxuXHJcbiAgICBpZiAoc3RhdHVzLm1vZGlmaWVkWGUgPT09IHN0YXR1cy54ZSAmJiBzdGF0dXMubW9kaWZpZWRZZSA9PT0gc3RhdHVzLnllKSB7XHJcbiAgICAgIHN0YXR1cy5zeCA9IHN0YXR1cy54ZSAqIHByb2dyZXNzO1xyXG4gICAgICBzdGF0dXMuc3kgPSBzdGF0dXMueWUgKiBwcm9ncmVzcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBxdWFkUG9pbnQgPSB1dGlscy5nZXRRdWFkcmF0aWNDdXJ2ZVBvaW50KDAsIDAsIHN0YXR1cy54ZSwgc3RhdHVzLnllLCBzdGF0dXMubW9kaWZpZWRYZSwgc3RhdHVzLm1vZGlmaWVkWWUsIHByb2dyZXNzKTtcclxuXHJcbiAgICAgIHN0YXR1cy5zeCA9IHF1YWRQb2ludC54O1xyXG4gICAgICBzdGF0dXMuc3kgPSBxdWFkUG9pbnQueTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRvTW92ZSgpO1xyXG5cclxuICAgIHN0YXR1cy5pID0gYW5pbWF0aW9uRnJhbWUucmVxdWVzdCh0aGlzLmJvdW5kSW5lcnRpYUZyYW1lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdHVzLnN4ID0gc3RhdHVzLm1vZGlmaWVkWGU7XHJcbiAgICBzdGF0dXMuc3kgPSBzdGF0dXMubW9kaWZpZWRZZTtcclxuXHJcbiAgICB0aGlzLmRvTW92ZSgpO1xyXG4gICAgdGhpcy5lbmQoc3RhdHVzLnN0YXJ0RXZlbnQpO1xyXG4gICAgc3RhdHVzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zaW11bGF0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHV0aWxzLmNvcHlDb29yZHModGhpcy5wcmV2Q29vcmRzLCB0aGlzLmN1ckNvb3Jkcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNtb290aEVuZEZyYW1lKCkge1xyXG4gIHVwZGF0ZUluZXJ0aWFDb29yZHModGhpcyk7XHJcblxyXG4gIHZhciBzdGF0dXMgPSB0aGlzLmluZXJ0aWFTdGF0dXM7XHJcbiAgdmFyIHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXR1cy50MDtcclxuICB2YXIgZHVyYXRpb24gPSB0aGlzLnRhcmdldC5vcHRpb25zW3RoaXMucHJlcGFyZWQubmFtZV0uaW5lcnRpYS5zbW9vdGhFbmREdXJhdGlvbjtcclxuXHJcbiAgaWYgKHQgPCBkdXJhdGlvbikge1xyXG4gICAgc3RhdHVzLnN4ID0gdXRpbHMuZWFzZU91dFF1YWQodCwgMCwgc3RhdHVzLnhlLCBkdXJhdGlvbik7XHJcbiAgICBzdGF0dXMuc3kgPSB1dGlscy5lYXNlT3V0UXVhZCh0LCAwLCBzdGF0dXMueWUsIGR1cmF0aW9uKTtcclxuXHJcbiAgICB0aGlzLnBvaW50ZXJNb3ZlKHN0YXR1cy5zdGFydEV2ZW50LCBzdGF0dXMuc3RhcnRFdmVudCk7XHJcblxyXG4gICAgc3RhdHVzLmkgPSBhbmltYXRpb25GcmFtZS5yZXF1ZXN0KHRoaXMuYm91bmRTbW9vdGhFbmRGcmFtZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXR1cy5zeCA9IHN0YXR1cy54ZTtcclxuICAgIHN0YXR1cy5zeSA9IHN0YXR1cy55ZTtcclxuXHJcbiAgICB0aGlzLnBvaW50ZXJNb3ZlKHN0YXR1cy5zdGFydEV2ZW50LCBzdGF0dXMuc3RhcnRFdmVudCk7XHJcbiAgICB0aGlzLmVuZChzdGF0dXMuc3RhcnRFdmVudCk7XHJcblxyXG4gICAgc3RhdHVzLnNtb290aEVuZCA9IHN0YXR1cy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIHRoaXMuc2ltdWxhdGlvbiA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVJbmVydGlhQ29vcmRzKGludGVyYWN0aW9uKSB7XHJcbiAgdmFyIHN0YXR1cyA9IGludGVyYWN0aW9uLmluZXJ0aWFTdGF0dXM7XHJcblxyXG4gIC8vIHJldHVybiBpZiBpbmVydGlhIGlzbid0IHJ1bm5pbmdcclxuICBpZiAoIXN0YXR1cy5hY3RpdmUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBwYWdlVXAgPSBzdGF0dXMudXBDb29yZHMucGFnZTtcclxuICB2YXIgY2xpZW50VXAgPSBzdGF0dXMudXBDb29yZHMuY2xpZW50O1xyXG5cclxuICB1dGlscy5zZXRDb29yZHMoaW50ZXJhY3Rpb24uY3VyQ29vcmRzLCBbe1xyXG4gICAgcGFnZVg6IHBhZ2VVcC54ICsgc3RhdHVzLnN4LFxyXG4gICAgcGFnZVk6IHBhZ2VVcC55ICsgc3RhdHVzLnN5LFxyXG4gICAgY2xpZW50WDogY2xpZW50VXAueCArIHN0YXR1cy5zeCxcclxuICAgIGNsaWVudFk6IGNsaWVudFVwLnkgKyBzdGF0dXMuc3lcclxuICB9XSk7XHJcbn1cclxuXHJcbn0se1wiLi9JbnRlcmFjdEV2ZW50XCI6MyxcIi4vSW50ZXJhY3Rpb25cIjo1LFwiLi9tb2RpZmllcnNcIjoyNCxcIi4vdXRpbHNcIjo0NCxcIi4vdXRpbHMvcmFmXCI6NTB9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJyk7XHJcbnZhciBldmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50cycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBzY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUnKTtcclxudmFyIEludGVyYWN0YWJsZSA9IHJlcXVpcmUoJy4vSW50ZXJhY3RhYmxlJyk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb24nKTtcclxuXHJcbnZhciBnbG9iYWxFdmVudHMgPSB7fTtcclxuXHJcbi8qXFxcclxuICogaW50ZXJhY3RcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogVGhlIG1ldGhvZHMgb2YgdGhpcyB2YXJpYWJsZSBjYW4gYmUgdXNlZCB0byBzZXQgZWxlbWVudHMgYXNcclxuICogaW50ZXJhY3RhYmxlcyBhbmQgYWxzbyB0byBjaGFuZ2UgdmFyaW91cyBkZWZhdWx0IHNldHRpbmdzLlxyXG4gKlxyXG4gKiBDYWxsaW5nIGl0IGFzIGEgZnVuY3Rpb24gYW5kIHBhc3NpbmcgYW4gZWxlbWVudCBvciBhIHZhbGlkIENTUyBzZWxlY3RvclxyXG4gKiBzdHJpbmcgcmV0dXJucyBhbiBJbnRlcmFjdGFibGUgb2JqZWN0IHdoaWNoIGhhcyB2YXJpb3VzIG1ldGhvZHMgdG9cclxuICogY29uZmlndXJlIGl0LlxyXG4gKlxyXG4gLSBlbGVtZW50IChFbGVtZW50IHwgc3RyaW5nKSBUaGUgSFRNTCBvciBTVkcgRWxlbWVudCB0byBpbnRlcmFjdCB3aXRoIG9yIENTUyBzZWxlY3RvclxyXG4gPSAob2JqZWN0KSBBbiBASW50ZXJhY3RhYmxlXHJcbiAqXHJcbiA+IFVzYWdlXHJcbiB8IGludGVyYWN0KCcjZHJhZ2dhYmxlJykuZHJhZ2dhYmxlKHRydWUpO1xyXG4gfFxyXG4gfCB2YXIgcmVjdGFibGVzID0gaW50ZXJhY3QoJ3JlY3QnKTtcclxuIHwgcmVjdGFibGVzXHJcbiB8ICAgICAuZ2VzdHVyYWJsZSh0cnVlKVxyXG4gfCAgICAgLm9uKCdnZXN0dXJlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gfCAgICAgICAgIC8vIC4uLlxyXG4gfCAgICAgfSk7XHJcblxcKi9cclxuZnVuY3Rpb24gaW50ZXJhY3QoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gIHZhciBpbnRlcmFjdGFibGUgPSBzY29wZS5pbnRlcmFjdGFibGVzLmdldChlbGVtZW50LCBvcHRpb25zKTtcclxuXHJcbiAgaWYgKCFpbnRlcmFjdGFibGUpIHtcclxuICAgIGludGVyYWN0YWJsZSA9IG5ldyBJbnRlcmFjdGFibGUoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICBpbnRlcmFjdGFibGUuZXZlbnRzLmdsb2JhbCA9IGdsb2JhbEV2ZW50cztcclxuICB9XHJcblxyXG4gIHJldHVybiBpbnRlcmFjdGFibGU7XHJcbn1cclxuXHJcbi8qXFxcclxuICogaW50ZXJhY3QuaXNTZXRcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBzZXRcclxuIC0gZWxlbWVudCAoRWxlbWVudCkgVGhlIEVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yXHJcbiA9IChib29sZWFuKSBJbmRpY2F0ZXMgaWYgdGhlIGVsZW1lbnQgb3IgQ1NTIHNlbGVjdG9yIHdhcyBwcmV2aW91c2x5IHBhc3NlZCB0byBpbnRlcmFjdFxyXG5cXCovXHJcbmludGVyYWN0LmlzU2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gc2NvcGUuaW50ZXJhY3RhYmxlcy5pbmRleE9mRWxlbWVudChlbGVtZW50LCBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCkgIT09IC0xO1xyXG59O1xyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5vblxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGxpc3RlbmVyIGZvciBhbiBJbnRlcmFjdEV2ZW50IG9yIGFkZHMgYSBET00gZXZlbnQgdG9cclxuICogYGRvY3VtZW50YFxyXG4gKlxyXG4gLSB0eXBlICAgICAgIChzdHJpbmcgfCBhcnJheSB8IG9iamVjdCkgVGhlIHR5cGVzIG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yXHJcbiAtIGxpc3RlbmVyICAgKGZ1bmN0aW9uKSBUaGUgZnVuY3Rpb24gZXZlbnQgKHMpXHJcbiAtIG9wdGlvbnMgICAgKG9iamVjdCB8IGJvb2xlYW4pICNvcHRpb25hbCBvcHRpb25zIG9iamVjdCBvciB1c2VDYXB0dXJlIGZsYWcgZm9yIGFkZEV2ZW50TGlzdGVuZXJcclxuID0gKG9iamVjdCkgaW50ZXJhY3RcclxuXFwqL1xyXG5pbnRlcmFjdC5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xyXG4gIGlmICh1dGlscy5pcy5zdHJpbmcodHlwZSkgJiYgdHlwZS5zZWFyY2goJyAnKSAhPT0gLTEpIHtcclxuICAgIHR5cGUgPSB0eXBlLnRyaW0oKS5zcGxpdCgvICsvKTtcclxuICB9XHJcblxyXG4gIGlmICh1dGlscy5pcy5hcnJheSh0eXBlKSkge1xyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdHlwZSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWY7XHJcblxyXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcclxuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGV2ZW50VHlwZSA9IF9yZWY7XHJcblxyXG4gICAgICBpbnRlcmFjdC5vbihldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW50ZXJhY3Q7XHJcbiAgfVxyXG5cclxuICBpZiAodXRpbHMuaXMub2JqZWN0KHR5cGUpKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIHR5cGUpIHtcclxuICAgICAgaW50ZXJhY3Qub24ocHJvcCwgdHlwZVtwcm9wXSwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnRlcmFjdDtcclxuICB9XHJcblxyXG4gIC8vIGlmIGl0IGlzIGFuIEludGVyYWN0RXZlbnQgdHlwZSwgYWRkIGxpc3RlbmVyIHRvIGdsb2JhbEV2ZW50c1xyXG4gIGlmICh1dGlscy5jb250YWlucyhJbnRlcmFjdGFibGUuZXZlbnRUeXBlcywgdHlwZSkpIHtcclxuICAgIC8vIGlmIHRoaXMgdHlwZSBvZiBldmVudCB3YXMgbmV2ZXIgYm91bmRcclxuICAgIGlmICghZ2xvYmFsRXZlbnRzW3R5cGVdKSB7XHJcbiAgICAgIGdsb2JhbEV2ZW50c1t0eXBlXSA9IFtsaXN0ZW5lcl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnbG9iYWxFdmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIElmIG5vbiBJbnRlcmFjdEV2ZW50IHR5cGUsIGFkZEV2ZW50TGlzdGVuZXIgdG8gZG9jdW1lbnRcclxuICBlbHNlIHtcclxuICAgICAgZXZlbnRzLmFkZChzY29wZS5kb2N1bWVudCwgdHlwZSwgbGlzdGVuZXIsIHsgb3B0aW9uczogb3B0aW9ucyB9KTtcclxuICAgIH1cclxuXHJcbiAgcmV0dXJuIGludGVyYWN0O1xyXG59O1xyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5vZmZcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogUmVtb3ZlcyBhIGdsb2JhbCBJbnRlcmFjdEV2ZW50IGxpc3RlbmVyIG9yIERPTSBldmVudCBmcm9tIGBkb2N1bWVudGBcclxuICpcclxuIC0gdHlwZSAgICAgICAoc3RyaW5nIHwgYXJyYXkgfCBvYmplY3QpIFRoZSB0eXBlcyBvZiBldmVudHMgdGhhdCB3ZXJlIGxpc3RlbmVkIGZvclxyXG4gLSBsaXN0ZW5lciAgIChmdW5jdGlvbikgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcclxuIC0gb3B0aW9ucyAgICAob2JqZWN0IHwgYm9vbGVhbikgI29wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IG9yIHVzZUNhcHR1cmUgZmxhZyBmb3IgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG4gPSAob2JqZWN0KSBpbnRlcmFjdFxyXG4gXFwqL1xyXG5pbnRlcmFjdC5vZmYgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcclxuICBpZiAodXRpbHMuaXMuc3RyaW5nKHR5cGUpICYmIHR5cGUuc2VhcmNoKCcgJykgIT09IC0xKSB7XHJcbiAgICB0eXBlID0gdHlwZS50cmltKCkuc3BsaXQoLyArLyk7XHJcbiAgfVxyXG5cclxuICBpZiAodXRpbHMuaXMuYXJyYXkodHlwZSkpIHtcclxuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0eXBlLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWYyO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5Mikge1xyXG4gICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGV2ZW50VHlwZSA9IF9yZWYyO1xyXG5cclxuICAgICAgaW50ZXJhY3Qub2ZmKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnRlcmFjdDtcclxuICB9XHJcblxyXG4gIGlmICh1dGlscy5pcy5vYmplY3QodHlwZSkpIHtcclxuICAgIGZvciAodmFyIHByb3AgaW4gdHlwZSkge1xyXG4gICAgICBpbnRlcmFjdC5vZmYocHJvcCwgdHlwZVtwcm9wXSwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnRlcmFjdDtcclxuICB9XHJcblxyXG4gIGlmICghdXRpbHMuY29udGFpbnMoSW50ZXJhY3RhYmxlLmV2ZW50VHlwZXMsIHR5cGUpKSB7XHJcbiAgICBldmVudHMucmVtb3ZlKHNjb3BlLmRvY3VtZW50LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBpbmRleCA9IHZvaWQgMDtcclxuXHJcbiAgICBpZiAodHlwZSBpbiBnbG9iYWxFdmVudHMgJiYgKGluZGV4ID0gdXRpbHMuaW5kZXhPZihnbG9iYWxFdmVudHNbdHlwZV0sIGxpc3RlbmVyKSkgIT09IC0xKSB7XHJcbiAgICAgIGdsb2JhbEV2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGludGVyYWN0O1xyXG59O1xyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5kZWJ1Z1xyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBleHBvc2VzIGludGVybmFsIGRhdGFcclxuID0gKG9iamVjdCkgQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IG91dGxpbmUgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGV4cG9zZSBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xyXG5cXCovXHJcbmludGVyYWN0LmRlYnVnID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBzY29wZTtcclxufTtcclxuXHJcbi8vIGV4cG9zZSB0aGUgZnVuY3Rpb25zIHVzZWQgdG8gY2FsY3VsYXRlIG11bHRpLXRvdWNoIHByb3BlcnRpZXNcclxuaW50ZXJhY3QuZ2V0UG9pbnRlckF2ZXJhZ2UgPSB1dGlscy5wb2ludGVyQXZlcmFnZTtcclxuaW50ZXJhY3QuZ2V0VG91Y2hCQm94ID0gdXRpbHMudG91Y2hCQm94O1xyXG5pbnRlcmFjdC5nZXRUb3VjaERpc3RhbmNlID0gdXRpbHMudG91Y2hEaXN0YW5jZTtcclxuaW50ZXJhY3QuZ2V0VG91Y2hBbmdsZSA9IHV0aWxzLnRvdWNoQW5nbGU7XHJcblxyXG5pbnRlcmFjdC5nZXRFbGVtZW50UmVjdCA9IHV0aWxzLmdldEVsZW1lbnRSZWN0O1xyXG5pbnRlcmFjdC5nZXRFbGVtZW50Q2xpZW50UmVjdCA9IHV0aWxzLmdldEVsZW1lbnRDbGllbnRSZWN0O1xyXG5pbnRlcmFjdC5tYXRjaGVzU2VsZWN0b3IgPSB1dGlscy5tYXRjaGVzU2VsZWN0b3I7XHJcbmludGVyYWN0LmNsb3Nlc3QgPSB1dGlscy5jbG9zZXN0O1xyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5zdXBwb3J0c1RvdWNoXHJcbiBbIG1ldGhvZCBdXHJcbiAqXHJcbiA9IChib29sZWFuKSBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBpbnB1dFxyXG5cXCovXHJcbmludGVyYWN0LnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGJyb3dzZXIuc3VwcG9ydHNUb3VjaDtcclxufTtcclxuXHJcbi8qXFxcclxuICogaW50ZXJhY3Quc3VwcG9ydHNQb2ludGVyRXZlbnRcclxuIFsgbWV0aG9kIF1cclxuICpcclxuID0gKGJvb2xlYW4pIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIFBvaW50ZXJFdmVudHNcclxuXFwqL1xyXG5pbnRlcmFjdC5zdXBwb3J0c1BvaW50ZXJFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gYnJvd3Nlci5zdXBwb3J0c1BvaW50ZXJFdmVudDtcclxufTtcclxuXHJcbi8qXFxcclxuICogaW50ZXJhY3Quc3RvcFxyXG4gWyBtZXRob2QgXVxyXG4gKlxyXG4gKiBDYW5jZWxzIGFsbCBpbnRlcmFjdGlvbnMgKGVuZCBldmVudHMgYXJlIG5vdCBmaXJlZClcclxuICpcclxuIC0gZXZlbnQgKEV2ZW50KSBBbiBldmVudCBvbiB3aGljaCB0byBjYWxsIHByZXZlbnREZWZhdWx0KClcclxuID0gKG9iamVjdCkgaW50ZXJhY3RcclxuXFwqL1xyXG5pbnRlcmFjdC5zdG9wID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgZm9yICh2YXIgaSA9IHNjb3BlLmludGVyYWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgc2NvcGUuaW50ZXJhY3Rpb25zW2ldLnN0b3AoZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGludGVyYWN0O1xyXG59O1xyXG5cclxuLypcXFxyXG4gKiBpbnRlcmFjdC5wb2ludGVyTW92ZVRvbGVyYW5jZVxyXG4gWyBtZXRob2QgXVxyXG4gKiBSZXR1cm5zIG9yIHNldHMgdGhlIGRpc3RhbmNlIHRoZSBwb2ludGVyIG11c3QgYmUgbW92ZWQgYmVmb3JlIGFuIGFjdGlvblxyXG4gKiBzZXF1ZW5jZSBvY2N1cnMuIFRoaXMgYWxzbyBhZmZlY3RzIHRvbGVyYW5jZSBmb3IgdGFwIGV2ZW50cy5cclxuICpcclxuIC0gbmV3VmFsdWUgKG51bWJlcikgI29wdGlvbmFsIFRoZSBtb3ZlbWVudCBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGlzIHZhbHVlXHJcbiA9IChudW1iZXIgfCBJbnRlcmFjdGFibGUpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgaW50ZXJhY3RcclxuXFwqL1xyXG5pbnRlcmFjdC5wb2ludGVyTW92ZVRvbGVyYW5jZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gIGlmICh1dGlscy5pcy5udW1iZXIobmV3VmFsdWUpKSB7XHJcbiAgICBJbnRlcmFjdGlvbi5wb2ludGVyTW92ZVRvbGVyYW5jZSA9IG5ld1ZhbHVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEludGVyYWN0aW9uLnBvaW50ZXJNb3ZlVG9sZXJhbmNlO1xyXG59O1xyXG5cclxuaW50ZXJhY3QuYWRkRG9jdW1lbnQgPSBzY29wZS5hZGREb2N1bWVudDtcclxuaW50ZXJhY3QucmVtb3ZlRG9jdW1lbnQgPSBzY29wZS5yZW1vdmVEb2N1bWVudDtcclxuXHJcbnNjb3BlLmludGVyYWN0ID0gaW50ZXJhY3Q7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyYWN0O1xyXG5cclxufSx7XCIuL0ludGVyYWN0YWJsZVwiOjQsXCIuL0ludGVyYWN0aW9uXCI6NSxcIi4vc2NvcGVcIjozNCxcIi4vdXRpbHNcIjo0NCxcIi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi91dGlscy9ldmVudHNcIjo0MH1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEludGVyYWN0YWJsZSA9IHJlcXVpcmUoJy4vSW50ZXJhY3RhYmxlJyk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb24nKTtcclxudmFyIHNjb3BlID0gcmVxdWlyZSgnLi9zY29wZScpO1xyXG52YXIgaXMgPSByZXF1aXJlKCcuL3V0aWxzL2lzJyk7XHJcbnZhciBldmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50cycpO1xyXG5cclxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9kb21VdGlscycpLFxyXG4gICAgbm9kZUNvbnRhaW5zID0gX3JlcXVpcmUubm9kZUNvbnRhaW5zLFxyXG4gICAgbWF0Y2hlc1NlbGVjdG9yID0gX3JlcXVpcmUubWF0Y2hlc1NlbGVjdG9yO1xyXG5cclxuLypcXFxyXG4gKiBJbnRlcmFjdGFibGUucHJldmVudERlZmF1bHRcclxuIFsgbWV0aG9kIF1cclxuICpcclxuICogUmV0dXJucyBvciBzZXRzIHdoZXRoZXIgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3VyXHJcbiAqIGluIHJlc3BvbnNlIHRvIHBvaW50ZXIgZXZlbnRzLiBDYW4gYmUgc2V0IHRvOlxyXG4gKiAgLSBgJ2Fsd2F5cydgIHRvIGFsd2F5cyBwcmV2ZW50XHJcbiAqICAtIGAnbmV2ZXInYCB0byBuZXZlciBwcmV2ZW50XHJcbiAqICAtIGAnYXV0bydgIHRvIGxldCBpbnRlcmFjdC5qcyB0cnkgdG8gZGV0ZXJtaW5lIHdoYXQgd291bGQgYmUgYmVzdFxyXG4gKlxyXG4gLSBuZXdWYWx1ZSAoc3RyaW5nKSAjb3B0aW9uYWwgYHRydWVgLCBgZmFsc2VgIG9yIGAnYXV0bydgXHJcbiA9IChzdHJpbmcgfCBJbnRlcmFjdGFibGUpIFRoZSBjdXJyZW50IHNldHRpbmcgb3IgdGhpcyBJbnRlcmFjdGFibGVcclxuXFwqL1xyXG5cclxuXHJcbkludGVyYWN0YWJsZS5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICBpZiAoL14oYWx3YXlzfG5ldmVyfGF1dG8pJC8udGVzdChuZXdWYWx1ZSkpIHtcclxuICAgIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9IG5ld1ZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpZiAoaXMuYm9vbChuZXdWYWx1ZSkpIHtcclxuICAgIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9IG5ld1ZhbHVlID8gJ2Fsd2F5cycgOiAnbmV2ZXInO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xyXG59O1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5jaGVja0FuZFByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgdmFyIHNldHRpbmcgPSB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XHJcblxyXG4gIGlmIChzZXR0aW5nID09PSAnbmV2ZXInKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoc2V0dGluZyA9PT0gJ2Fsd2F5cycpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBzZXR0aW5nID09PSAnYXV0bydcclxuXHJcbiAgLy8gZG9uJ3QgcHJldmVudERlZmF1bHQgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZUV2ZW50c1xyXG4gIC8vIENTUyB0b3VjaC1hY3Rpb24gYW5kIHVzZXItc2VsZWNjdCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXHJcbiAgaWYgKGV2ZW50cy5zdXBwb3J0c09wdGlvbnMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIGRvbid0IHByZXZlbnREZWZhdWx0IG9mIHBvaW50ZXJkb3duIGV2ZW50c1xyXG4gIGlmICgvXihtb3VzZXxwb2ludGVyfHRvdWNoKSooZG93bnxzdGFydCkvaS50ZXN0KGV2ZW50LnR5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBkb24ndCBwcmV2ZW50RGVmYXVsdCBvbiBlZGl0YWJsZSBlbGVtZW50c1xyXG4gIGlmIChpcy5lbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgbWF0Y2hlc1NlbGVjdG9yKGV2ZW50LnRhcmdldCwgJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlPXRydWVdLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0gKicpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gb25JbnRlcmFjdGlvbkV2ZW50KF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQ7XHJcblxyXG4gIGlmIChpbnRlcmFjdGlvbi50YXJnZXQpIHtcclxuICAgIGludGVyYWN0aW9uLnRhcmdldC5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBfYXJyID0gWydkb3duJywgJ21vdmUnLCAndXAnLCAnY2FuY2VsJ107XHJcbmZvciAodmFyIF9pID0gMDsgX2kgPCBfYXJyLmxlbmd0aDsgX2krKykge1xyXG4gIHZhciBldmVudFNpZ25hbCA9IF9hcnJbX2ldO1xyXG4gIEludGVyYWN0aW9uLnNpZ25hbHMub24oZXZlbnRTaWduYWwsIG9uSW50ZXJhY3Rpb25FdmVudCk7XHJcbn1cclxuXHJcbi8vIHByZXZlbnQgbmF0aXZlIEhUTUw1IGRyYWcgb24gaW50ZXJhY3QuanMgdGFyZ2V0IGVsZW1lbnRzXHJcbkludGVyYWN0aW9uLmRvY0V2ZW50cy5kcmFnc3RhcnQgPSBmdW5jdGlvbiBwcmV2ZW50TmF0aXZlRHJhZyhldmVudCkge1xyXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IHNjb3BlLmludGVyYWN0aW9ucywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pMiA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICB2YXIgX3JlZjI7XHJcblxyXG4gICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgIF9yZWYyID0gX2l0ZXJhdG9yW19pMisrXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9pMiA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XHJcbiAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYyO1xyXG5cclxuXHJcbiAgICBpZiAoaW50ZXJhY3Rpb24uZWxlbWVudCAmJiAoaW50ZXJhY3Rpb24uZWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0IHx8IG5vZGVDb250YWlucyhpbnRlcmFjdGlvbi5lbGVtZW50LCBldmVudC50YXJnZXQpKSkge1xyXG5cclxuICAgICAgaW50ZXJhY3Rpb24udGFyZ2V0LmNoZWNrQW5kUHJldmVudERlZmF1bHQoZXZlbnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxufSx7XCIuL0ludGVyYWN0YWJsZVwiOjQsXCIuL0ludGVyYWN0aW9uXCI6NSxcIi4vc2NvcGVcIjozNCxcIi4vdXRpbHMvZG9tVXRpbHNcIjozOSxcIi4vdXRpbHMvZXZlbnRzXCI6NDAsXCIuL3V0aWxzL2lzXCI6NDZ9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBzY29wZSA9IHJlcXVpcmUoJy4vc2NvcGUnKTtcclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnRzJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJyk7XHJcbnZhciBpRmluZGVyID0gcmVxdWlyZSgnLi91dGlscy9pbnRlcmFjdGlvbkZpbmRlcicpO1xyXG52YXIgcG9pbnRlckV2ZW50cyA9IHJlcXVpcmUoJy4vcG9pbnRlckV2ZW50cy9iYXNlJyk7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL3dpbmRvdycpLFxyXG4gICAgd2luZG93ID0gX3JlcXVpcmUud2luZG93O1xyXG5cclxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbmlmICghd2luZG93LkFycmF5LmlzQXJyYXkpIHtcclxuICB3aW5kb3cuQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgfTtcclxufVxyXG5cclxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcclxuICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9jbGljay5odG1sXHJcbi8vID5FdmVudHMgbGVhZGluZyB0byBkYmxjbGlja1xyXG4vL1xyXG4vLyBJRTggZG9lc24ndCBmaXJlIGRvd24gZXZlbnQgYmVmb3JlIGRibGNsaWNrLlxyXG4vLyBUaGlzIHdvcmthcm91bmQgdHJpZXMgdG8gZmlyZSBhIHRhcCBhbmQgZG91YmxldGFwIGFmdGVyIGRibGNsaWNrXHJcbmZ1bmN0aW9uIG9uSUU4RGJsY2xpY2soZXZlbnQpIHtcclxuICB2YXIgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gaUZpbmRlci5zZWFyY2goZXZlbnQsIGV2ZW50LnR5cGUsIGV2ZW50VGFyZ2V0KTtcclxuXHJcbiAgaWYgKCFpbnRlcmFjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGludGVyYWN0aW9uLnByZXZUYXAgJiYgZXZlbnQuY2xpZW50WCA9PT0gaW50ZXJhY3Rpb24ucHJldlRhcC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkgPT09IGludGVyYWN0aW9uLnByZXZUYXAuY2xpZW50WSAmJiBldmVudFRhcmdldCA9PT0gaW50ZXJhY3Rpb24ucHJldlRhcC50YXJnZXQpIHtcclxuXHJcbiAgICBpbnRlcmFjdGlvbi5kb3duVGFyZ2V0c1swXSA9IGV2ZW50VGFyZ2V0O1xyXG4gICAgaW50ZXJhY3Rpb24uZG93blRpbWVzWzBdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgcG9pbnRlckV2ZW50cy5maXJlKHtcclxuICAgICAgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uLFxyXG4gICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcclxuICAgICAgcG9pbnRlcjogZXZlbnQsXHJcbiAgICAgIHR5cGU6ICd0YXAnXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmlmIChicm93c2VyLmlzSUU4KSB7XHJcbiAgdmFyIHNlbGVjdEZpeCA9IGZ1bmN0aW9uIHNlbGVjdEZpeChldmVudCkge1xyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gc2NvcGUuaW50ZXJhY3Rpb25zLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICB2YXIgX3JlZjtcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheSkge1xyXG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmO1xyXG5cclxuICAgICAgaWYgKGludGVyYWN0aW9uLmludGVyYWN0aW5nKCkpIHtcclxuICAgICAgICBpbnRlcmFjdGlvbi50YXJnZXQuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgb25Eb2NJRTggPSBmdW5jdGlvbiBvbkRvY0lFOChfcmVmMiwgc2lnbmFsTmFtZSkge1xyXG4gICAgdmFyIGRvYyA9IF9yZWYyLmRvYyxcclxuICAgICAgICB3aW4gPSBfcmVmMi53aW47XHJcblxyXG4gICAgdmFyIGV2ZW50TWV0aG9kID0gc2lnbmFsTmFtZS5pbmRleE9mKCdsaXN0ZW4nKSA9PT0gMCA/IGV2ZW50cy5hZGQgOiBldmVudHMucmVtb3ZlO1xyXG5cclxuICAgIC8vIEZvciBJRSdzIGxhY2sgb2YgRXZlbnQjcHJldmVudERlZmF1bHRcclxuICAgIGV2ZW50TWV0aG9kKGRvYywgJ3NlbGVjdHN0YXJ0Jywgc2VsZWN0Rml4KTtcclxuXHJcbiAgICBpZiAocG9pbnRlckV2ZW50cykge1xyXG4gICAgICBldmVudE1ldGhvZChkb2MsICdkYmxjbGljaycsIG9uSUU4RGJsY2xpY2spO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNjb3BlLnNpZ25hbHMub24oJ2FkZC1kb2N1bWVudCcsIG9uRG9jSUU4KTtcclxuICBzY29wZS5zaWduYWxzLm9uKCdyZW1vdmUtZG9jdW1lbnQnLCBvbkRvY0lFOCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbnVsbDtcclxuXHJcbn0se1wiLi9wb2ludGVyRXZlbnRzL2Jhc2VcIjozMSxcIi4vc2NvcGVcIjozNCxcIi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi91dGlscy9ldmVudHNcIjo0MCxcIi4vdXRpbHMvaW50ZXJhY3Rpb25GaW5kZXJcIjo0NSxcIi4vdXRpbHMvd2luZG93XCI6NTJ9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBJbnRlcmFjdEV2ZW50ID0gcmVxdWlyZSgnLi4vSW50ZXJhY3RFdmVudCcpO1xyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuLi9JbnRlcmFjdGlvbicpO1xyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbHMvZXh0ZW5kJyk7XHJcblxyXG52YXIgbW9kaWZpZXJzID0ge1xyXG4gIG5hbWVzOiBbXSxcclxuXHJcbiAgc2V0T2Zmc2V0czogZnVuY3Rpb24gc2V0T2Zmc2V0cyhhcmcpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IGFyZy5pbnRlcmFjdGlvbixcclxuICAgICAgICBwYWdlID0gYXJnLnBhZ2VDb29yZHM7XHJcbiAgICB2YXIgdGFyZ2V0ID0gaW50ZXJhY3Rpb24udGFyZ2V0LFxyXG4gICAgICAgIGVsZW1lbnQgPSBpbnRlcmFjdGlvbi5lbGVtZW50LFxyXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gaW50ZXJhY3Rpb24uc3RhcnRPZmZzZXQ7XHJcblxyXG4gICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0UmVjdChlbGVtZW50KTtcclxuXHJcbiAgICBpZiAocmVjdCkge1xyXG4gICAgICBzdGFydE9mZnNldC5sZWZ0ID0gcGFnZS54IC0gcmVjdC5sZWZ0O1xyXG4gICAgICBzdGFydE9mZnNldC50b3AgPSBwYWdlLnkgLSByZWN0LnRvcDtcclxuXHJcbiAgICAgIHN0YXJ0T2Zmc2V0LnJpZ2h0ID0gcmVjdC5yaWdodCAtIHBhZ2UueDtcclxuICAgICAgc3RhcnRPZmZzZXQuYm90dG9tID0gcmVjdC5ib3R0b20gLSBwYWdlLnk7XHJcblxyXG4gICAgICBpZiAoISgnd2lkdGgnIGluIHJlY3QpKSB7XHJcbiAgICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEoJ2hlaWdodCcgaW4gcmVjdCkpIHtcclxuICAgICAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0T2Zmc2V0LmxlZnQgPSBzdGFydE9mZnNldC50b3AgPSBzdGFydE9mZnNldC5yaWdodCA9IHN0YXJ0T2Zmc2V0LmJvdHRvbSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgYXJnLnJlY3QgPSByZWN0O1xyXG4gICAgYXJnLmludGVyYWN0YWJsZSA9IHRhcmdldDtcclxuICAgIGFyZy5lbGVtZW50ID0gZWxlbWVudDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGlmaWVycy5uYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgbW9kaWZpZXJOYW1lID0gbW9kaWZpZXJzLm5hbWVzW2ldO1xyXG5cclxuICAgICAgYXJnLm9wdGlvbnMgPSB0YXJnZXQub3B0aW9uc1tpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lXVttb2RpZmllck5hbWVdO1xyXG5cclxuICAgICAgaWYgKCFhcmcub3B0aW9ucykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbnRlcmFjdGlvbi5tb2RpZmllck9mZnNldHNbbW9kaWZpZXJOYW1lXSA9IG1vZGlmaWVyc1ttb2RpZmllck5hbWVdLnNldE9mZnNldChhcmcpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNldEFsbDogZnVuY3Rpb24gc2V0QWxsKGFyZykge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gYXJnLmludGVyYWN0aW9uLFxyXG4gICAgICAgIHN0YXR1c2VzID0gYXJnLnN0YXR1c2VzLFxyXG4gICAgICAgIHByZUVuZCA9IGFyZy5wcmVFbmQsXHJcbiAgICAgICAgcmVxdWlyZUVuZE9ubHkgPSBhcmcucmVxdWlyZUVuZE9ubHk7XHJcblxyXG4gICAgdmFyIGNvb3JkcyA9IGV4dGVuZCh7fSwgYXJnLnBhZ2VDb29yZHMpO1xyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgZHg6IDAsXHJcbiAgICAgIGR5OiAwLFxyXG4gICAgICBjaGFuZ2VkOiBmYWxzZSxcclxuICAgICAgbG9ja2VkOiBmYWxzZSxcclxuICAgICAgc2hvdWxkTW92ZTogdHJ1ZVxyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBtb2RpZmllcnMubmFtZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmID0gX2kudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtb2RpZmllck5hbWUgPSBfcmVmO1xyXG5cclxuICAgICAgdmFyIG1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVyTmFtZV07XHJcbiAgICAgIHZhciBvcHRpb25zID0gaW50ZXJhY3Rpb24udGFyZ2V0Lm9wdGlvbnNbaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV1bbW9kaWZpZXJOYW1lXTtcclxuXHJcbiAgICAgIGlmICghc2hvdWxkRG8ob3B0aW9ucywgcHJlRW5kLCByZXF1aXJlRW5kT25seSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXJnLnN0YXR1cyA9IGFyZy5zdGF0dXMgPSBzdGF0dXNlc1ttb2RpZmllck5hbWVdO1xyXG4gICAgICBhcmcub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgIGFyZy5vZmZzZXQgPSBhcmcuaW50ZXJhY3Rpb24ubW9kaWZpZXJPZmZzZXRzW21vZGlmaWVyTmFtZV07XHJcblxyXG4gICAgICBtb2RpZmllci5zZXQoYXJnKTtcclxuXHJcbiAgICAgIGlmIChhcmcuc3RhdHVzLmxvY2tlZCkge1xyXG4gICAgICAgIGNvb3Jkcy54ICs9IGFyZy5zdGF0dXMuZHg7XHJcbiAgICAgICAgY29vcmRzLnkgKz0gYXJnLnN0YXR1cy5keTtcclxuXHJcbiAgICAgICAgcmVzdWx0LmR4ICs9IGFyZy5zdGF0dXMuZHg7XHJcbiAgICAgICAgcmVzdWx0LmR5ICs9IGFyZy5zdGF0dXMuZHk7XHJcblxyXG4gICAgICAgIHJlc3VsdC5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYSBtb3ZlIHNob3VsZCBiZSBmaXJlZCBpZjpcclxuICAgIC8vICAtIHRoZXJlIGFyZSBubyBtb2RpZmllcnMgZW5hYmxlZCxcclxuICAgIC8vICAtIG5vIG1vZGlmaWVycyBhcmUgXCJsb2NrZWRcIiBpLmUuIGhhdmUgY2hhbmdlZCB0aGUgcG9pbnRlcidzIGNvb3JkaW5hdGVzLCBvclxyXG4gICAgLy8gIC0gdGhlIGxvY2tlZCBjb29yZHMgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHBvaW50ZXIgbW92ZVxyXG4gICAgcmVzdWx0LnNob3VsZE1vdmUgPSAhYXJnLnN0YXR1cyB8fCAhcmVzdWx0LmxvY2tlZCB8fCBhcmcuc3RhdHVzLmNoYW5nZWQ7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LFxyXG5cclxuICByZXNldFN0YXR1c2VzOiBmdW5jdGlvbiByZXNldFN0YXR1c2VzKHN0YXR1c2VzKSB7XHJcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gbW9kaWZpZXJzLm5hbWVzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWYyO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5Mikge1xyXG4gICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1vZGlmaWVyTmFtZSA9IF9yZWYyO1xyXG5cclxuICAgICAgdmFyIHN0YXR1cyA9IHN0YXR1c2VzW21vZGlmaWVyTmFtZV0gfHwge307XHJcblxyXG4gICAgICBzdGF0dXMuZHggPSBzdGF0dXMuZHkgPSAwO1xyXG4gICAgICBzdGF0dXMubW9kaWZpZWRYID0gc3RhdHVzLm1vZGlmaWVkWSA9IE5hTjtcclxuICAgICAgc3RhdHVzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICBzdGF0dXMuY2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICBzdGF0dXNlc1ttb2RpZmllck5hbWVdID0gc3RhdHVzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGF0dXNlcztcclxuICB9LFxyXG5cclxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoX3JlZjMsIHNpZ25hbE5hbWUpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYzLmludGVyYWN0aW9uO1xyXG5cclxuICAgIHZhciBhcmcgPSB7XHJcbiAgICAgIGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbixcclxuICAgICAgcGFnZUNvb3JkczogKHNpZ25hbE5hbWUgPT09ICdhY3Rpb24tcmVzdW1lJyA/IGludGVyYWN0aW9uLmN1ckNvb3JkcyA6IGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzKS5wYWdlLFxyXG4gICAgICBzdGFydE9mZnNldDogaW50ZXJhY3Rpb24uc3RhcnRPZmZzZXQsXHJcbiAgICAgIHN0YXR1c2VzOiBpbnRlcmFjdGlvbi5tb2RpZmllclN0YXR1c2VzLFxyXG4gICAgICBwcmVFbmQ6IGZhbHNlLFxyXG4gICAgICByZXF1aXJlRW5kT25seTogZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgbW9kaWZpZXJzLnNldE9mZnNldHMoYXJnKTtcclxuICAgIG1vZGlmaWVycy5yZXNldFN0YXR1c2VzKGFyZy5zdGF0dXNlcyk7XHJcblxyXG4gICAgYXJnLnBhZ2VDb29yZHMgPSBleHRlbmQoe30sIGludGVyYWN0aW9uLnN0YXJ0Q29vcmRzLnBhZ2UpO1xyXG4gICAgaW50ZXJhY3Rpb24ubW9kaWZpZXJSZXN1bHQgPSBtb2RpZmllcnMuc2V0QWxsKGFyZyk7XHJcbiAgfVxyXG59O1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgaW50ZXJhY3Rpb24uc3RhcnRPZmZzZXQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xyXG4gIGludGVyYWN0aW9uLm1vZGlmaWVyT2Zmc2V0cyA9IHt9O1xyXG4gIGludGVyYWN0aW9uLm1vZGlmaWVyU3RhdHVzZXMgPSBtb2RpZmllcnMucmVzZXRTdGF0dXNlcyh7fSk7XHJcbiAgaW50ZXJhY3Rpb24ubW9kaWZpZXJSZXN1bHQgPSBudWxsO1xyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ2FjdGlvbi1zdGFydCcsIG1vZGlmaWVycy5zdGFydCk7XHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ2FjdGlvbi1yZXN1bWUnLCBtb2RpZmllcnMuc3RhcnQpO1xyXG5cclxuSW50ZXJhY3Rpb24uc2lnbmFscy5vbignYmVmb3JlLWFjdGlvbi1tb3ZlJywgZnVuY3Rpb24gKF9yZWY0KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjQuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHByZUVuZCA9IF9yZWY0LnByZUVuZCxcclxuICAgICAgaW50ZXJhY3RpbmdCZWZvcmVNb3ZlID0gX3JlZjQuaW50ZXJhY3RpbmdCZWZvcmVNb3ZlO1xyXG5cclxuICB2YXIgbW9kaWZpZXJSZXN1bHQgPSBtb2RpZmllcnMuc2V0QWxsKHtcclxuICAgIGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbixcclxuICAgIHByZUVuZDogcHJlRW5kLFxyXG4gICAgcGFnZUNvb3JkczogaW50ZXJhY3Rpb24uY3VyQ29vcmRzLnBhZ2UsXHJcbiAgICBzdGF0dXNlczogaW50ZXJhY3Rpb24ubW9kaWZpZXJTdGF0dXNlcyxcclxuICAgIHJlcXVpcmVFbmRPbmx5OiBmYWxzZVxyXG4gIH0pO1xyXG5cclxuICAvLyBkb24ndCBmaXJlIGFuIGFjdGlvbiBtb3ZlIGlmIGEgbW9kaWZpZXIgd291bGQga2VlcCB0aGUgZXZlbnQgaW4gdGhlIHNhbWVcclxuICAvLyBjb3JkaW5hdGVzIGFzIGJlZm9yZVxyXG4gIGlmICghbW9kaWZpZXJSZXN1bHQuc2hvdWxkTW92ZSAmJiBpbnRlcmFjdGluZ0JlZm9yZU1vdmUpIHtcclxuICAgIGludGVyYWN0aW9uLl9kb250RmlyZU1vdmUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaW50ZXJhY3Rpb24ubW9kaWZpZXJSZXN1bHQgPSBtb2RpZmllclJlc3VsdDtcclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdhY3Rpb24tZW5kJywgZnVuY3Rpb24gKF9yZWY1KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjUuaW50ZXJhY3Rpb24sXHJcbiAgICAgIGV2ZW50ID0gX3JlZjUuZXZlbnQ7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kaWZpZXJzLm5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGludGVyYWN0aW9uLnRhcmdldC5vcHRpb25zW2ludGVyYWN0aW9uLnByZXBhcmVkLm5hbWVdW21vZGlmaWVycy5uYW1lc1tpXV07XHJcblxyXG4gICAgLy8gaWYgdGhlIGVuZE9ubHkgb3B0aW9uIGlzIHRydWUgZm9yIGFueSBtb2RpZmllclxyXG4gICAgaWYgKHNob3VsZERvKG9wdGlvbnMsIHRydWUsIHRydWUpKSB7XHJcbiAgICAgIC8vIGZpcmUgYSBtb3ZlIGV2ZW50IGF0IHRoZSBtb2RpZmllZCBjb29yZGluYXRlc1xyXG4gICAgICBpbnRlcmFjdGlvbi5kb01vdmUoeyBldmVudDogZXZlbnQsIHByZUVuZDogdHJ1ZSB9KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbkludGVyYWN0RXZlbnQuc2lnbmFscy5vbignc2V0LXh5JywgZnVuY3Rpb24gKGFyZykge1xyXG4gIHZhciBpRXZlbnQgPSBhcmcuaUV2ZW50LFxyXG4gICAgICBpbnRlcmFjdGlvbiA9IGFyZy5pbnRlcmFjdGlvbjtcclxuXHJcbiAgdmFyIG1vZGlmaWVyQXJnID0gZXh0ZW5kKHt9LCBhcmcpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGlmaWVycy5uYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIG1vZGlmaWVyTmFtZSA9IG1vZGlmaWVycy5uYW1lc1tpXTtcclxuICAgIG1vZGlmaWVyQXJnLm9wdGlvbnMgPSBpbnRlcmFjdGlvbi50YXJnZXQub3B0aW9uc1tpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lXVttb2RpZmllck5hbWVdO1xyXG5cclxuICAgIGlmICghbW9kaWZpZXJBcmcub3B0aW9ucykge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJOYW1lXTtcclxuXHJcbiAgICBtb2RpZmllckFyZy5zdGF0dXMgPSBpbnRlcmFjdGlvbi5tb2RpZmllclN0YXR1c2VzW21vZGlmaWVyTmFtZV07XHJcblxyXG4gICAgaUV2ZW50W21vZGlmaWVyTmFtZV0gPSBtb2RpZmllci5tb2RpZnlDb29yZHMobW9kaWZpZXJBcmcpO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBzaG91bGREbyhvcHRpb25zLCBwcmVFbmQsIHJlcXVpcmVFbmRPbmx5KSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5lbmFibGVkICYmIChwcmVFbmQgfHwgIW9wdGlvbnMuZW5kT25seSkgJiYgKCFyZXF1aXJlRW5kT25seSB8fCBvcHRpb25zLmVuZE9ubHkpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGlmaWVycztcclxuXHJcbn0se1wiLi4vSW50ZXJhY3RFdmVudFwiOjMsXCIuLi9JbnRlcmFjdGlvblwiOjUsXCIuLi91dGlscy9leHRlbmRcIjo0MX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG1vZGlmaWVycyA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxuXHJcbnZhciByZXN0cmljdCA9IHtcclxuICBkZWZhdWx0czoge1xyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICBlbmRPbmx5OiBmYWxzZSxcclxuICAgIHJlc3RyaWN0aW9uOiBudWxsLFxyXG4gICAgZWxlbWVudFJlY3Q6IG51bGxcclxuICB9LFxyXG5cclxuICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIHNldE9mZnNldChfcmVmKSB7XHJcbiAgICB2YXIgcmVjdCA9IF9yZWYucmVjdCxcclxuICAgICAgICBzdGFydE9mZnNldCA9IF9yZWYuc3RhcnRPZmZzZXQsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcclxuXHJcbiAgICB2YXIgZWxlbWVudFJlY3QgPSBvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudFJlY3Q7XHJcbiAgICB2YXIgb2Zmc2V0ID0ge307XHJcblxyXG4gICAgaWYgKHJlY3QgJiYgZWxlbWVudFJlY3QpIHtcclxuICAgICAgb2Zmc2V0LmxlZnQgPSBzdGFydE9mZnNldC5sZWZ0IC0gcmVjdC53aWR0aCAqIGVsZW1lbnRSZWN0LmxlZnQ7XHJcbiAgICAgIG9mZnNldC50b3AgPSBzdGFydE9mZnNldC50b3AgLSByZWN0LmhlaWdodCAqIGVsZW1lbnRSZWN0LnRvcDtcclxuXHJcbiAgICAgIG9mZnNldC5yaWdodCA9IHN0YXJ0T2Zmc2V0LnJpZ2h0IC0gcmVjdC53aWR0aCAqICgxIC0gZWxlbWVudFJlY3QucmlnaHQpO1xyXG4gICAgICBvZmZzZXQuYm90dG9tID0gc3RhcnRPZmZzZXQuYm90dG9tIC0gcmVjdC5oZWlnaHQgKiAoMSAtIGVsZW1lbnRSZWN0LmJvdHRvbSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvZmZzZXQubGVmdCA9IG9mZnNldC50b3AgPSBvZmZzZXQucmlnaHQgPSBvZmZzZXQuYm90dG9tID0gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2Zmc2V0O1xyXG4gIH0sXHJcblxyXG4gIHNldDogZnVuY3Rpb24gc2V0KF9yZWYyKSB7XHJcbiAgICB2YXIgcGFnZUNvb3JkcyA9IF9yZWYyLnBhZ2VDb29yZHMsXHJcbiAgICAgICAgaW50ZXJhY3Rpb24gPSBfcmVmMi5pbnRlcmFjdGlvbixcclxuICAgICAgICBzdGF0dXMgPSBfcmVmMi5zdGF0dXMsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhZ2UgPSBzdGF0dXMudXNlU3RhdHVzWFkgPyB7IHg6IHN0YXR1cy54LCB5OiBzdGF0dXMueSB9IDogdXRpbHMuZXh0ZW5kKHt9LCBwYWdlQ29vcmRzKTtcclxuXHJcbiAgICB2YXIgcmVzdHJpY3Rpb24gPSBnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5yZXN0cmljdGlvbiwgaW50ZXJhY3Rpb24sIHBhZ2UpO1xyXG5cclxuICAgIGlmICghcmVzdHJpY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0dXMuZHggPSAwO1xyXG4gICAgc3RhdHVzLmR5ID0gMDtcclxuICAgIHN0YXR1cy5sb2NrZWQgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgcmVjdCA9IHJlc3RyaWN0aW9uO1xyXG4gICAgdmFyIG1vZGlmaWVkWCA9IHBhZ2UueDtcclxuICAgIHZhciBtb2RpZmllZFkgPSBwYWdlLnk7XHJcblxyXG4gICAgdmFyIG9mZnNldCA9IGludGVyYWN0aW9uLm1vZGlmaWVyT2Zmc2V0cy5yZXN0cmljdDtcclxuXHJcbiAgICAvLyBvYmplY3QgaXMgYXNzdW1lZCB0byBoYXZlXHJcbiAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0IG9yXHJcbiAgICAvLyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cclxuICAgIGlmICgneCcgaW4gcmVzdHJpY3Rpb24gJiYgJ3knIGluIHJlc3RyaWN0aW9uKSB7XHJcbiAgICAgIG1vZGlmaWVkWCA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QueCArIHJlY3Qud2lkdGggLSBvZmZzZXQucmlnaHQsIHBhZ2UueCksIHJlY3QueCArIG9mZnNldC5sZWZ0KTtcclxuICAgICAgbW9kaWZpZWRZID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdC55ICsgcmVjdC5oZWlnaHQgLSBvZmZzZXQuYm90dG9tLCBwYWdlLnkpLCByZWN0LnkgKyBvZmZzZXQudG9wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1vZGlmaWVkWCA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QucmlnaHQgLSBvZmZzZXQucmlnaHQsIHBhZ2UueCksIHJlY3QubGVmdCArIG9mZnNldC5sZWZ0KTtcclxuICAgICAgbW9kaWZpZWRZID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdC5ib3R0b20gLSBvZmZzZXQuYm90dG9tLCBwYWdlLnkpLCByZWN0LnRvcCArIG9mZnNldC50b3ApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXR1cy5keCA9IG1vZGlmaWVkWCAtIHBhZ2UueDtcclxuICAgIHN0YXR1cy5keSA9IG1vZGlmaWVkWSAtIHBhZ2UueTtcclxuXHJcbiAgICBzdGF0dXMuY2hhbmdlZCA9IHN0YXR1cy5tb2RpZmllZFggIT09IG1vZGlmaWVkWCB8fCBzdGF0dXMubW9kaWZpZWRZICE9PSBtb2RpZmllZFk7XHJcbiAgICBzdGF0dXMubG9ja2VkID0gISEoc3RhdHVzLmR4IHx8IHN0YXR1cy5keSk7XHJcblxyXG4gICAgc3RhdHVzLm1vZGlmaWVkWCA9IG1vZGlmaWVkWDtcclxuICAgIHN0YXR1cy5tb2RpZmllZFkgPSBtb2RpZmllZFk7XHJcbiAgfSxcclxuXHJcbiAgbW9kaWZ5Q29vcmRzOiBmdW5jdGlvbiBtb2RpZnlDb29yZHMoX3JlZjMpIHtcclxuICAgIHZhciBwYWdlID0gX3JlZjMucGFnZSxcclxuICAgICAgICBjbGllbnQgPSBfcmVmMy5jbGllbnQsXHJcbiAgICAgICAgc3RhdHVzID0gX3JlZjMuc3RhdHVzLFxyXG4gICAgICAgIHBoYXNlID0gX3JlZjMucGhhc2UsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnM7XHJcblxyXG4gICAgdmFyIGVsZW1lbnRSZWN0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmVsZW1lbnRSZWN0O1xyXG5cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5hYmxlZCAmJiAhKHBoYXNlID09PSAnc3RhcnQnICYmIGVsZW1lbnRSZWN0ICYmIHN0YXR1cy5sb2NrZWQpKSB7XHJcblxyXG4gICAgICBpZiAoc3RhdHVzLmxvY2tlZCkge1xyXG4gICAgICAgIHBhZ2UueCArPSBzdGF0dXMuZHg7XHJcbiAgICAgICAgcGFnZS55ICs9IHN0YXR1cy5keTtcclxuICAgICAgICBjbGllbnQueCArPSBzdGF0dXMuZHg7XHJcbiAgICAgICAgY2xpZW50LnkgKz0gc3RhdHVzLmR5O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZHg6IHN0YXR1cy5keCxcclxuICAgICAgICAgIGR5OiBzdGF0dXMuZHlcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0UmVzdHJpY3Rpb25SZWN0OiBnZXRSZXN0cmljdGlvblJlY3RcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldFJlc3RyaWN0aW9uUmVjdCh2YWx1ZSwgaW50ZXJhY3Rpb24sIHBhZ2UpIHtcclxuICBpZiAodXRpbHMuaXMuZnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdXRpbHMucmVzb2x2ZVJlY3RMaWtlKHZhbHVlLCBpbnRlcmFjdGlvbi50YXJnZXQsIGludGVyYWN0aW9uLmVsZW1lbnQsIFtwYWdlLngsIHBhZ2UueSwgaW50ZXJhY3Rpb25dKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHV0aWxzLnJlc29sdmVSZWN0TGlrZSh2YWx1ZSwgaW50ZXJhY3Rpb24udGFyZ2V0LCBpbnRlcmFjdGlvbi5lbGVtZW50KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZGlmaWVycy5yZXN0cmljdCA9IHJlc3RyaWN0O1xyXG5tb2RpZmllcnMubmFtZXMucHVzaCgncmVzdHJpY3QnKTtcclxuXHJcbmRlZmF1bHRPcHRpb25zLnBlckFjdGlvbi5yZXN0cmljdCA9IHJlc3RyaWN0LmRlZmF1bHRzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXN0cmljdDtcclxuXHJcbn0se1wiLi4vZGVmYXVsdE9wdGlvbnNcIjoxOCxcIi4uL3V0aWxzXCI6NDQsXCIuL2luZGV4XCI6MjR9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRoaXMgbW9kdWxlIGFkZHMgdGhlIG9wdGlvbnMucmVzaXplLnJlc3RyaWN0RWRnZXMgc2V0dGluZyB3aGljaCBzZXRzIG1pbiBhbmRcclxuLy8gbWF4IGZvciB0aGUgdG9wLCBsZWZ0LCBib3R0b20gYW5kIHJpZ2h0IGVkZ2VzIG9mIHRoZSB0YXJnZXQgYmVpbmcgcmVzaXplZC5cclxuLy9cclxuLy8gaW50ZXJhY3QodGFyZ2V0KS5yZXNpemUoe1xyXG4vLyAgIGVkZ2VzOiB7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LFxyXG4vLyAgIHJlc3RyaWN0RWRnZXM6IHtcclxuLy8gICAgIGlubmVyOiB7IHRvcDogMjAwLCBsZWZ0OiAyMDAsIHJpZ2h0OiA0MDAsIGJvdHRvbTogNDAwIH0sXHJcbi8vICAgICBvdXRlcjogeyB0b3A6ICAgMCwgbGVmdDogICAwLCByaWdodDogNjAwLCBib3R0b206IDYwMCB9LFxyXG4vLyAgIH0sXHJcbi8vIH0pO1xyXG5cclxudmFyIG1vZGlmaWVycyA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIHJlY3RVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3JlY3QnKTtcclxudmFyIGRlZmF1bHRPcHRpb25zID0gcmVxdWlyZSgnLi4vZGVmYXVsdE9wdGlvbnMnKTtcclxudmFyIHJlc2l6ZSA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvcmVzaXplJyk7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3Jlc3RyaWN0JyksXHJcbiAgICBnZXRSZXN0cmljdGlvblJlY3QgPSBfcmVxdWlyZS5nZXRSZXN0cmljdGlvblJlY3Q7XHJcblxyXG52YXIgbm9Jbm5lciA9IHsgdG9wOiArSW5maW5pdHksIGxlZnQ6ICtJbmZpbml0eSwgYm90dG9tOiAtSW5maW5pdHksIHJpZ2h0OiAtSW5maW5pdHkgfTtcclxudmFyIG5vT3V0ZXIgPSB7IHRvcDogLUluZmluaXR5LCBsZWZ0OiAtSW5maW5pdHksIGJvdHRvbTogK0luZmluaXR5LCByaWdodDogK0luZmluaXR5IH07XHJcblxyXG52YXIgcmVzdHJpY3RFZGdlcyA9IHtcclxuICBkZWZhdWx0czoge1xyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICBlbmRPbmx5OiBmYWxzZSxcclxuICAgIG1pbjogbnVsbCxcclxuICAgIG1heDogbnVsbCxcclxuICAgIG9mZnNldDogbnVsbFxyXG4gIH0sXHJcblxyXG4gIHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KF9yZWYpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBfcmVmLnN0YXJ0T2Zmc2V0LFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB1dGlscy5leHRlbmQoe30sIHN0YXJ0T2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb2Zmc2V0ID0gZ2V0UmVzdHJpY3Rpb25SZWN0KG9wdGlvbnMub2Zmc2V0LCBpbnRlcmFjdGlvbiwgaW50ZXJhY3Rpb24uc3RhcnRDb29yZHMucGFnZSk7XHJcblxyXG4gICAgaWYgKG9mZnNldCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogc3RhcnRPZmZzZXQudG9wICsgb2Zmc2V0LnksXHJcbiAgICAgICAgbGVmdDogc3RhcnRPZmZzZXQubGVmdCArIG9mZnNldC54LFxyXG4gICAgICAgIGJvdHRvbTogc3RhcnRPZmZzZXQuYm90dG9tICsgb2Zmc2V0LnksXHJcbiAgICAgICAgcmlnaHQ6IHN0YXJ0T2Zmc2V0LnJpZ2h0ICsgb2Zmc2V0LnhcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RhcnRPZmZzZXQ7XHJcbiAgfSxcclxuXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQoX3JlZjIpIHtcclxuICAgIHZhciBwYWdlQ29vcmRzID0gX3JlZjIucGFnZUNvb3JkcyxcclxuICAgICAgICBpbnRlcmFjdGlvbiA9IF9yZWYyLmludGVyYWN0aW9uLFxyXG4gICAgICAgIHN0YXR1cyA9IF9yZWYyLnN0YXR1cyxcclxuICAgICAgICBvZmZzZXQgPSBfcmVmMi5vZmZzZXQsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XHJcblxyXG4gICAgdmFyIGVkZ2VzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQubGlua2VkRWRnZXMgfHwgaW50ZXJhY3Rpb24ucHJlcGFyZWQuZWRnZXM7XHJcblxyXG4gICAgaWYgKCFpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpIHx8ICFlZGdlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhZ2UgPSBzdGF0dXMudXNlU3RhdHVzWFkgPyB7IHg6IHN0YXR1cy54LCB5OiBzdGF0dXMueSB9IDogdXRpbHMuZXh0ZW5kKHt9LCBwYWdlQ29vcmRzKTtcclxuICAgIHZhciBpbm5lciA9IHJlY3RVdGlscy54eXdoVG9UbGJyKGdldFJlc3RyaWN0aW9uUmVjdChvcHRpb25zLmlubmVyLCBpbnRlcmFjdGlvbiwgcGFnZSkpIHx8IG5vSW5uZXI7XHJcbiAgICB2YXIgb3V0ZXIgPSByZWN0VXRpbHMueHl3aFRvVGxicihnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5vdXRlciwgaW50ZXJhY3Rpb24sIHBhZ2UpKSB8fCBub091dGVyO1xyXG5cclxuICAgIHZhciBtb2RpZmllZFggPSBwYWdlLng7XHJcbiAgICB2YXIgbW9kaWZpZWRZID0gcGFnZS55O1xyXG5cclxuICAgIHN0YXR1cy5keCA9IDA7XHJcbiAgICBzdGF0dXMuZHkgPSAwO1xyXG4gICAgc3RhdHVzLmxvY2tlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChlZGdlcy50b3ApIHtcclxuICAgICAgbW9kaWZpZWRZID0gTWF0aC5taW4oTWF0aC5tYXgob3V0ZXIudG9wICsgb2Zmc2V0LnRvcCwgcGFnZS55KSwgaW5uZXIudG9wICsgb2Zmc2V0LnRvcCk7XHJcbiAgICB9IGVsc2UgaWYgKGVkZ2VzLmJvdHRvbSkge1xyXG4gICAgICBtb2RpZmllZFkgPSBNYXRoLm1heChNYXRoLm1pbihvdXRlci5ib3R0b20gLSBvZmZzZXQuYm90dG9tLCBwYWdlLnkpLCBpbm5lci5ib3R0b20gLSBvZmZzZXQuYm90dG9tKTtcclxuICAgIH1cclxuICAgIGlmIChlZGdlcy5sZWZ0KSB7XHJcbiAgICAgIG1vZGlmaWVkWCA9IE1hdGgubWluKE1hdGgubWF4KG91dGVyLmxlZnQgKyBvZmZzZXQubGVmdCwgcGFnZS54KSwgaW5uZXIubGVmdCArIG9mZnNldC5sZWZ0KTtcclxuICAgIH0gZWxzZSBpZiAoZWRnZXMucmlnaHQpIHtcclxuICAgICAgbW9kaWZpZWRYID0gTWF0aC5tYXgoTWF0aC5taW4ob3V0ZXIucmlnaHQgLSBvZmZzZXQucmlnaHQsIHBhZ2UueCksIGlubmVyLnJpZ2h0IC0gb2Zmc2V0LnJpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0dXMuZHggPSBtb2RpZmllZFggLSBwYWdlLng7XHJcbiAgICBzdGF0dXMuZHkgPSBtb2RpZmllZFkgLSBwYWdlLnk7XHJcblxyXG4gICAgc3RhdHVzLmNoYW5nZWQgPSBzdGF0dXMubW9kaWZpZWRYICE9PSBtb2RpZmllZFggfHwgc3RhdHVzLm1vZGlmaWVkWSAhPT0gbW9kaWZpZWRZO1xyXG4gICAgc3RhdHVzLmxvY2tlZCA9ICEhKHN0YXR1cy5keCB8fCBzdGF0dXMuZHkpO1xyXG5cclxuICAgIHN0YXR1cy5tb2RpZmllZFggPSBtb2RpZmllZFg7XHJcbiAgICBzdGF0dXMubW9kaWZpZWRZID0gbW9kaWZpZWRZO1xyXG4gIH0sXHJcblxyXG4gIG1vZGlmeUNvb3JkczogZnVuY3Rpb24gbW9kaWZ5Q29vcmRzKF9yZWYzKSB7XHJcbiAgICB2YXIgcGFnZSA9IF9yZWYzLnBhZ2UsXHJcbiAgICAgICAgY2xpZW50ID0gX3JlZjMuY2xpZW50LFxyXG4gICAgICAgIHN0YXR1cyA9IF9yZWYzLnN0YXR1cyxcclxuICAgICAgICBwaGFzZSA9IF9yZWYzLnBoYXNlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zO1xyXG5cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5hYmxlZCAmJiAhKHBoYXNlID09PSAnc3RhcnQnICYmIHN0YXR1cy5sb2NrZWQpKSB7XHJcblxyXG4gICAgICBpZiAoc3RhdHVzLmxvY2tlZCkge1xyXG4gICAgICAgIHBhZ2UueCArPSBzdGF0dXMuZHg7XHJcbiAgICAgICAgcGFnZS55ICs9IHN0YXR1cy5keTtcclxuICAgICAgICBjbGllbnQueCArPSBzdGF0dXMuZHg7XHJcbiAgICAgICAgY2xpZW50LnkgKz0gc3RhdHVzLmR5O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZHg6IHN0YXR1cy5keCxcclxuICAgICAgICAgIGR5OiBzdGF0dXMuZHlcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgbm9Jbm5lcjogbm9Jbm5lcixcclxuICBub091dGVyOiBub091dGVyLFxyXG4gIGdldFJlc3RyaWN0aW9uUmVjdDogZ2V0UmVzdHJpY3Rpb25SZWN0XHJcbn07XHJcblxyXG5tb2RpZmllcnMucmVzdHJpY3RFZGdlcyA9IHJlc3RyaWN0RWRnZXM7XHJcbm1vZGlmaWVycy5uYW1lcy5wdXNoKCdyZXN0cmljdEVkZ2VzJyk7XHJcblxyXG5kZWZhdWx0T3B0aW9ucy5wZXJBY3Rpb24ucmVzdHJpY3RFZGdlcyA9IHJlc3RyaWN0RWRnZXMuZGVmYXVsdHM7XHJcbnJlc2l6ZS5kZWZhdWx0cy5yZXN0cmljdEVkZ2VzID0gcmVzdHJpY3RFZGdlcy5kZWZhdWx0cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVzdHJpY3RFZGdlcztcclxuXHJcbn0se1wiLi4vYWN0aW9ucy9yZXNpemVcIjoxMCxcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi91dGlsc1wiOjQ0LFwiLi4vdXRpbHMvcmVjdFwiOjUxLFwiLi9pbmRleFwiOjI0LFwiLi9yZXN0cmljdFwiOjI1fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUaGlzIG1vZHVsZSBhZGRzIHRoZSBvcHRpb25zLnJlc2l6ZS5yZXN0cmljdFNpemUgc2V0dGluZyB3aGljaCBzZXRzIG1pbiBhbmRcclxuLy8gbWF4IHdpZHRoIGFuZCBoZWlnaHQgZm9yIHRoZSB0YXJnZXQgYmVpbmcgcmVzaXplZC5cclxuLy9cclxuLy8gaW50ZXJhY3QodGFyZ2V0KS5yZXNpemUoe1xyXG4vLyAgIGVkZ2VzOiB7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LFxyXG4vLyAgIHJlc3RyaWN0U2l6ZToge1xyXG4vLyAgICAgbWluOiB7IHdpZHRoOiAtNjAwLCBoZWlnaHQ6IC02MDAgfSxcclxuLy8gICAgIG1heDogeyB3aWR0aDogIDYwMCwgaGVpZ2h0OiAgNjAwIH0sXHJcbi8vICAgfSxcclxuLy8gfSk7XHJcblxyXG52YXIgbW9kaWZpZXJzID0gcmVxdWlyZSgnLi9pbmRleCcpO1xyXG52YXIgcmVzdHJpY3RFZGdlcyA9IHJlcXVpcmUoJy4vcmVzdHJpY3RFZGdlcycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xyXG52YXIgcmVjdFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvcmVjdCcpO1xyXG52YXIgZGVmYXVsdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9kZWZhdWx0T3B0aW9ucycpO1xyXG52YXIgcmVzaXplID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9yZXNpemUnKTtcclxuXHJcbnZhciBub01pbiA9IHsgd2lkdGg6IC1JbmZpbml0eSwgaGVpZ2h0OiAtSW5maW5pdHkgfTtcclxudmFyIG5vTWF4ID0geyB3aWR0aDogK0luZmluaXR5LCBoZWlnaHQ6ICtJbmZpbml0eSB9O1xyXG5cclxudmFyIHJlc3RyaWN0U2l6ZSA9IHtcclxuICBkZWZhdWx0czoge1xyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICBlbmRPbmx5OiBmYWxzZSxcclxuICAgIG1pbjogbnVsbCxcclxuICAgIG1heDogbnVsbFxyXG4gIH0sXHJcblxyXG4gIHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KF9yZWYpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYuaW50ZXJhY3Rpb247XHJcblxyXG4gICAgcmV0dXJuIGludGVyYWN0aW9uLnN0YXJ0T2Zmc2V0O1xyXG4gIH0sXHJcblxyXG4gIHNldDogZnVuY3Rpb24gc2V0KGFyZykge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gYXJnLmludGVyYWN0aW9uLFxyXG4gICAgICAgIG9wdGlvbnMgPSBhcmcub3B0aW9ucztcclxuXHJcbiAgICB2YXIgZWRnZXMgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5saW5rZWRFZGdlcyB8fCBpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcztcclxuXHJcbiAgICBpZiAoIWludGVyYWN0aW9uLmludGVyYWN0aW5nKCkgfHwgIWVkZ2VzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVjdCA9IHJlY3RVdGlscy54eXdoVG9UbGJyKGludGVyYWN0aW9uLnJlc2l6ZVJlY3RzLmludmVydGVkKTtcclxuXHJcbiAgICB2YXIgbWluU2l6ZSA9IHJlY3RVdGlscy50bGJyVG9YeXdoKHJlc3RyaWN0RWRnZXMuZ2V0UmVzdHJpY3Rpb25SZWN0KG9wdGlvbnMubWluLCBpbnRlcmFjdGlvbikpIHx8IG5vTWluO1xyXG4gICAgdmFyIG1heFNpemUgPSByZWN0VXRpbHMudGxiclRvWHl3aChyZXN0cmljdEVkZ2VzLmdldFJlc3RyaWN0aW9uUmVjdChvcHRpb25zLm1heCwgaW50ZXJhY3Rpb24pKSB8fCBub01heDtcclxuXHJcbiAgICBhcmcub3B0aW9ucyA9IHtcclxuICAgICAgZW5hYmxlZDogb3B0aW9ucy5lbmFibGVkLFxyXG4gICAgICBlbmRPbmx5OiBvcHRpb25zLmVuZE9ubHksXHJcbiAgICAgIGlubmVyOiB1dGlscy5leHRlbmQoe30sIHJlc3RyaWN0RWRnZXMubm9Jbm5lciksXHJcbiAgICAgIG91dGVyOiB1dGlscy5leHRlbmQoe30sIHJlc3RyaWN0RWRnZXMubm9PdXRlcilcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGVkZ2VzLnRvcCkge1xyXG4gICAgICBhcmcub3B0aW9ucy5pbm5lci50b3AgPSByZWN0LmJvdHRvbSAtIG1pblNpemUuaGVpZ2h0O1xyXG4gICAgICBhcmcub3B0aW9ucy5vdXRlci50b3AgPSByZWN0LmJvdHRvbSAtIG1heFNpemUuaGVpZ2h0O1xyXG4gICAgfSBlbHNlIGlmIChlZGdlcy5ib3R0b20pIHtcclxuICAgICAgYXJnLm9wdGlvbnMuaW5uZXIuYm90dG9tID0gcmVjdC50b3AgKyBtaW5TaXplLmhlaWdodDtcclxuICAgICAgYXJnLm9wdGlvbnMub3V0ZXIuYm90dG9tID0gcmVjdC50b3AgKyBtYXhTaXplLmhlaWdodDtcclxuICAgIH1cclxuICAgIGlmIChlZGdlcy5sZWZ0KSB7XHJcbiAgICAgIGFyZy5vcHRpb25zLmlubmVyLmxlZnQgPSByZWN0LnJpZ2h0IC0gbWluU2l6ZS53aWR0aDtcclxuICAgICAgYXJnLm9wdGlvbnMub3V0ZXIubGVmdCA9IHJlY3QucmlnaHQgLSBtYXhTaXplLndpZHRoO1xyXG4gICAgfSBlbHNlIGlmIChlZGdlcy5yaWdodCkge1xyXG4gICAgICBhcmcub3B0aW9ucy5pbm5lci5yaWdodCA9IHJlY3QubGVmdCArIG1pblNpemUud2lkdGg7XHJcbiAgICAgIGFyZy5vcHRpb25zLm91dGVyLnJpZ2h0ID0gcmVjdC5sZWZ0ICsgbWF4U2l6ZS53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXN0cmljdEVkZ2VzLnNldChhcmcpO1xyXG4gIH0sXHJcblxyXG4gIG1vZGlmeUNvb3JkczogcmVzdHJpY3RFZGdlcy5tb2RpZnlDb29yZHNcclxufTtcclxuXHJcbm1vZGlmaWVycy5yZXN0cmljdFNpemUgPSByZXN0cmljdFNpemU7XHJcbm1vZGlmaWVycy5uYW1lcy5wdXNoKCdyZXN0cmljdFNpemUnKTtcclxuXHJcbmRlZmF1bHRPcHRpb25zLnBlckFjdGlvbi5yZXN0cmljdFNpemUgPSByZXN0cmljdFNpemUuZGVmYXVsdHM7XHJcbnJlc2l6ZS5kZWZhdWx0cy5yZXN0cmljdFNpemUgPSByZXN0cmljdFNpemUuZGVmYXVsdHM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3RyaWN0U2l6ZTtcclxuXHJcbn0se1wiLi4vYWN0aW9ucy9yZXNpemVcIjoxMCxcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi91dGlsc1wiOjQ0LFwiLi4vdXRpbHMvcmVjdFwiOjUxLFwiLi9pbmRleFwiOjI0LFwiLi9yZXN0cmljdEVkZ2VzXCI6MjZ9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBtb2RpZmllcnMgPSByZXF1aXJlKCcuL2luZGV4Jyk7XHJcbnZhciBpbnRlcmFjdCA9IHJlcXVpcmUoJy4uL2ludGVyYWN0Jyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRPcHRpb25zJyk7XHJcblxyXG52YXIgc25hcCA9IHtcclxuICBkZWZhdWx0czoge1xyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICBlbmRPbmx5OiBmYWxzZSxcclxuICAgIHJhbmdlOiBJbmZpbml0eSxcclxuICAgIHRhcmdldHM6IG51bGwsXHJcbiAgICBvZmZzZXRzOiBudWxsLFxyXG5cclxuICAgIHJlbGF0aXZlUG9pbnRzOiBudWxsXHJcbiAgfSxcclxuXHJcbiAgc2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQoX3JlZikge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gX3JlZi5pbnRlcmFjdGlvbixcclxuICAgICAgICBpbnRlcmFjdGFibGUgPSBfcmVmLmludGVyYWN0YWJsZSxcclxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxyXG4gICAgICAgIHJlY3QgPSBfcmVmLnJlY3QsXHJcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBfcmVmLnN0YXJ0T2Zmc2V0LFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XHJcblxyXG4gICAgdmFyIG9mZnNldHMgPSBbXTtcclxuICAgIHZhciBvcHRpb25zT3JpZ2luID0gdXRpbHMucmVjdFRvWFkodXRpbHMucmVzb2x2ZVJlY3RMaWtlKG9wdGlvbnMub3JpZ2luKSk7XHJcbiAgICB2YXIgb3JpZ2luID0gb3B0aW9uc09yaWdpbiB8fCB1dGlscy5nZXRPcmlnaW5YWShpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpO1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgaW50ZXJhY3RhYmxlLm9wdGlvbnNbaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZV0uc25hcCB8fCB7fTtcclxuXHJcbiAgICB2YXIgc25hcE9mZnNldCA9IHZvaWQgMDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgPT09ICdzdGFydENvb3JkcycpIHtcclxuICAgICAgc25hcE9mZnNldCA9IHtcclxuICAgICAgICB4OiBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnggLSBvcmlnaW4ueCxcclxuICAgICAgICB5OiBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLnkgLSBvcmlnaW4ueVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIG9mZnNldFJlY3QgPSB1dGlscy5yZXNvbHZlUmVjdExpa2Uob3B0aW9ucy5vZmZzZXQsIGludGVyYWN0YWJsZSwgZWxlbWVudCwgW2ludGVyYWN0aW9uXSk7XHJcblxyXG4gICAgICBzbmFwT2Zmc2V0ID0gdXRpbHMucmVjdFRvWFkob2Zmc2V0UmVjdCkgfHwgeyB4OiAwLCB5OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlY3QgJiYgb3B0aW9ucy5yZWxhdGl2ZVBvaW50cyAmJiBvcHRpb25zLnJlbGF0aXZlUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBvcHRpb25zLnJlbGF0aXZlUG9pbnRzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICAgIHZhciBfcmVmMjtcclxuXHJcbiAgICAgICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgX3JlZjIgPSBfaS52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfcmVmMyA9IF9yZWYyLFxyXG4gICAgICAgICAgICByZWxhdGl2ZVggPSBfcmVmMy54LFxyXG4gICAgICAgICAgICByZWxhdGl2ZVkgPSBfcmVmMy55O1xyXG5cclxuICAgICAgICBvZmZzZXRzLnB1c2goe1xyXG4gICAgICAgICAgeDogc3RhcnRPZmZzZXQubGVmdCAtIHJlY3Qud2lkdGggKiByZWxhdGl2ZVggKyBzbmFwT2Zmc2V0LngsXHJcbiAgICAgICAgICB5OiBzdGFydE9mZnNldC50b3AgLSByZWN0LmhlaWdodCAqIHJlbGF0aXZlWSArIHNuYXBPZmZzZXQueVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvZmZzZXRzLnB1c2goc25hcE9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9mZnNldHM7XHJcbiAgfSxcclxuXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQoX3JlZjQpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWY0LmludGVyYWN0aW9uLFxyXG4gICAgICAgIHBhZ2VDb29yZHMgPSBfcmVmNC5wYWdlQ29vcmRzLFxyXG4gICAgICAgIHN0YXR1cyA9IF9yZWY0LnN0YXR1cyxcclxuICAgICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucyxcclxuICAgICAgICBvZmZzZXRzID0gX3JlZjQub2Zmc2V0O1xyXG5cclxuICAgIHZhciB0YXJnZXRzID0gW107XHJcbiAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xyXG4gICAgdmFyIHBhZ2UgPSB2b2lkIDA7XHJcbiAgICB2YXIgaSA9IHZvaWQgMDtcclxuXHJcbiAgICBpZiAoc3RhdHVzLnVzZVN0YXR1c1hZKSB7XHJcbiAgICAgIHBhZ2UgPSB7IHg6IHN0YXR1cy54LCB5OiBzdGF0dXMueSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIG9yaWdpbiA9IHV0aWxzLmdldE9yaWdpblhZKGludGVyYWN0aW9uLnRhcmdldCwgaW50ZXJhY3Rpb24uZWxlbWVudCwgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSk7XHJcblxyXG4gICAgICBwYWdlID0gdXRpbHMuZXh0ZW5kKHt9LCBwYWdlQ29vcmRzKTtcclxuXHJcbiAgICAgIHBhZ2UueCAtPSBvcmlnaW4ueDtcclxuICAgICAgcGFnZS55IC09IG9yaWdpbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXR1cy5yZWFsWCA9IHBhZ2UueDtcclxuICAgIHN0YXR1cy5yZWFsWSA9IHBhZ2UueTtcclxuXHJcbiAgICB2YXIgbGVuID0gb3B0aW9ucy50YXJnZXRzID8gb3B0aW9ucy50YXJnZXRzLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG9mZnNldHMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICB2YXIgX3JlZjU7XHJcblxyXG4gICAgICBpZiAoX2lzQXJyYXkyKSB7XHJcbiAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3IyW19pMisrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcclxuICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgIF9yZWY1ID0gX2kyLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgX3JlZjYgPSBfcmVmNSxcclxuICAgICAgICAgIG9mZnNldFggPSBfcmVmNi54LFxyXG4gICAgICAgICAgb2Zmc2V0WSA9IF9yZWY2Lnk7XHJcblxyXG4gICAgICB2YXIgcmVsYXRpdmVYID0gcGFnZS54IC0gb2Zmc2V0WDtcclxuICAgICAgdmFyIHJlbGF0aXZlWSA9IHBhZ2UueSAtIG9mZnNldFk7XHJcblxyXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gb3B0aW9ucy50YXJnZXRzLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgICB2YXIgX3JlZjc7XHJcblxyXG4gICAgICAgIGlmIChfaXNBcnJheTMpIHtcclxuICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3IzW19pMysrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgICAgX3JlZjcgPSBfaTMudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc25hcFRhcmdldCA9IF9yZWY3O1xyXG5cclxuICAgICAgICBpZiAodXRpbHMuaXMuZnVuY3Rpb24oc25hcFRhcmdldCkpIHtcclxuICAgICAgICAgIHRhcmdldCA9IHNuYXBUYXJnZXQocmVsYXRpdmVYLCByZWxhdGl2ZVksIGludGVyYWN0aW9uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFyZ2V0ID0gc25hcFRhcmdldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRhcmdldHMucHVzaCh7XHJcbiAgICAgICAgICB4OiB1dGlscy5pcy5udW1iZXIodGFyZ2V0LngpID8gdGFyZ2V0LnggKyBvZmZzZXRYIDogcmVsYXRpdmVYLFxyXG4gICAgICAgICAgeTogdXRpbHMuaXMubnVtYmVyKHRhcmdldC55KSA/IHRhcmdldC55ICsgb2Zmc2V0WSA6IHJlbGF0aXZlWSxcclxuXHJcbiAgICAgICAgICByYW5nZTogdXRpbHMuaXMubnVtYmVyKHRhcmdldC5yYW5nZSkgPyB0YXJnZXQucmFuZ2UgOiBvcHRpb25zLnJhbmdlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2xvc2VzdCA9IHtcclxuICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICBpblJhbmdlOiBmYWxzZSxcclxuICAgICAgZGlzdGFuY2U6IDAsXHJcbiAgICAgIHJhbmdlOiAwLFxyXG4gICAgICBkeDogMCxcclxuICAgICAgZHk6IDBcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB0YXJnZXQgPSB0YXJnZXRzW2ldO1xyXG5cclxuICAgICAgdmFyIHJhbmdlID0gdGFyZ2V0LnJhbmdlO1xyXG4gICAgICB2YXIgZHggPSB0YXJnZXQueCAtIHBhZ2UueDtcclxuICAgICAgdmFyIGR5ID0gdGFyZ2V0LnkgLSBwYWdlLnk7XHJcbiAgICAgIHZhciBkaXN0YW5jZSA9IHV0aWxzLmh5cG90KGR4LCBkeSk7XHJcbiAgICAgIHZhciBpblJhbmdlID0gZGlzdGFuY2UgPD0gcmFuZ2U7XHJcblxyXG4gICAgICAvLyBJbmZpbml0ZSB0YXJnZXRzIGNvdW50IGFzIGJlaW5nIG91dCBvZiByYW5nZVxyXG4gICAgICAvLyBjb21wYXJlZCB0byBub24gaW5maW5pdGUgb25lcyB0aGF0IGFyZSBpbiByYW5nZVxyXG4gICAgICBpZiAocmFuZ2UgPT09IEluZmluaXR5ICYmIGNsb3Nlc3QuaW5SYW5nZSAmJiBjbG9zZXN0LnJhbmdlICE9PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGluUmFuZ2UgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjbG9zZXN0LnRhcmdldCB8fCAoaW5SYW5nZVxyXG4gICAgICAvLyBpcyB0aGUgY2xvc2VzdCB0YXJnZXQgaW4gcmFuZ2U/XHJcbiAgICAgID8gY2xvc2VzdC5pblJhbmdlICYmIHJhbmdlICE9PSBJbmZpbml0eVxyXG4gICAgICAvLyB0aGUgcG9pbnRlciBpcyByZWxhdGl2ZWx5IGRlZXBlciBpbiB0aGlzIHRhcmdldFxyXG4gICAgICA/IGRpc3RhbmNlIC8gcmFuZ2UgPCBjbG9zZXN0LmRpc3RhbmNlIC8gY2xvc2VzdC5yYW5nZVxyXG4gICAgICAvLyB0aGlzIHRhcmdldCBoYXMgSW5maW5pdGUgcmFuZ2UgYW5kIHRoZSBjbG9zZXN0IGRvZXNuJ3RcclxuICAgICAgOiByYW5nZSA9PT0gSW5maW5pdHkgJiYgY2xvc2VzdC5yYW5nZSAhPT0gSW5maW5pdHkgfHxcclxuICAgICAgLy8gT1IgdGhpcyB0YXJnZXQgaXMgY2xvc2VyIHRoYXQgdGhlIHByZXZpb3VzIGNsb3Nlc3RcclxuICAgICAgZGlzdGFuY2UgPCBjbG9zZXN0LmRpc3RhbmNlIDpcclxuICAgICAgLy8gVGhlIG90aGVyIGlzIG5vdCBpbiByYW5nZSBhbmQgdGhlIHBvaW50ZXIgaXMgY2xvc2VyIHRvIHRoaXMgdGFyZ2V0XHJcbiAgICAgICFjbG9zZXN0LmluUmFuZ2UgJiYgZGlzdGFuY2UgPCBjbG9zZXN0LmRpc3RhbmNlKSkge1xyXG5cclxuICAgICAgICBjbG9zZXN0LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICBjbG9zZXN0LmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgY2xvc2VzdC5yYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIGNsb3Nlc3QuaW5SYW5nZSA9IGluUmFuZ2U7XHJcbiAgICAgICAgY2xvc2VzdC5keCA9IGR4O1xyXG4gICAgICAgIGNsb3Nlc3QuZHkgPSBkeTtcclxuXHJcbiAgICAgICAgc3RhdHVzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc25hcENoYW5nZWQgPSB2b2lkIDA7XHJcblxyXG4gICAgaWYgKGNsb3Nlc3QudGFyZ2V0KSB7XHJcbiAgICAgIHNuYXBDaGFuZ2VkID0gc3RhdHVzLm1vZGlmaWVkWCAhPT0gY2xvc2VzdC50YXJnZXQueCB8fCBzdGF0dXMubW9kaWZpZWRZICE9PSBjbG9zZXN0LnRhcmdldC55O1xyXG5cclxuICAgICAgc3RhdHVzLm1vZGlmaWVkWCA9IGNsb3Nlc3QudGFyZ2V0Lng7XHJcbiAgICAgIHN0YXR1cy5tb2RpZmllZFkgPSBjbG9zZXN0LnRhcmdldC55O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc25hcENoYW5nZWQgPSB0cnVlO1xyXG5cclxuICAgICAgc3RhdHVzLm1vZGlmaWVkWCA9IE5hTjtcclxuICAgICAgc3RhdHVzLm1vZGlmaWVkWSA9IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0dXMuZHggPSBjbG9zZXN0LmR4O1xyXG4gICAgc3RhdHVzLmR5ID0gY2xvc2VzdC5keTtcclxuXHJcbiAgICBzdGF0dXMuY2hhbmdlZCA9IHNuYXBDaGFuZ2VkIHx8IGNsb3Nlc3QuaW5SYW5nZSAmJiAhc3RhdHVzLmxvY2tlZDtcclxuICAgIHN0YXR1cy5sb2NrZWQgPSBjbG9zZXN0LmluUmFuZ2U7XHJcbiAgfSxcclxuXHJcbiAgbW9kaWZ5Q29vcmRzOiBmdW5jdGlvbiBtb2RpZnlDb29yZHMoX3JlZjgpIHtcclxuICAgIHZhciBwYWdlID0gX3JlZjgucGFnZSxcclxuICAgICAgICBjbGllbnQgPSBfcmVmOC5jbGllbnQsXHJcbiAgICAgICAgc3RhdHVzID0gX3JlZjguc3RhdHVzLFxyXG4gICAgICAgIHBoYXNlID0gX3JlZjgucGhhc2UsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWY4Lm9wdGlvbnM7XHJcblxyXG4gICAgdmFyIHJlbGF0aXZlUG9pbnRzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF0aXZlUG9pbnRzO1xyXG5cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5hYmxlZCAmJiAhKHBoYXNlID09PSAnc3RhcnQnICYmIHJlbGF0aXZlUG9pbnRzICYmIHJlbGF0aXZlUG9pbnRzLmxlbmd0aCkpIHtcclxuXHJcbiAgICAgIGlmIChzdGF0dXMubG9ja2VkKSB7XHJcbiAgICAgICAgcGFnZS54ICs9IHN0YXR1cy5keDtcclxuICAgICAgICBwYWdlLnkgKz0gc3RhdHVzLmR5O1xyXG4gICAgICAgIGNsaWVudC54ICs9IHN0YXR1cy5keDtcclxuICAgICAgICBjbGllbnQueSArPSBzdGF0dXMuZHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmFuZ2U6IHN0YXR1cy5yYW5nZSxcclxuICAgICAgICBsb2NrZWQ6IHN0YXR1cy5sb2NrZWQsXHJcbiAgICAgICAgeDogc3RhdHVzLm1vZGlmaWVkWCxcclxuICAgICAgICB5OiBzdGF0dXMubW9kaWZpZWRZLFxyXG4gICAgICAgIHJlYWxYOiBzdGF0dXMucmVhbFgsXHJcbiAgICAgICAgcmVhbFk6IHN0YXR1cy5yZWFsWSxcclxuICAgICAgICBkeDogc3RhdHVzLmR4LFxyXG4gICAgICAgIGR5OiBzdGF0dXMuZHlcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5pbnRlcmFjdC5jcmVhdGVTbmFwR3JpZCA9IGZ1bmN0aW9uIChncmlkKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICB2YXIgbGltaXRzID0gZ3JpZC5saW1pdHMgfHwge1xyXG4gICAgICBsZWZ0OiAtSW5maW5pdHksXHJcbiAgICAgIHJpZ2h0OiBJbmZpbml0eSxcclxuICAgICAgdG9wOiAtSW5maW5pdHksXHJcbiAgICAgIGJvdHRvbTogSW5maW5pdHlcclxuICAgIH07XHJcbiAgICB2YXIgb2Zmc2V0WCA9IDA7XHJcbiAgICB2YXIgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgaWYgKHV0aWxzLmlzLm9iamVjdChncmlkLm9mZnNldCkpIHtcclxuICAgICAgb2Zmc2V0WCA9IGdyaWQub2Zmc2V0Lng7XHJcbiAgICAgIG9mZnNldFkgPSBncmlkLm9mZnNldC55O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBncmlkeCA9IE1hdGgucm91bmQoKHggLSBvZmZzZXRYKSAvIGdyaWQueCk7XHJcbiAgICB2YXIgZ3JpZHkgPSBNYXRoLnJvdW5kKCh5IC0gb2Zmc2V0WSkgLyBncmlkLnkpO1xyXG5cclxuICAgIHZhciBuZXdYID0gTWF0aC5tYXgobGltaXRzLmxlZnQsIE1hdGgubWluKGxpbWl0cy5yaWdodCwgZ3JpZHggKiBncmlkLnggKyBvZmZzZXRYKSk7XHJcbiAgICB2YXIgbmV3WSA9IE1hdGgubWF4KGxpbWl0cy50b3AsIE1hdGgubWluKGxpbWl0cy5ib3R0b20sIGdyaWR5ICogZ3JpZC55ICsgb2Zmc2V0WSkpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IG5ld1gsXHJcbiAgICAgIHk6IG5ld1ksXHJcbiAgICAgIHJhbmdlOiBncmlkLnJhbmdlXHJcbiAgICB9O1xyXG4gIH07XHJcbn07XHJcblxyXG5tb2RpZmllcnMuc25hcCA9IHNuYXA7XHJcbm1vZGlmaWVycy5uYW1lcy5wdXNoKCdzbmFwJyk7XHJcblxyXG5kZWZhdWx0T3B0aW9ucy5wZXJBY3Rpb24uc25hcCA9IHNuYXAuZGVmYXVsdHM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNuYXA7XHJcblxyXG59LHtcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi9pbnRlcmFjdFwiOjIxLFwiLi4vdXRpbHNcIjo0NCxcIi4vaW5kZXhcIjoyNH1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVGhpcyBtb2R1bGUgYWxsb3dzIHNuYXBwaW5nIG9mIHRoZSBzaXplIG9mIHRhcmdldHMgZHVyaW5nIHJlc2l6ZVxyXG4vLyBpbnRlcmFjdGlvbnMuXHJcblxyXG52YXIgbW9kaWZpZXJzID0gcmVxdWlyZSgnLi9pbmRleCcpO1xyXG52YXIgc25hcCA9IHJlcXVpcmUoJy4vc25hcCcpO1xyXG52YXIgZGVmYXVsdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9kZWZhdWx0T3B0aW9ucycpO1xyXG52YXIgcmVzaXplID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9yZXNpemUnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvJyk7XHJcblxyXG52YXIgc25hcFNpemUgPSB7XHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgZW5kT25seTogZmFsc2UsXHJcbiAgICByYW5nZTogSW5maW5pdHksXHJcbiAgICB0YXJnZXRzOiBudWxsLFxyXG4gICAgb2Zmc2V0czogbnVsbFxyXG4gIH0sXHJcblxyXG4gIHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KGFyZykge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gYXJnLmludGVyYWN0aW9uLFxyXG4gICAgICAgIG9wdGlvbnMgPSBhcmcub3B0aW9ucztcclxuXHJcbiAgICB2YXIgZWRnZXMgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcztcclxuXHJcbiAgICBpZiAoIWVkZ2VzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBhcmcub3B0aW9ucyA9IHtcclxuICAgICAgcmVsYXRpdmVQb2ludHM6IFt7XHJcbiAgICAgICAgeDogZWRnZXMubGVmdCA/IDAgOiAxLFxyXG4gICAgICAgIHk6IGVkZ2VzLnRvcCA/IDAgOiAxXHJcbiAgICAgIH1dLFxyXG4gICAgICBvcmlnaW46IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICBvZmZzZXQ6ICdzZWxmJyxcclxuICAgICAgcmFuZ2U6IG9wdGlvbnMucmFuZ2VcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9mZnNldHMgPSBzbmFwLnNldE9mZnNldChhcmcpO1xyXG4gICAgYXJnLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cclxuICAgIHJldHVybiBvZmZzZXRzO1xyXG4gIH0sXHJcblxyXG4gIHNldDogZnVuY3Rpb24gc2V0KGFyZykge1xyXG4gICAgdmFyIGludGVyYWN0aW9uID0gYXJnLmludGVyYWN0aW9uLFxyXG4gICAgICAgIG9wdGlvbnMgPSBhcmcub3B0aW9ucyxcclxuICAgICAgICBvZmZzZXQgPSBhcmcub2Zmc2V0LFxyXG4gICAgICAgIHBhZ2VDb29yZHMgPSBhcmcucGFnZUNvb3JkcztcclxuXHJcbiAgICB2YXIgcGFnZSA9IHV0aWxzLmV4dGVuZCh7fSwgcGFnZUNvb3Jkcyk7XHJcbiAgICB2YXIgcmVsYXRpdmVYID0gcGFnZS54IC0gb2Zmc2V0WzBdLng7XHJcbiAgICB2YXIgcmVsYXRpdmVZID0gcGFnZS55IC0gb2Zmc2V0WzBdLnk7XHJcblxyXG4gICAgYXJnLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gICAgYXJnLm9wdGlvbnMudGFyZ2V0cyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG9wdGlvbnMudGFyZ2V0cywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWY7XHJcblxyXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcclxuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNuYXBUYXJnZXQgPSBfcmVmO1xyXG5cclxuICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcclxuXHJcbiAgICAgIGlmICh1dGlscy5pcy5mdW5jdGlvbihzbmFwVGFyZ2V0KSkge1xyXG4gICAgICAgIHRhcmdldCA9IHNuYXBUYXJnZXQocmVsYXRpdmVYLCByZWxhdGl2ZVksIGludGVyYWN0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXQgPSBzbmFwVGFyZ2V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoJ3dpZHRoJyBpbiB0YXJnZXQgJiYgJ2hlaWdodCcgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0LnggPSB0YXJnZXQud2lkdGg7XHJcbiAgICAgICAgdGFyZ2V0LnkgPSB0YXJnZXQuaGVpZ2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcmcub3B0aW9ucy50YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBzbmFwLnNldChhcmcpO1xyXG4gIH0sXHJcblxyXG4gIG1vZGlmeUNvb3JkczogZnVuY3Rpb24gbW9kaWZ5Q29vcmRzKGFyZykge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmcub3B0aW9ucztcclxuXHJcblxyXG4gICAgYXJnLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIG9wdGlvbnMpO1xyXG4gICAgYXJnLm9wdGlvbnMuZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcclxuICAgIGFyZy5vcHRpb25zLnJlbGF0aXZlUG9pbnRzID0gW251bGxdO1xyXG5cclxuICAgIHNuYXAubW9kaWZ5Q29vcmRzKGFyZyk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kaWZpZXJzLnNuYXBTaXplID0gc25hcFNpemU7XHJcbm1vZGlmaWVycy5uYW1lcy5wdXNoKCdzbmFwU2l6ZScpO1xyXG5cclxuZGVmYXVsdE9wdGlvbnMucGVyQWN0aW9uLnNuYXBTaXplID0gc25hcFNpemUuZGVmYXVsdHM7XHJcbnJlc2l6ZS5kZWZhdWx0cy5zbmFwU2l6ZSA9IHNuYXBTaXplLmRlZmF1bHRzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzbmFwU2l6ZTtcclxuXHJcbn0se1wiLi4vYWN0aW9ucy9yZXNpemVcIjoxMCxcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi91dGlscy9cIjo0NCxcIi4vaW5kZXhcIjoyNCxcIi4vc25hcFwiOjI4fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxudmFyIHBvaW50ZXJVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3BvaW50ZXJVdGlscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KHR5cGUsIHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgaW50ZXJhY3Rpb24pIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludGVyRXZlbnQpO1xyXG5cclxuICAgIHBvaW50ZXJVdGlscy5wb2ludGVyRXh0ZW5kKHRoaXMsIGV2ZW50KTtcclxuXHJcbiAgICBpZiAoZXZlbnQgIT09IHBvaW50ZXIpIHtcclxuICAgICAgcG9pbnRlclV0aWxzLnBvaW50ZXJFeHRlbmQodGhpcywgcG9pbnRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uO1xyXG5cclxuICAgIHRoaXMudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLnBvaW50ZXJJZCA9IHBvaW50ZXJVdGlscy5nZXRQb2ludGVySWQocG9pbnRlcik7XHJcbiAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclV0aWxzLmdldFBvaW50ZXJUeXBlKHBvaW50ZXIpO1xyXG4gICAgdGhpcy50YXJnZXQgPSBldmVudFRhcmdldDtcclxuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICd0YXAnKSB7XHJcbiAgICAgIHZhciBwb2ludGVySW5kZXggPSBpbnRlcmFjdGlvbi5nZXRQb2ludGVySW5kZXgocG9pbnRlcik7XHJcbiAgICAgIHRoaXMuZHQgPSB0aGlzLnRpbWVTdGFtcCAtIGludGVyYWN0aW9uLmRvd25UaW1lc1twb2ludGVySW5kZXhdO1xyXG5cclxuICAgICAgdmFyIGludGVydmFsID0gdGhpcy50aW1lU3RhbXAgLSBpbnRlcmFjdGlvbi50YXBUaW1lO1xyXG5cclxuICAgICAgdGhpcy5kb3VibGUgPSAhIShpbnRlcmFjdGlvbi5wcmV2VGFwICYmIGludGVyYWN0aW9uLnByZXZUYXAudHlwZSAhPT0gJ2RvdWJsZXRhcCcgJiYgaW50ZXJhY3Rpb24ucHJldlRhcC50YXJnZXQgPT09IHRoaXMudGFyZ2V0ICYmIGludGVydmFsIDwgNTAwKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RvdWJsZXRhcCcpIHtcclxuICAgICAgdGhpcy5kdCA9IHBvaW50ZXIudGltZVN0YW1wIC0gaW50ZXJhY3Rpb24udGFwVGltZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUuc3VidHJhY3RPcmlnaW4gPSBmdW5jdGlvbiBzdWJ0cmFjdE9yaWdpbihfcmVmKSB7XHJcbiAgICB2YXIgb3JpZ2luWCA9IF9yZWYueCxcclxuICAgICAgICBvcmlnaW5ZID0gX3JlZi55O1xyXG5cclxuICAgIHRoaXMucGFnZVggLT0gb3JpZ2luWDtcclxuICAgIHRoaXMucGFnZVkgLT0gb3JpZ2luWTtcclxuICAgIHRoaXMuY2xpZW50WCAtPSBvcmlnaW5YO1xyXG4gICAgdGhpcy5jbGllbnRZIC09IG9yaWdpblk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgUG9pbnRlckV2ZW50LnByb3RvdHlwZS5hZGRPcmlnaW4gPSBmdW5jdGlvbiBhZGRPcmlnaW4oX3JlZjIpIHtcclxuICAgIHZhciBvcmlnaW5YID0gX3JlZjIueCxcclxuICAgICAgICBvcmlnaW5ZID0gX3JlZjIueTtcclxuXHJcbiAgICB0aGlzLnBhZ2VYICs9IG9yaWdpblg7XHJcbiAgICB0aGlzLnBhZ2VZICs9IG9yaWdpblk7XHJcbiAgICB0aGlzLmNsaWVudFggKz0gb3JpZ2luWDtcclxuICAgIHRoaXMuY2xpZW50WSArPSBvcmlnaW5ZO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcclxuICAgIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH07XHJcblxyXG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG4gIH07XHJcblxyXG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xyXG4gICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFBvaW50ZXJFdmVudDtcclxufSgpO1xyXG5cclxufSx7XCIuLi91dGlscy9wb2ludGVyVXRpbHNcIjo0OX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFBvaW50ZXJFdmVudCA9IHJlcXVpcmUoJy4vUG9pbnRlckV2ZW50Jyk7XHJcbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4uL0ludGVyYWN0aW9uJyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpO1xyXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0T3B0aW9ucycpO1xyXG52YXIgc2lnbmFscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1NpZ25hbHMnKS5uZXcoKTtcclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2FycicpLFxyXG4gICAgZmlsdGVyID0gX3JlcXVpcmUuZmlsdGVyO1xyXG5cclxudmFyIHNpbXBsZVNpZ25hbHMgPSBbJ2Rvd24nLCAndXAnLCAnY2FuY2VsJ107XHJcbnZhciBzaW1wbGVFdmVudHMgPSBbJ2Rvd24nLCAndXAnLCAnY2FuY2VsJ107XHJcblxyXG52YXIgcG9pbnRlckV2ZW50cyA9IHtcclxuICBQb2ludGVyRXZlbnQ6IFBvaW50ZXJFdmVudCxcclxuICBmaXJlOiBmaXJlLFxyXG4gIGNvbGxlY3RFdmVudFRhcmdldHM6IGNvbGxlY3RFdmVudFRhcmdldHMsXHJcbiAgc2lnbmFsczogc2lnbmFscyxcclxuICBkZWZhdWx0czoge1xyXG4gICAgaG9sZER1cmF0aW9uOiA2MDAsXHJcbiAgICBpZ25vcmVGcm9tOiBudWxsLFxyXG4gICAgYWxsb3dGcm9tOiBudWxsLFxyXG4gICAgb3JpZ2luOiB7IHg6IDAsIHk6IDAgfVxyXG4gIH0sXHJcbiAgdHlwZXM6IFsnZG93bicsICdtb3ZlJywgJ3VwJywgJ2NhbmNlbCcsICd0YXAnLCAnZG91YmxldGFwJywgJ2hvbGQnXVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZmlyZShhcmcpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBhcmcuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXIgPSBhcmcucG9pbnRlcixcclxuICAgICAgZXZlbnQgPSBhcmcuZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0ID0gYXJnLmV2ZW50VGFyZ2V0LFxyXG4gICAgICBfYXJnJHR5cGUgPSBhcmcudHlwZSxcclxuICAgICAgdHlwZSA9IF9hcmckdHlwZSA9PT0gdW5kZWZpbmVkID8gYXJnLnBvaW50ZXJFdmVudC50eXBlIDogX2FyZyR0eXBlLFxyXG4gICAgICBfYXJnJHRhcmdldHMgPSBhcmcudGFyZ2V0cyxcclxuICAgICAgdGFyZ2V0cyA9IF9hcmckdGFyZ2V0cyA9PT0gdW5kZWZpbmVkID8gY29sbGVjdEV2ZW50VGFyZ2V0cyhhcmcpIDogX2FyZyR0YXJnZXRzLFxyXG4gICAgICBfYXJnJHBvaW50ZXJFdmVudCA9IGFyZy5wb2ludGVyRXZlbnQsXHJcbiAgICAgIHBvaW50ZXJFdmVudCA9IF9hcmckcG9pbnRlckV2ZW50ID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnRlckV2ZW50KHR5cGUsIHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgaW50ZXJhY3Rpb24pIDogX2FyZyRwb2ludGVyRXZlbnQ7XHJcblxyXG5cclxuICB2YXIgc2lnbmFsQXJnID0ge1xyXG4gICAgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uLFxyXG4gICAgcG9pbnRlcjogcG9pbnRlcixcclxuICAgIGV2ZW50OiBldmVudCxcclxuICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcclxuICAgIHRhcmdldHM6IHRhcmdldHMsXHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAgcG9pbnRlckV2ZW50OiBwb2ludGVyRXZlbnRcclxuICB9O1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xyXG5cclxuICAgIGZvciAodmFyIHByb3AgaW4gdGFyZ2V0LnByb3BzIHx8IHt9KSB7XHJcbiAgICAgIHBvaW50ZXJFdmVudFtwcm9wXSA9IHRhcmdldC5wcm9wc1twcm9wXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3JpZ2luID0gdXRpbHMuZ2V0T3JpZ2luWFkodGFyZ2V0LmV2ZW50YWJsZSwgdGFyZ2V0LmVsZW1lbnQpO1xyXG5cclxuICAgIHBvaW50ZXJFdmVudC5zdWJ0cmFjdE9yaWdpbihvcmlnaW4pO1xyXG4gICAgcG9pbnRlckV2ZW50LmV2ZW50YWJsZSA9IHRhcmdldC5ldmVudGFibGU7XHJcbiAgICBwb2ludGVyRXZlbnQuY3VycmVudFRhcmdldCA9IHRhcmdldC5lbGVtZW50O1xyXG5cclxuICAgIHRhcmdldC5ldmVudGFibGUuZmlyZShwb2ludGVyRXZlbnQpO1xyXG5cclxuICAgIHBvaW50ZXJFdmVudC5hZGRPcmlnaW4ob3JpZ2luKTtcclxuXHJcbiAgICBpZiAocG9pbnRlckV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCB8fCBwb2ludGVyRXZlbnQucHJvcGFnYXRpb25TdG9wcGVkICYmIGkgKyAxIDwgdGFyZ2V0cy5sZW5ndGggJiYgdGFyZ2V0c1tpICsgMV0uZWxlbWVudCAhPT0gcG9pbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzaWduYWxzLmZpcmUoJ2ZpcmVkJywgc2lnbmFsQXJnKTtcclxuXHJcbiAgaWYgKHR5cGUgPT09ICd0YXAnKSB7XHJcbiAgICAvLyBpZiBwb2ludGVyRXZlbnQgc2hvdWxkIG1ha2UgYSBkb3VibGUgdGFwLCBjcmVhdGUgYW5kIGZpcmUgYSBkb3VibGV0YXBcclxuICAgIC8vIFBvaW50ZXJFdmVudCBhbmQgdXNlIHRoYXQgYXMgdGhlIHByZXZUYXBcclxuICAgIHZhciBwcmV2VGFwID0gcG9pbnRlckV2ZW50LmRvdWJsZSA/IGZpcmUoe1xyXG4gICAgICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sIHBvaW50ZXI6IHBvaW50ZXIsIGV2ZW50OiBldmVudCwgZXZlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxyXG4gICAgICB0eXBlOiAnZG91YmxldGFwJ1xyXG4gICAgfSkgOiBwb2ludGVyRXZlbnQ7XHJcblxyXG4gICAgaW50ZXJhY3Rpb24ucHJldlRhcCA9IHByZXZUYXA7XHJcbiAgICBpbnRlcmFjdGlvbi50YXBUaW1lID0gcHJldlRhcC50aW1lU3RhbXA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcG9pbnRlckV2ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsZWN0RXZlbnRUYXJnZXRzKF9yZWYpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmLmludGVyYWN0aW9uLFxyXG4gICAgICBwb2ludGVyID0gX3JlZi5wb2ludGVyLFxyXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQsXHJcbiAgICAgIGV2ZW50VGFyZ2V0ID0gX3JlZi5ldmVudFRhcmdldCxcclxuICAgICAgdHlwZSA9IF9yZWYudHlwZTtcclxuXHJcbiAgdmFyIHBvaW50ZXJJbmRleCA9IGludGVyYWN0aW9uLmdldFBvaW50ZXJJbmRleChwb2ludGVyKTtcclxuXHJcbiAgLy8gZG8gbm90IGZpcmUgYSB0YXAgZXZlbnQgaWYgdGhlIHBvaW50ZXIgd2FzIG1vdmVkIGJlZm9yZSBiZWluZyBsaWZ0ZWRcclxuICBpZiAodHlwZSA9PT0gJ3RhcCcgJiYgKGludGVyYWN0aW9uLnBvaW50ZXJXYXNNb3ZlZFxyXG4gIC8vIG9yIGlmIHRoZSBwb2ludGVydXAgdGFyZ2V0IGlzIGRpZmZlcmVudCB0byB0aGUgcG9pbnRlcmRvd24gdGFyZ2V0XHJcbiAgfHwgIShpbnRlcmFjdGlvbi5kb3duVGFyZ2V0c1twb2ludGVySW5kZXhdICYmIGludGVyYWN0aW9uLmRvd25UYXJnZXRzW3BvaW50ZXJJbmRleF0gPT09IGV2ZW50VGFyZ2V0KSkpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIHZhciBwYXRoID0gdXRpbHMuZ2V0UGF0aChldmVudFRhcmdldCk7XHJcbiAgdmFyIHNpZ25hbEFyZyA9IHtcclxuICAgIGludGVyYWN0aW9uOiBpbnRlcmFjdGlvbixcclxuICAgIHBvaW50ZXI6IHBvaW50ZXIsXHJcbiAgICBldmVudDogZXZlbnQsXHJcbiAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAgcGF0aDogcGF0aCxcclxuICAgIHRhcmdldHM6IFtdLFxyXG4gICAgZWxlbWVudDogbnVsbFxyXG4gIH07XHJcblxyXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IHBhdGgsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICB2YXIgX3JlZjI7XHJcblxyXG4gICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgX3JlZjIgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgX3JlZjIgPSBfaS52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IF9yZWYyO1xyXG5cclxuICAgIHNpZ25hbEFyZy5lbGVtZW50ID0gZWxlbWVudDtcclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ2NvbGxlY3QtdGFyZ2V0cycsIHNpZ25hbEFyZyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZSA9PT0gJ2hvbGQnKSB7XHJcbiAgICBzaWduYWxBcmcudGFyZ2V0cyA9IGZpbHRlcihzaWduYWxBcmcudGFyZ2V0cywgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICByZXR1cm4gdGFyZ2V0LmV2ZW50YWJsZS5vcHRpb25zLmhvbGREdXJhdGlvbiA9PT0gaW50ZXJhY3Rpb24uaG9sZFRpbWVyc1twb2ludGVySW5kZXhdLmR1cmF0aW9uO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2lnbmFsQXJnLnRhcmdldHM7XHJcbn1cclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ3VwZGF0ZS1wb2ludGVyLWRvd24nLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbixcclxuICAgICAgcG9pbnRlckluZGV4ID0gX3JlZjMucG9pbnRlckluZGV4O1xyXG5cclxuICBpbnRlcmFjdGlvbi5ob2xkVGltZXJzW3BvaW50ZXJJbmRleF0gPSB7IGR1cmF0aW9uOiBJbmZpbml0eSwgdGltZW91dDogbnVsbCB9O1xyXG59KTtcclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ3JlbW92ZS1wb2ludGVyJywgZnVuY3Rpb24gKF9yZWY0KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjQuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXJJbmRleCA9IF9yZWY0LnBvaW50ZXJJbmRleDtcclxuXHJcbiAgaW50ZXJhY3Rpb24uaG9sZFRpbWVycy5zcGxpY2UocG9pbnRlckluZGV4LCAxKTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdtb3ZlJywgZnVuY3Rpb24gKF9yZWY1KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjUuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXIgPSBfcmVmNS5wb2ludGVyLFxyXG4gICAgICBldmVudCA9IF9yZWY1LmV2ZW50LFxyXG4gICAgICBldmVudFRhcmdldCA9IF9yZWY1LmV2ZW50VGFyZ2V0LFxyXG4gICAgICBkdXBsaWNhdGVNb3ZlID0gX3JlZjUuZHVwbGljYXRlTW92ZTtcclxuXHJcbiAgdmFyIHBvaW50ZXJJbmRleCA9IGludGVyYWN0aW9uLmdldFBvaW50ZXJJbmRleChwb2ludGVyKTtcclxuXHJcbiAgaWYgKCFkdXBsaWNhdGVNb3ZlICYmICghaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93biB8fCBpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQpKSB7XHJcbiAgICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93bikge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaW50ZXJhY3Rpb24uaG9sZFRpbWVyc1twb2ludGVySW5kZXhdLnRpbWVvdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpcmUoe1xyXG4gICAgICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sIHBvaW50ZXI6IHBvaW50ZXIsIGV2ZW50OiBldmVudCwgZXZlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxyXG4gICAgICB0eXBlOiAnbW92ZSdcclxuICAgIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCdkb3duJywgZnVuY3Rpb24gKF9yZWY2KSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjYuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXIgPSBfcmVmNi5wb2ludGVyLFxyXG4gICAgICBldmVudCA9IF9yZWY2LmV2ZW50LFxyXG4gICAgICBldmVudFRhcmdldCA9IF9yZWY2LmV2ZW50VGFyZ2V0LFxyXG4gICAgICBwb2ludGVySW5kZXggPSBfcmVmNi5wb2ludGVySW5kZXg7XHJcblxyXG4gIC8vIGNvcHkgZXZlbnQgdG8gYmUgdXNlZCBpbiB0aW1lb3V0IGZvciBJRThcclxuICB2YXIgZXZlbnRDb3B5ID0gYnJvd3Nlci5pc0lFOCA/IHV0aWxzLmV4dGVuZCh7fSwgZXZlbnQpIDogZXZlbnQ7XHJcblxyXG4gIHZhciB0aW1lciA9IGludGVyYWN0aW9uLmhvbGRUaW1lcnNbcG9pbnRlckluZGV4XTtcclxuICB2YXIgcGF0aCA9IHV0aWxzLmdldFBhdGgoZXZlbnRUYXJnZXQpO1xyXG4gIHZhciBzaWduYWxBcmcgPSB7XHJcbiAgICBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sXHJcbiAgICBwb2ludGVyOiBwb2ludGVyLFxyXG4gICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgZXZlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxyXG4gICAgdHlwZTogJ2hvbGQnLFxyXG4gICAgdGFyZ2V0czogW10sXHJcbiAgICBwYXRoOiBwYXRoLFxyXG4gICAgZWxlbWVudDogbnVsbFxyXG4gIH07XHJcblxyXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBwYXRoLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgIHZhciBfcmVmNztcclxuXHJcbiAgICBpZiAoX2lzQXJyYXkyKSB7XHJcbiAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICBfcmVmNyA9IF9pdGVyYXRvcjJbX2kyKytdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XHJcbiAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XHJcbiAgICAgIF9yZWY3ID0gX2kyLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbGVtZW50ID0gX3JlZjc7XHJcblxyXG4gICAgc2lnbmFsQXJnLmVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgIHNpZ25hbHMuZmlyZSgnY29sbGVjdC10YXJnZXRzJywgc2lnbmFsQXJnKTtcclxuICB9XHJcblxyXG4gIGlmICghc2lnbmFsQXJnLnRhcmdldHMubGVuZ3RoKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgbWluRHVyYXRpb24gPSBJbmZpbml0eTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYWxBcmcudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHRhcmdldCA9IHNpZ25hbEFyZy50YXJnZXRzW2ldO1xyXG4gICAgdmFyIGhvbGREdXJhdGlvbiA9IHRhcmdldC5ldmVudGFibGUub3B0aW9ucy5ob2xkRHVyYXRpb247XHJcblxyXG4gICAgaWYgKGhvbGREdXJhdGlvbiA8IG1pbkR1cmF0aW9uKSB7XHJcbiAgICAgIG1pbkR1cmF0aW9uID0gaG9sZER1cmF0aW9uO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGltZXIuZHVyYXRpb24gPSBtaW5EdXJhdGlvbjtcclxuICB0aW1lci50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICBmaXJlKHtcclxuICAgICAgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uLFxyXG4gICAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXHJcbiAgICAgIHBvaW50ZXI6IGJyb3dzZXIuaXNJRTggPyBldmVudENvcHkgOiBwb2ludGVyLFxyXG4gICAgICBldmVudDogZXZlbnRDb3B5LFxyXG4gICAgICB0eXBlOiAnaG9sZCdcclxuICAgIH0pO1xyXG4gIH0sIG1pbkR1cmF0aW9uKTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGlvbi5zaWduYWxzLm9uKCd1cCcsIGZ1bmN0aW9uIChfcmVmOCkge1xyXG4gIHZhciBpbnRlcmFjdGlvbiA9IF9yZWY4LmludGVyYWN0aW9uLFxyXG4gICAgICBwb2ludGVyID0gX3JlZjgucG9pbnRlcixcclxuICAgICAgZXZlbnQgPSBfcmVmOC5ldmVudCxcclxuICAgICAgZXZlbnRUYXJnZXQgPSBfcmVmOC5ldmVudFRhcmdldDtcclxuXHJcbiAgaWYgKCFpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQpIHtcclxuICAgIGZpcmUoeyBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCwgcG9pbnRlcjogcG9pbnRlciwgZXZlbnQ6IGV2ZW50LCB0eXBlOiAndGFwJyB9KTtcclxuICB9XHJcbn0pO1xyXG5cclxuWyd1cCcsICdjYW5jZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduYWxOYW1lKSB7XHJcbiAgSW50ZXJhY3Rpb24uc2lnbmFscy5vbihzaWduYWxOYW1lLCBmdW5jdGlvbiAoX3JlZjkpIHtcclxuICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWY5LmludGVyYWN0aW9uLFxyXG4gICAgICAgIHBvaW50ZXJJbmRleCA9IF9yZWY5LnBvaW50ZXJJbmRleDtcclxuXHJcbiAgICBpZiAoaW50ZXJhY3Rpb24uaG9sZFRpbWVyc1twb2ludGVySW5kZXhdKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChpbnRlcmFjdGlvbi5ob2xkVGltZXJzW3BvaW50ZXJJbmRleF0udGltZW91dCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlU2lnbmFsTGlzdGVuZXIodHlwZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZjEwKSB7XHJcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMTAuaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgcG9pbnRlciA9IF9yZWYxMC5wb2ludGVyLFxyXG4gICAgICAgIGV2ZW50ID0gX3JlZjEwLmV2ZW50LFxyXG4gICAgICAgIGV2ZW50VGFyZ2V0ID0gX3JlZjEwLmV2ZW50VGFyZ2V0O1xyXG5cclxuICAgIGZpcmUoeyBpbnRlcmFjdGlvbjogaW50ZXJhY3Rpb24sIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCwgcG9pbnRlcjogcG9pbnRlciwgZXZlbnQ6IGV2ZW50LCB0eXBlOiB0eXBlIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbmZvciAodmFyIGkgPSAwOyBpIDwgc2ltcGxlU2lnbmFscy5sZW5ndGg7IGkrKykge1xyXG4gIEludGVyYWN0aW9uLnNpZ25hbHMub24oc2ltcGxlU2lnbmFsc1tpXSwgY3JlYXRlU2lnbmFsTGlzdGVuZXIoc2ltcGxlRXZlbnRzW2ldKSk7XHJcbn1cclxuXHJcbkludGVyYWN0aW9uLnNpZ25hbHMub24oJ25ldycsIGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xyXG4gIGludGVyYWN0aW9uLnByZXZUYXAgPSBudWxsOyAvLyB0aGUgbW9zdCByZWNlbnQgdGFwIGV2ZW50IG9uIHRoaXMgaW50ZXJhY3Rpb25cclxuICBpbnRlcmFjdGlvbi50YXBUaW1lID0gMDsgLy8gdGltZSBvZiB0aGUgbW9zdCByZWNlbnQgdGFwIGV2ZW50XHJcbiAgaW50ZXJhY3Rpb24uaG9sZFRpbWVycyA9IFtdOyAvLyBbeyBkdXJhdGlvbiwgdGltZW91dCB9XVxyXG59KTtcclxuXHJcbmRlZmF1bHRzLnBvaW50ZXJFdmVudHMgPSBwb2ludGVyRXZlbnRzLmRlZmF1bHRzO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBvaW50ZXJFdmVudHM7XHJcblxyXG59LHtcIi4uL0ludGVyYWN0aW9uXCI6NSxcIi4uL2RlZmF1bHRPcHRpb25zXCI6MTgsXCIuLi91dGlsc1wiOjQ0LFwiLi4vdXRpbHMvU2lnbmFsc1wiOjM1LFwiLi4vdXRpbHMvYXJyXCI6MzYsXCIuLi91dGlscy9icm93c2VyXCI6MzcsXCIuL1BvaW50ZXJFdmVudFwiOjMwfV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcG9pbnRlckV2ZW50cyA9IHJlcXVpcmUoJy4vYmFzZScpO1xyXG52YXIgSW50ZXJhY3Rpb24gPSByZXF1aXJlKCcuLi9JbnRlcmFjdGlvbicpO1xyXG5cclxucG9pbnRlckV2ZW50cy5zaWduYWxzLm9uKCduZXcnLCBvbk5ldyk7XHJcbnBvaW50ZXJFdmVudHMuc2lnbmFscy5vbignZmlyZWQnLCBvbkZpcmVkKTtcclxuXHJcbnZhciBfYXJyID0gWydtb3ZlJywgJ3VwJywgJ2NhbmNlbCcsICdlbmRhbGwnXTtcclxuZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgdmFyIHNpZ25hbCA9IF9hcnJbX2ldO1xyXG4gIEludGVyYWN0aW9uLnNpZ25hbHMub24oc2lnbmFsLCBlbmRIb2xkUmVwZWF0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25OZXcoX3JlZikge1xyXG4gIHZhciBwb2ludGVyRXZlbnQgPSBfcmVmLnBvaW50ZXJFdmVudDtcclxuXHJcbiAgaWYgKHBvaW50ZXJFdmVudC50eXBlICE9PSAnaG9sZCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHBvaW50ZXJFdmVudC5jb3VudCA9IChwb2ludGVyRXZlbnQuY291bnQgfHwgMCkgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkZpcmVkKF9yZWYyKSB7XHJcbiAgdmFyIGludGVyYWN0aW9uID0gX3JlZjIuaW50ZXJhY3Rpb24sXHJcbiAgICAgIHBvaW50ZXJFdmVudCA9IF9yZWYyLnBvaW50ZXJFdmVudCxcclxuICAgICAgZXZlbnRUYXJnZXQgPSBfcmVmMi5ldmVudFRhcmdldCxcclxuICAgICAgdGFyZ2V0cyA9IF9yZWYyLnRhcmdldHM7XHJcblxyXG4gIGlmIChwb2ludGVyRXZlbnQudHlwZSAhPT0gJ2hvbGQnIHx8ICF0YXJnZXRzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgZnJvbSB0aGUgZmlyc3QgZXZlbnRhYmxlXHJcbiAgdmFyIGludGVydmFsID0gdGFyZ2V0c1swXS5ldmVudGFibGUub3B0aW9ucy5ob2xkUmVwZWF0SW50ZXJ2YWw7XHJcblxyXG4gIC8vIGRvbid0IHJlcGVhdCBpZiB0aGUgaW50ZXJ2YWwgaXMgMCBvciBsZXNzXHJcbiAgaWYgKGludGVydmFsIDw9IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIHNldCBhIHRpbWVvdXQgdG8gZmlyZSB0aGUgaG9sZHJlcGVhdCBldmVudFxyXG4gIGludGVyYWN0aW9uLmhvbGRJbnRlcnZhbEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgcG9pbnRlckV2ZW50cy5maXJlKHtcclxuICAgICAgaW50ZXJhY3Rpb246IGludGVyYWN0aW9uLFxyXG4gICAgICBldmVudFRhcmdldDogZXZlbnRUYXJnZXQsXHJcbiAgICAgIHR5cGU6ICdob2xkJyxcclxuICAgICAgcG9pbnRlcjogcG9pbnRlckV2ZW50LFxyXG4gICAgICBldmVudDogcG9pbnRlckV2ZW50XHJcbiAgICB9KTtcclxuICB9LCBpbnRlcnZhbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZEhvbGRSZXBlYXQoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3Rpb24gPSBfcmVmMy5pbnRlcmFjdGlvbjtcclxuXHJcbiAgLy8gc2V0IHRoZSBpbnRlcmFjdGlvbidzIGhvbGRTdG9wVGltZSBwcm9wZXJ0eVxyXG4gIC8vIHRvIHN0b3AgZnVydGhlciBob2xkUmVwZWF0IGV2ZW50c1xyXG4gIGlmIChpbnRlcmFjdGlvbi5ob2xkSW50ZXJ2YWxIYW5kbGUpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJhY3Rpb24uaG9sZEludGVydmFsSGFuZGxlKTtcclxuICAgIGludGVyYWN0aW9uLmhvbGRJbnRlcnZhbEhhbmRsZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBkb24ndCByZXBlYXQgYnkgZGVmYXVsdFxyXG5wb2ludGVyRXZlbnRzLmRlZmF1bHRzLmhvbGRSZXBlYXRJbnRlcnZhbCA9IDA7XHJcbnBvaW50ZXJFdmVudHMudHlwZXMucHVzaCgnaG9sZHJlcGVhdCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgb25OZXc6IG9uTmV3LFxyXG4gIG9uRmlyZWQ6IG9uRmlyZWQsXHJcbiAgZW5kSG9sZFJlcGVhdDogZW5kSG9sZFJlcGVhdFxyXG59O1xyXG5cclxufSx7XCIuLi9JbnRlcmFjdGlvblwiOjUsXCIuL2Jhc2VcIjozMX1dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHBvaW50ZXJFdmVudHMgPSByZXF1aXJlKCcuL2Jhc2UnKTtcclxudmFyIEludGVyYWN0YWJsZSA9IHJlcXVpcmUoJy4uL0ludGVyYWN0YWJsZScpO1xyXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKTtcclxudmFyIGlzID0gcmVxdWlyZSgnLi4vdXRpbHMvaXMnKTtcclxudmFyIGRvbVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZG9tVXRpbHMnKTtcclxudmFyIHNjb3BlID0gcmVxdWlyZSgnLi4vc2NvcGUnKTtcclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWxzL2V4dGVuZCcpO1xyXG5cclxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi4vdXRpbHMvYXJyJyksXHJcbiAgICBtZXJnZSA9IF9yZXF1aXJlLm1lcmdlO1xyXG5cclxucG9pbnRlckV2ZW50cy5zaWduYWxzLm9uKCdjb2xsZWN0LXRhcmdldHMnLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gIHZhciB0YXJnZXRzID0gX3JlZi50YXJnZXRzLFxyXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxyXG4gICAgICB0eXBlID0gX3JlZi50eXBlLFxyXG4gICAgICBldmVudFRhcmdldCA9IF9yZWYuZXZlbnRUYXJnZXQ7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbGxlY3RTZWxlY3RvcnMoaW50ZXJhY3RhYmxlLCBzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgdmFyIGVscyA9IGJyb3dzZXIudXNlTWF0Y2hlc1NlbGVjdG9yUG9seWZpbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHZhciBldmVudGFibGUgPSBpbnRlcmFjdGFibGUuZXZlbnRzO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBldmVudGFibGUub3B0aW9ucztcclxuXHJcbiAgICBpZiAoZXZlbnRhYmxlW3R5cGVdICYmIGlzLmVsZW1lbnQoZWxlbWVudCkgJiYgZG9tVXRpbHMubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yLCBlbHMpICYmIGludGVyYWN0YWJsZS50ZXN0SWdub3JlQWxsb3cob3B0aW9ucywgZWxlbWVudCwgZXZlbnRUYXJnZXQpKSB7XHJcblxyXG4gICAgICB0YXJnZXRzLnB1c2goe1xyXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgZXZlbnRhYmxlOiBldmVudGFibGUsXHJcbiAgICAgICAgcHJvcHM6IHsgaW50ZXJhY3RhYmxlOiBpbnRlcmFjdGFibGUgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBpbnRlcmFjdGFibGUgPSBzY29wZS5pbnRlcmFjdGFibGVzLmdldChlbGVtZW50KTtcclxuXHJcbiAgaWYgKGludGVyYWN0YWJsZSkge1xyXG4gICAgdmFyIGV2ZW50YWJsZSA9IGludGVyYWN0YWJsZS5ldmVudHM7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGV2ZW50YWJsZS5vcHRpb25zO1xyXG5cclxuICAgIGlmIChldmVudGFibGVbdHlwZV0gJiYgaW50ZXJhY3RhYmxlLnRlc3RJZ25vcmVBbGxvdyhvcHRpb25zLCBlbGVtZW50LCBldmVudFRhcmdldCkpIHtcclxuICAgICAgdGFyZ2V0cy5wdXNoKHtcclxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgIGV2ZW50YWJsZTogZXZlbnRhYmxlLFxyXG4gICAgICAgIHByb3BzOiB7IGludGVyYWN0YWJsZTogaW50ZXJhY3RhYmxlIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzY29wZS5pbnRlcmFjdGFibGVzLmZvckVhY2hTZWxlY3Rvcihjb2xsZWN0U2VsZWN0b3JzLCBlbGVtZW50KTtcclxufSk7XHJcblxyXG5JbnRlcmFjdGFibGUuc2lnbmFscy5vbignbmV3JywgZnVuY3Rpb24gKF9yZWYyKSB7XHJcbiAgdmFyIGludGVyYWN0YWJsZSA9IF9yZWYyLmludGVyYWN0YWJsZTtcclxuXHJcbiAgaW50ZXJhY3RhYmxlLmV2ZW50cy5nZXRSZWN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBpbnRlcmFjdGFibGUuZ2V0UmVjdChlbGVtZW50KTtcclxuICB9O1xyXG59KTtcclxuXHJcbkludGVyYWN0YWJsZS5zaWduYWxzLm9uKCdzZXQnLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICB2YXIgaW50ZXJhY3RhYmxlID0gX3JlZjMuaW50ZXJhY3RhYmxlLFxyXG4gICAgICBvcHRpb25zID0gX3JlZjMub3B0aW9ucztcclxuXHJcbiAgZXh0ZW5kKGludGVyYWN0YWJsZS5ldmVudHMub3B0aW9ucywgcG9pbnRlckV2ZW50cy5kZWZhdWx0cyk7XHJcbiAgZXh0ZW5kKGludGVyYWN0YWJsZS5ldmVudHMub3B0aW9ucywgb3B0aW9ucyk7XHJcbn0pO1xyXG5cclxubWVyZ2UoSW50ZXJhY3RhYmxlLmV2ZW50VHlwZXMsIHBvaW50ZXJFdmVudHMudHlwZXMpO1xyXG5cclxuSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5wb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBleHRlbmQodGhpcy5ldmVudHMub3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxudmFyIF9fYmFja0NvbXBhdE9wdGlvbiA9IEludGVyYWN0YWJsZS5wcm90b3R5cGUuX2JhY2tDb21wYXRPcHRpb247XHJcblxyXG5JbnRlcmFjdGFibGUucHJvdG90eXBlLl9iYWNrQ29tcGF0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbk5hbWUsIG5ld1ZhbHVlKSB7XHJcbiAgdmFyIHJldCA9IF9fYmFja0NvbXBhdE9wdGlvbi5jYWxsKHRoaXMsIG9wdGlvbk5hbWUsIG5ld1ZhbHVlKTtcclxuXHJcbiAgaWYgKHJldCA9PT0gdGhpcykge1xyXG4gICAgdGhpcy5ldmVudHMub3B0aW9uc1tvcHRpb25OYW1lXSA9IG5ld1ZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbkludGVyYWN0YWJsZS5zZXR0aW5nc01ldGhvZHMucHVzaCgncG9pbnRlckV2ZW50cycpO1xyXG5cclxufSx7XCIuLi9JbnRlcmFjdGFibGVcIjo0LFwiLi4vc2NvcGVcIjozNCxcIi4uL3V0aWxzL2FyclwiOjM2LFwiLi4vdXRpbHMvYnJvd3NlclwiOjM3LFwiLi4vdXRpbHMvZG9tVXRpbHNcIjozOSxcIi4uL3V0aWxzL2V4dGVuZFwiOjQxLFwiLi4vdXRpbHMvaXNcIjo0NixcIi4vYmFzZVwiOjMxfV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBldmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50cycpO1xyXG52YXIgc2lnbmFscyA9IHJlcXVpcmUoJy4vdXRpbHMvU2lnbmFscycpLm5ldygpO1xyXG5cclxudmFyIHNjb3BlID0ge1xyXG4gIHNpZ25hbHM6IHNpZ25hbHMsXHJcbiAgZXZlbnRzOiBldmVudHMsXHJcbiAgdXRpbHM6IHV0aWxzLFxyXG5cclxuICAvLyBtYWluIGRvY3VtZW50XHJcbiAgZG9jdW1lbnQ6IHJlcXVpcmUoJy4vdXRpbHMvZG9tT2JqZWN0cycpLmRvY3VtZW50LFxyXG4gIC8vIGFsbCBkb2N1bWVudHMgYmVpbmcgbGlzdGVuZWQgdG9cclxuICBkb2N1bWVudHM6IFtdLFxyXG5cclxuICBhZGREb2N1bWVudDogZnVuY3Rpb24gYWRkRG9jdW1lbnQoZG9jLCB3aW4pIHtcclxuICAgIC8vIGRvIG5vdGhpbmcgaWYgZG9jdW1lbnQgaXMgYWxyZWFkeSBrbm93blxyXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHNjb3BlLmRvY3VtZW50cywgZG9jKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgd2luID0gd2luIHx8IHNjb3BlLmdldFdpbmRvdyhkb2MpO1xyXG5cclxuICAgIHNjb3BlLmRvY3VtZW50cy5wdXNoKGRvYyk7XHJcbiAgICBldmVudHMuZG9jdW1lbnRzLnB1c2goZG9jKTtcclxuXHJcbiAgICAvLyBkb24ndCBhZGQgYW4gdW5sb2FkIGV2ZW50IGZvciB0aGUgbWFpbiBkb2N1bWVudFxyXG4gICAgLy8gc28gdGhhdCB0aGUgcGFnZSBtYXkgYmUgY2FjaGVkIGluIGJyb3dzZXIgaGlzdG9yeVxyXG4gICAgaWYgKGRvYyAhPT0gc2NvcGUuZG9jdW1lbnQpIHtcclxuICAgICAgZXZlbnRzLmFkZCh3aW4sICd1bmxvYWQnLCBzY29wZS5vbldpbmRvd1VubG9hZCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2lnbmFscy5maXJlKCdhZGQtZG9jdW1lbnQnLCB7IGRvYzogZG9jLCB3aW46IHdpbiB9KTtcclxuICB9LFxyXG5cclxuICByZW1vdmVEb2N1bWVudDogZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnQoZG9jLCB3aW4pIHtcclxuICAgIHZhciBpbmRleCA9IHV0aWxzLmluZGV4T2Yoc2NvcGUuZG9jdW1lbnRzLCBkb2MpO1xyXG5cclxuICAgIHdpbiA9IHdpbiB8fCBzY29wZS5nZXRXaW5kb3coZG9jKTtcclxuXHJcbiAgICBldmVudHMucmVtb3ZlKHdpbiwgJ3VubG9hZCcsIHNjb3BlLm9uV2luZG93VW5sb2FkKTtcclxuXHJcbiAgICBzY29wZS5kb2N1bWVudHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIGV2ZW50cy5kb2N1bWVudHMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICBzaWduYWxzLmZpcmUoJ3JlbW92ZS1kb2N1bWVudCcsIHsgd2luOiB3aW4sIGRvYzogZG9jIH0pO1xyXG4gIH0sXHJcblxyXG4gIG9uV2luZG93VW5sb2FkOiBmdW5jdGlvbiBvbldpbmRvd1VubG9hZCgpIHtcclxuICAgIHNjb3BlLnJlbW92ZURvY3VtZW50KHRoaXMuZG9jdW1lbnQsIHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2NvcGU7XHJcblxyXG59LHtcIi4vdXRpbHNcIjo0NCxcIi4vdXRpbHMvU2lnbmFsc1wiOjM1LFwiLi91dGlscy9kb21PYmplY3RzXCI6MzgsXCIuL3V0aWxzL2V2ZW50c1wiOjQwfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9hcnInKSxcclxuICAgIGluZGV4T2YgPSBfcmVxdWlyZS5pbmRleE9mO1xyXG5cclxudmFyIFNpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gU2lnbmFscygpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWduYWxzKTtcclxuXHJcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcclxuICAgICAgLy8gc2lnbmFsTmFtZTogW2xpc3RlbmVyc10sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgU2lnbmFscy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihuYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tuYW1lXSkge1xyXG4gICAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXSA9IFtsaXN0ZW5lcl07XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcclxuICB9O1xyXG5cclxuICBTaWduYWxzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYobmFtZSwgbGlzdGVuZXIpIHtcclxuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbbmFtZV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5saXN0ZW5lcnNbbmFtZV0sIGxpc3RlbmVyKTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHRoaXMubGlzdGVuZXJzW25hbWVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgU2lnbmFscy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uIGZpcmUobmFtZSwgYXJnKSB7XHJcbiAgICB2YXIgdGFyZ2V0TGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbbmFtZV07XHJcblxyXG4gICAgaWYgKCF0YXJnZXRMaXN0ZW5lcnMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0YXJnZXRMaXN0ZW5lcnNbaV0oYXJnLCBuYW1lKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gU2lnbmFscztcclxufSgpO1xyXG5cclxuU2lnbmFscy5uZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG5ldyBTaWduYWxzKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbHM7XHJcblxyXG59LHtcIi4vYXJyXCI6MzZ9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdGFyZ2V0KSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAoYXJyYXlbaV0gPT09IHRhcmdldCkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIHRhcmdldCkge1xyXG4gIHJldHVybiBpbmRleE9mKGFycmF5LCB0YXJnZXQpICE9PSAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgdGFyZ2V0LnB1c2goc291cmNlW2ldKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcihhcnJheSwgdGVzdCkge1xyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRlc3QoYXJyYXlbaV0pKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGluZGV4T2Y6IGluZGV4T2YsXHJcbiAgY29udGFpbnM6IGNvbnRhaW5zLFxyXG4gIG1lcmdlOiBtZXJnZSxcclxuICBmaWx0ZXI6IGZpbHRlclxyXG59O1xyXG5cclxufSx7fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3dpbmRvdycpLFxyXG4gICAgd2luZG93ID0gX3JlcXVpcmUud2luZG93O1xyXG5cclxudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xyXG52YXIgZG9tT2JqZWN0cyA9IHJlcXVpcmUoJy4vZG9tT2JqZWN0cycpO1xyXG5cclxudmFyIEVsZW1lbnQgPSBkb21PYmplY3RzLkVsZW1lbnQ7XHJcbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xyXG5cclxudmFyIGJyb3dzZXIgPSB7XHJcbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRvdWNoIGlucHV0P1xyXG4gIHN1cHBvcnRzVG91Y2g6ICEhKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBpcy5mdW5jdGlvbih3aW5kb3cuRG9jdW1lbnRUb3VjaCkgJiYgZG9tT2JqZWN0cy5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcclxuXHJcbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IFBvaW50ZXJFdmVudHNcclxuICBzdXBwb3J0c1BvaW50ZXJFdmVudDogISFkb21PYmplY3RzLlBvaW50ZXJFdmVudCxcclxuXHJcbiAgaXNJRTg6ICdhdHRhY2hFdmVudCcgaW4gd2luZG93ICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyksXHJcblxyXG4gIC8vIE9wZXJhIE1vYmlsZSBtdXN0IGJlIGhhbmRsZWQgZGlmZmVyZW50bHlcclxuICBpc09wZXJhTW9iaWxlOiBuYXZpZ2F0b3IuYXBwTmFtZSA9PT0gJ09wZXJhJyAmJiBicm93c2VyLnN1cHBvcnRzVG91Y2ggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnUHJlc3RvJyksXHJcblxyXG4gIC8vIHNjcm9sbGluZyBkb2Vzbid0IGNoYW5nZSB0aGUgcmVzdWx0IG9mIGdldENsaWVudFJlY3RzIG9uIGlPUyA3XHJcbiAgaXNJT1M3OiAvaVAoaG9uZXxvZHxhZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSAmJiAvT1MgN1teXFxkXS8udGVzdChuYXZpZ2F0b3IuYXBwVmVyc2lvbiksXHJcblxyXG4gIGlzSWU5T3JPbGRlcjogL01TSUUgKDh8OSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXHJcblxyXG4gIC8vIHByZWZpeCBtYXRjaGVzU2VsZWN0b3JcclxuICBwcmVmaXhlZE1hdGNoZXNTZWxlY3RvcjogJ21hdGNoZXMnIGluIEVsZW1lbnQucHJvdG90eXBlID8gJ21hdGNoZXMnIDogJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGUgPyAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJyA6ICdtb3pNYXRjaGVzU2VsZWN0b3InIGluIEVsZW1lbnQucHJvdG90eXBlID8gJ21vek1hdGNoZXNTZWxlY3RvcicgOiAnb01hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGUgPyAnb01hdGNoZXNTZWxlY3RvcicgOiAnbXNNYXRjaGVzU2VsZWN0b3InLFxyXG5cclxuICB1c2VNYXRjaGVzU2VsZWN0b3JQb2x5ZmlsbDogZmFsc2UsXHJcblxyXG4gIHBFdmVudFR5cGVzOiBkb21PYmplY3RzLlBvaW50ZXJFdmVudCA/IGRvbU9iamVjdHMuUG9pbnRlckV2ZW50ID09PSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgPyB7XHJcbiAgICB1cDogJ01TUG9pbnRlclVwJyxcclxuICAgIGRvd246ICdNU1BvaW50ZXJEb3duJyxcclxuICAgIG92ZXI6ICdtb3VzZW92ZXInLFxyXG4gICAgb3V0OiAnbW91c2VvdXQnLFxyXG4gICAgbW92ZTogJ01TUG9pbnRlck1vdmUnLFxyXG4gICAgY2FuY2VsOiAnTVNQb2ludGVyQ2FuY2VsJ1xyXG4gIH0gOiB7XHJcbiAgICB1cDogJ3BvaW50ZXJ1cCcsXHJcbiAgICBkb3duOiAncG9pbnRlcmRvd24nLFxyXG4gICAgb3ZlcjogJ3BvaW50ZXJvdmVyJyxcclxuICAgIG91dDogJ3BvaW50ZXJvdXQnLFxyXG4gICAgbW92ZTogJ3BvaW50ZXJtb3ZlJyxcclxuICAgIGNhbmNlbDogJ3BvaW50ZXJjYW5jZWwnXHJcbiAgfSA6IG51bGwsXHJcblxyXG4gIC8vIGJlY2F1c2UgV2Via2l0IGFuZCBPcGVyYSBzdGlsbCB1c2UgJ21vdXNld2hlZWwnIGV2ZW50IHR5cGVcclxuICB3aGVlbEV2ZW50OiAnb25tb3VzZXdoZWVsJyBpbiBkb21PYmplY3RzLmRvY3VtZW50ID8gJ21vdXNld2hlZWwnIDogJ3doZWVsJ1xyXG5cclxufTtcclxuXHJcbmJyb3dzZXIudXNlTWF0Y2hlc1NlbGVjdG9yUG9seWZpbGwgPSAhaXMuZnVuY3Rpb24oRWxlbWVudC5wcm90b3R5cGVbYnJvd3Nlci5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcl0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBicm93c2VyO1xyXG5cclxufSx7XCIuL2RvbU9iamVjdHNcIjozOCxcIi4vaXNcIjo0NixcIi4vd2luZG93XCI6NTJ9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkb21PYmplY3RzID0ge307XHJcbnZhciB3aW4gPSByZXF1aXJlKCcuL3dpbmRvdycpLndpbmRvdztcclxuXHJcbmZ1bmN0aW9uIGJsYW5rKCkge31cclxuXHJcbmRvbU9iamVjdHMuZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XHJcbmRvbU9iamVjdHMuRG9jdW1lbnRGcmFnbWVudCA9IHdpbi5Eb2N1bWVudEZyYWdtZW50IHx8IGJsYW5rO1xyXG5kb21PYmplY3RzLlNWR0VsZW1lbnQgPSB3aW4uU1ZHRWxlbWVudCB8fCBibGFuaztcclxuZG9tT2JqZWN0cy5TVkdTVkdFbGVtZW50ID0gd2luLlNWR1NWR0VsZW1lbnQgfHwgYmxhbms7XHJcbmRvbU9iamVjdHMuU1ZHRWxlbWVudEluc3RhbmNlID0gd2luLlNWR0VsZW1lbnRJbnN0YW5jZSB8fCBibGFuaztcclxuZG9tT2JqZWN0cy5FbGVtZW50ID0gd2luLkVsZW1lbnQgfHwgYmxhbms7XHJcbmRvbU9iamVjdHMuSFRNTEVsZW1lbnQgPSB3aW4uSFRNTEVsZW1lbnQgfHwgZG9tT2JqZWN0cy5FbGVtZW50O1xyXG5cclxuZG9tT2JqZWN0cy5FdmVudCA9IHdpbi5FdmVudDtcclxuZG9tT2JqZWN0cy5Ub3VjaCA9IHdpbi5Ub3VjaCB8fCBibGFuaztcclxuZG9tT2JqZWN0cy5Qb2ludGVyRXZlbnQgPSB3aW4uUG9pbnRlckV2ZW50IHx8IHdpbi5NU1BvaW50ZXJFdmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZG9tT2JqZWN0cztcclxuXHJcbn0se1wiLi93aW5kb3dcIjo1Mn1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHdpbiA9IHJlcXVpcmUoJy4vd2luZG93Jyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJyk7XHJcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcclxudmFyIGRvbU9iamVjdHMgPSByZXF1aXJlKCcuL2RvbU9iamVjdHMnKTtcclxuXHJcbnZhciBkb21VdGlscyA9IHtcclxuICBub2RlQ29udGFpbnM6IGZ1bmN0aW9uIG5vZGVDb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XHJcbiAgICB3aGlsZSAoY2hpbGQpIHtcclxuICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICB3aGlsZSAoaXMuZWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgICBpZiAoZG9tVXRpbHMubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50ID0gZG9tVXRpbHMucGFyZW50Tm9kZShlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9LFxyXG5cclxuICBwYXJlbnROb2RlOiBmdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XHJcblxyXG4gICAgaWYgKGlzLmRvY0ZyYWcocGFyZW50KSkge1xyXG4gICAgICAvLyBza2lwIHBhc3QgI3NoYWRvLXJvb3QgZnJhZ21lbnRzXHJcbiAgICAgIHdoaWxlICgocGFyZW50ID0gcGFyZW50Lmhvc3QpICYmIGlzLmRvY0ZyYWcocGFyZW50KSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgfSxcclxuXHJcbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vdGFuYWxpbi5jb20vZW4vYmxvZy8yMDEyLzEyL21hdGNoZXMtc2VsZWN0b3ItaWU4LyBhbmQgbW9kaWZpZWRcclxuICBtYXRjaGVzU2VsZWN0b3JQb2x5ZmlsbDogYnJvd3Nlci51c2VNYXRjaGVzU2VsZWN0b3JQb2x5ZmlsbCA/IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgZWxlbXMpIHtcclxuICAgIGVsZW1zID0gZWxlbXMgfHwgZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoZWxlbXNbaV0gPT09IGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9IDogbnVsbCxcclxuXHJcbiAgbWF0Y2hlc1NlbGVjdG9yOiBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IsIG5vZGVMaXN0KSB7XHJcbiAgICBpZiAoYnJvd3Nlci51c2VNYXRjaGVzU2VsZWN0b3JQb2x5ZmlsbCkge1xyXG4gICAgICByZXR1cm4gZG9tVXRpbHMubWF0Y2hlc1NlbGVjdG9yUG9seWZpbGwoZWxlbWVudCwgc2VsZWN0b3IsIG5vZGVMaXN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZW1vdmUgL2RlZXAvIGZyb20gc2VsZWN0b3JzIGlmIHNoYWRvd0RPTSBwb2x5ZmlsbCBpcyB1c2VkXHJcbiAgICBpZiAod2luLndpbmRvdyAhPT0gd2luLnJlYWxXaW5kb3cpIHtcclxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9cXC9kZWVwXFwvL2csICcgJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRbYnJvd3Nlci5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcl0oc2VsZWN0b3IpO1xyXG4gIH0sXHJcblxyXG4gIC8vIFRlc3QgZm9yIHRoZSBlbGVtZW50IHRoYXQncyBcImFib3ZlXCIgYWxsIG90aGVyIHF1YWxpZmllcnNcclxuICBpbmRleE9mRGVlcGVzdEVsZW1lbnQ6IGZ1bmN0aW9uIGluZGV4T2ZEZWVwZXN0RWxlbWVudChlbGVtZW50cykge1xyXG4gICAgdmFyIGRlZXBlc3Rab25lUGFyZW50cyA9IFtdO1xyXG4gICAgdmFyIGRyb3B6b25lUGFyZW50cyA9IFtdO1xyXG4gICAgdmFyIGRyb3B6b25lID0gdm9pZCAwO1xyXG4gICAgdmFyIGRlZXBlc3Rab25lID0gZWxlbWVudHNbMF07XHJcbiAgICB2YXIgaW5kZXggPSBkZWVwZXN0Wm9uZSA/IDAgOiAtMTtcclxuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XHJcbiAgICB2YXIgY2hpbGQgPSB2b2lkIDA7XHJcbiAgICB2YXIgaSA9IHZvaWQgMDtcclxuICAgIHZhciBuID0gdm9pZCAwO1xyXG5cclxuICAgIGZvciAoaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBkcm9wem9uZSA9IGVsZW1lbnRzW2ldO1xyXG5cclxuICAgICAgLy8gYW4gZWxlbWVudCBtaWdodCBiZWxvbmcgdG8gbXVsdGlwbGUgc2VsZWN0b3IgZHJvcHpvbmVzXHJcbiAgICAgIGlmICghZHJvcHpvbmUgfHwgZHJvcHpvbmUgPT09IGRlZXBlc3Rab25lKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZGVlcGVzdFpvbmUpIHtcclxuICAgICAgICBkZWVwZXN0Wm9uZSA9IGRyb3B6b25lO1xyXG4gICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2hlY2sgaWYgdGhlIGRlZXBlc3Qgb3IgY3VycmVudCBhcmUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IG9yIGRvY3VtZW50LnJvb3RFbGVtZW50XHJcbiAgICAgIC8vIC0gaWYgdGhlIGN1cnJlbnQgZHJvcHpvbmUgaXMsIGRvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXHJcbiAgICAgIGlmIChkcm9wem9uZS5wYXJlbnROb2RlID09PSBkcm9wem9uZS5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gLSBpZiBkZWVwZXN0IGlzLCB1cGRhdGUgd2l0aCB0aGUgY3VycmVudCBkcm9wem9uZSBhbmQgY29udGludWUgdG8gbmV4dFxyXG4gICAgICBlbHNlIGlmIChkZWVwZXN0Wm9uZS5wYXJlbnROb2RlID09PSBkcm9wem9uZS5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgICBkZWVwZXN0Wm9uZSA9IGRyb3B6b25lO1xyXG4gICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkZWVwZXN0Wm9uZVBhcmVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcGFyZW50ID0gZGVlcGVzdFpvbmU7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQub3duZXJEb2N1bWVudCkge1xyXG4gICAgICAgICAgZGVlcGVzdFpvbmVQYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcclxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIGFuIHN2ZyBlbGVtZW50IGFuZCB0aGUgY3VycmVudCBkZWVwZXN0IGlzXHJcbiAgICAgIC8vIGFuIEhUTUxFbGVtZW50XHJcbiAgICAgIGlmIChkZWVwZXN0Wm9uZSBpbnN0YW5jZW9mIGRvbU9iamVjdHMuSFRNTEVsZW1lbnQgJiYgZHJvcHpvbmUgaW5zdGFuY2VvZiBkb21PYmplY3RzLlNWR0VsZW1lbnQgJiYgIShkcm9wem9uZSBpbnN0YW5jZW9mIGRvbU9iamVjdHMuU1ZHU1ZHRWxlbWVudCkpIHtcclxuXHJcbiAgICAgICAgaWYgKGRyb3B6b25lID09PSBkZWVwZXN0Wm9uZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmVudCA9IGRyb3B6b25lLm93bmVyU1ZHRWxlbWVudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJlbnQgPSBkcm9wem9uZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZHJvcHpvbmVQYXJlbnRzID0gW107XHJcblxyXG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudE5vZGUgIT09IHBhcmVudC5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgZHJvcHpvbmVQYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAvLyBnZXQgKHBvc2l0aW9uIG9mIGxhc3QgY29tbW9uIGFuY2VzdG9yKSArIDFcclxuICAgICAgd2hpbGUgKGRyb3B6b25lUGFyZW50c1tuXSAmJiBkcm9wem9uZVBhcmVudHNbbl0gPT09IGRlZXBlc3Rab25lUGFyZW50c1tuXSkge1xyXG4gICAgICAgIG4rKztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBhcmVudHMgPSBbZHJvcHpvbmVQYXJlbnRzW24gLSAxXSwgZHJvcHpvbmVQYXJlbnRzW25dLCBkZWVwZXN0Wm9uZVBhcmVudHNbbl1dO1xyXG5cclxuICAgICAgY2hpbGQgPSBwYXJlbnRzWzBdLmxhc3RDaGlsZDtcclxuXHJcbiAgICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50c1sxXSkge1xyXG4gICAgICAgICAgZGVlcGVzdFpvbmUgPSBkcm9wem9uZTtcclxuICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgIGRlZXBlc3Rab25lUGFyZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgPT09IHBhcmVudHNbMl0pIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbiAgfSxcclxuXHJcbiAgbWF0Y2hlc1VwVG86IGZ1bmN0aW9uIG1hdGNoZXNVcFRvKGVsZW1lbnQsIHNlbGVjdG9yLCBsaW1pdCkge1xyXG4gICAgd2hpbGUgKGlzLmVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgaWYgKGRvbVV0aWxzLm1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvcikpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbWVudCA9IGRvbVV0aWxzLnBhcmVudE5vZGUoZWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudCA9PT0gbGltaXQpIHtcclxuICAgICAgICByZXR1cm4gZG9tVXRpbHMubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICBnZXRBY3R1YWxFbGVtZW50OiBmdW5jdGlvbiBnZXRBY3R1YWxFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgZG9tT2JqZWN0cy5TVkdFbGVtZW50SW5zdGFuY2UgPyBlbGVtZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IDogZWxlbWVudDtcclxuICB9LFxyXG5cclxuICBnZXRTY3JvbGxYWTogZnVuY3Rpb24gZ2V0U2Nyb2xsWFkocmVsZXZhbnRXaW5kb3cpIHtcclxuICAgIHJlbGV2YW50V2luZG93ID0gcmVsZXZhbnRXaW5kb3cgfHwgd2luLndpbmRvdztcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHJlbGV2YW50V2luZG93LnNjcm9sbFggfHwgcmVsZXZhbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXHJcbiAgICAgIHk6IHJlbGV2YW50V2luZG93LnNjcm9sbFkgfHwgcmVsZXZhbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBnZXRFbGVtZW50Q2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0RWxlbWVudENsaWVudFJlY3QoZWxlbWVudCkge1xyXG4gICAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50IGluc3RhbmNlb2YgZG9tT2JqZWN0cy5TVkdFbGVtZW50ID8gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcclxuXHJcbiAgICByZXR1cm4gY2xpZW50UmVjdCAmJiB7XHJcbiAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCxcclxuICAgICAgcmlnaHQ6IGNsaWVudFJlY3QucmlnaHQsXHJcbiAgICAgIHRvcDogY2xpZW50UmVjdC50b3AsXHJcbiAgICAgIGJvdHRvbTogY2xpZW50UmVjdC5ib3R0b20sXHJcbiAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoIHx8IGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQsXHJcbiAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQgfHwgY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBnZXRFbGVtZW50UmVjdDogZnVuY3Rpb24gZ2V0RWxlbWVudFJlY3QoZWxlbWVudCkge1xyXG4gICAgdmFyIGNsaWVudFJlY3QgPSBkb21VdGlscy5nZXRFbGVtZW50Q2xpZW50UmVjdChlbGVtZW50KTtcclxuXHJcbiAgICBpZiAoIWJyb3dzZXIuaXNJT1M3ICYmIGNsaWVudFJlY3QpIHtcclxuICAgICAgdmFyIHNjcm9sbCA9IGRvbVV0aWxzLmdldFNjcm9sbFhZKHdpbi5nZXRXaW5kb3coZWxlbWVudCkpO1xyXG5cclxuICAgICAgY2xpZW50UmVjdC5sZWZ0ICs9IHNjcm9sbC54O1xyXG4gICAgICBjbGllbnRSZWN0LnJpZ2h0ICs9IHNjcm9sbC54O1xyXG4gICAgICBjbGllbnRSZWN0LnRvcCArPSBzY3JvbGwueTtcclxuICAgICAgY2xpZW50UmVjdC5ib3R0b20gKz0gc2Nyb2xsLnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsaWVudFJlY3Q7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UGF0aDogZnVuY3Rpb24gZ2V0UGF0aChlbGVtZW50KSB7XHJcbiAgICB2YXIgcGF0aCA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChlbGVtZW50KSB7XHJcbiAgICAgIHBhdGgucHVzaChlbGVtZW50KTtcclxuICAgICAgZWxlbWVudCA9IGRvbVV0aWxzLnBhcmVudE5vZGUoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfSxcclxuXHJcbiAgdHJ5U2VsZWN0b3I6IGZ1bmN0aW9uIHRyeVNlbGVjdG9yKHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzLnN0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCBpZiBpdCBpcyBpbnZhbGlkXHJcbiAgICBkb21PYmplY3RzLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkb21VdGlscztcclxuXHJcbn0se1wiLi9icm93c2VyXCI6MzcsXCIuL2RvbU9iamVjdHNcIjozOCxcIi4vaXNcIjo0NixcIi4vd2luZG93XCI6NTJ9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcclxudmFyIGRvbVV0aWxzID0gcmVxdWlyZSgnLi9kb21VdGlscycpO1xyXG52YXIgcEV4dGVuZCA9IHJlcXVpcmUoJy4vcG9pbnRlckV4dGVuZCcpO1xyXG5cclxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi93aW5kb3cnKSxcclxuICAgIHdpbmRvdyA9IF9yZXF1aXJlLndpbmRvdyxcclxuICAgIGdldFdpbmRvdyA9IF9yZXF1aXJlLmdldFdpbmRvdztcclxuXHJcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuL2FycicpLFxyXG4gICAgaW5kZXhPZiA9IF9yZXF1aXJlMi5pbmRleE9mLFxyXG4gICAgY29udGFpbnMgPSBfcmVxdWlyZTIuY29udGFpbnM7XHJcblxyXG52YXIgdXNlQXR0YWNoRXZlbnQgPSAnYXR0YWNoRXZlbnQnIGluIHdpbmRvdyAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW5kb3cpO1xyXG52YXIgYWRkRXZlbnQgPSB1c2VBdHRhY2hFdmVudCA/ICdhdHRhY2hFdmVudCcgOiAnYWRkRXZlbnRMaXN0ZW5lcic7XHJcbnZhciByZW1vdmVFdmVudCA9IHVzZUF0dGFjaEV2ZW50ID8gJ2RldGFjaEV2ZW50JyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcclxudmFyIG9uID0gdXNlQXR0YWNoRXZlbnQgPyAnb24nIDogJyc7XHJcblxyXG52YXIgZWxlbWVudHMgPSBbXTtcclxudmFyIHRhcmdldHMgPSBbXTtcclxudmFyIGF0dGFjaGVkTGlzdGVuZXJzID0gW107XHJcblxyXG4vLyB7XHJcbi8vICAgdHlwZToge1xyXG4vLyAgICAgc2VsZWN0b3JzOiBbJ3NlbGVjdG9yJywgLi4uXSxcclxuLy8gICAgIGNvbnRleHRzIDogW2RvY3VtZW50LCAuLi5dLFxyXG4vLyAgICAgbGlzdGVuZXJzOiBbW2xpc3RlbmVyLCBjYXB0dXJlLCBwYXNzaXZlXSwgLi4uXVxyXG4vLyAgIH1cclxuLy8gIH1cclxudmFyIGRlbGVnYXRlZEV2ZW50cyA9IHt9O1xyXG5cclxudmFyIGRvY3VtZW50cyA9IFtdO1xyXG5cclxudmFyIHN1cHBvcnRzT3B0aW9ucyA9ICF1c2VBdHRhY2hFdmVudCAmJiBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG5cclxuICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtcclxuICAgIGdldCBjYXB0dXJlKCkge1xyXG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gc3VwcG9ydGVkO1xyXG59KCk7XHJcblxyXG5mdW5jdGlvbiBhZGQoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbmFsQXJnKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbmFsQXJnKTtcclxuICB2YXIgZWxlbWVudEluZGV4ID0gaW5kZXhPZihlbGVtZW50cywgZWxlbWVudCk7XHJcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbZWxlbWVudEluZGV4XTtcclxuXHJcbiAgaWYgKCF0YXJnZXQpIHtcclxuICAgIHRhcmdldCA9IHtcclxuICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgdHlwZUNvdW50OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGVsZW1lbnRJbmRleCA9IGVsZW1lbnRzLnB1c2goZWxlbWVudCkgLSAxO1xyXG4gICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblxyXG4gICAgYXR0YWNoZWRMaXN0ZW5lcnMucHVzaCh1c2VBdHRhY2hFdmVudCA/IHtcclxuICAgICAgc3VwcGxpZWQ6IFtdLFxyXG4gICAgICB3cmFwcGVkOiBbXSxcclxuICAgICAgdXNlQ291bnQ6IFtdXHJcbiAgICB9IDogbnVsbCk7XHJcbiAgfVxyXG5cclxuICBpZiAoIXRhcmdldC5ldmVudHNbdHlwZV0pIHtcclxuICAgIHRhcmdldC5ldmVudHNbdHlwZV0gPSBbXTtcclxuICAgIHRhcmdldC50eXBlQ291bnQrKztcclxuICB9XHJcblxyXG4gIGlmICghY29udGFpbnModGFyZ2V0LmV2ZW50c1t0eXBlXSwgbGlzdGVuZXIpKSB7XHJcbiAgICB2YXIgcmV0ID0gdm9pZCAwO1xyXG5cclxuICAgIGlmICh1c2VBdHRhY2hFdmVudCkge1xyXG4gICAgICB2YXIgX2F0dGFjaGVkTGlzdGVuZXJzJGVsID0gYXR0YWNoZWRMaXN0ZW5lcnNbZWxlbWVudEluZGV4XSxcclxuICAgICAgICAgIHN1cHBsaWVkID0gX2F0dGFjaGVkTGlzdGVuZXJzJGVsLnN1cHBsaWVkLFxyXG4gICAgICAgICAgd3JhcHBlZCA9IF9hdHRhY2hlZExpc3RlbmVycyRlbC53cmFwcGVkLFxyXG4gICAgICAgICAgdXNlQ291bnQgPSBfYXR0YWNoZWRMaXN0ZW5lcnMkZWwudXNlQ291bnQ7XHJcblxyXG4gICAgICB2YXIgbGlzdGVuZXJJbmRleCA9IGluZGV4T2Yoc3VwcGxpZWQsIGxpc3RlbmVyKTtcclxuXHJcbiAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXIgPSB3cmFwcGVkW2xpc3RlbmVySW5kZXhdIHx8IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmICghZXZlbnQuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKSB7XHJcbiAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xyXG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBldmVudC5wcmV2ZW50RGVmYXVsdCB8fCBwcmV2ZW50RGVmO1xyXG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc3RvcFByb3BhZ2F0aW9uIHx8IHN0b3BQcm9wO1xyXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIHx8IHN0b3BJbW1Qcm9wO1xyXG5cclxuICAgICAgICAgIGlmICgvbW91c2V8Y2xpY2svLnRlc3QoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgZ2V0V2luZG93KGVsZW1lbnQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyBnZXRXaW5kb3coZWxlbWVudCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsaXN0ZW5lcihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0ID0gZWxlbWVudFthZGRFdmVudF0ob24gKyB0eXBlLCB3cmFwcGVkTGlzdGVuZXIsICEhb3B0aW9ucy5jYXB0dXJlKTtcclxuXHJcbiAgICAgIGlmIChsaXN0ZW5lckluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHN1cHBsaWVkLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgIHdyYXBwZWQucHVzaCh3cmFwcGVkTGlzdGVuZXIpO1xyXG4gICAgICAgIHVzZUNvdW50LnB1c2goMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdXNlQ291bnRbbGlzdGVuZXJJbmRleF0rKztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0ID0gZWxlbWVudFthZGRFdmVudF0odHlwZSwgbGlzdGVuZXIsIHN1cHBvcnRzT3B0aW9ucyA/IG9wdGlvbnMgOiAhIW9wdGlvbnMuY2FwdHVyZSk7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQuZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbmFsQXJnKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbmFsQXJnKTtcclxuICB2YXIgZWxlbWVudEluZGV4ID0gaW5kZXhPZihlbGVtZW50cywgZWxlbWVudCk7XHJcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbZWxlbWVudEluZGV4XTtcclxuXHJcbiAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5ldmVudHMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciB3cmFwcGVkTGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICB2YXIgbGlzdGVuZXJzID0gdm9pZCAwO1xyXG4gIHZhciBsaXN0ZW5lckluZGV4ID0gdm9pZCAwO1xyXG5cclxuICBpZiAodXNlQXR0YWNoRXZlbnQpIHtcclxuICAgIGxpc3RlbmVycyA9IGF0dGFjaGVkTGlzdGVuZXJzW2VsZW1lbnRJbmRleF07XHJcbiAgICBsaXN0ZW5lckluZGV4ID0gaW5kZXhPZihsaXN0ZW5lcnMuc3VwcGxpZWQsIGxpc3RlbmVyKTtcclxuICAgIHdyYXBwZWRMaXN0ZW5lciA9IGxpc3RlbmVycy53cmFwcGVkW2xpc3RlbmVySW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGUgPT09ICdhbGwnKSB7XHJcbiAgICBmb3IgKHR5cGUgaW4gdGFyZ2V0LmV2ZW50cykge1xyXG4gICAgICBpZiAodGFyZ2V0LmV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG4gICAgICAgIHJlbW92ZShlbGVtZW50LCB0eXBlLCAnYWxsJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICh0YXJnZXQuZXZlbnRzW3R5cGVdKSB7XHJcbiAgICB2YXIgbGVuID0gdGFyZ2V0LmV2ZW50c1t0eXBlXS5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxpc3RlbmVyID09PSAnYWxsJykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgcmVtb3ZlKGVsZW1lbnQsIHR5cGUsIHRhcmdldC5ldmVudHNbdHlwZV1baV0sIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcclxuICAgICAgICBpZiAodGFyZ2V0LmV2ZW50c1t0eXBlXVtfaV0gPT09IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICBlbGVtZW50W3JlbW92ZUV2ZW50XShvbiArIHR5cGUsIHdyYXBwZWRMaXN0ZW5lciwgc3VwcG9ydHNPcHRpb25zID8gb3B0aW9ucyA6ICEhb3B0aW9ucy5jYXB0dXJlKTtcclxuICAgICAgICAgIHRhcmdldC5ldmVudHNbdHlwZV0uc3BsaWNlKF9pLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAodXNlQXR0YWNoRXZlbnQgJiYgbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy51c2VDb3VudFtsaXN0ZW5lckluZGV4XS0tO1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLnVzZUNvdW50W2xpc3RlbmVySW5kZXhdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLnN1cHBsaWVkLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcclxuICAgICAgICAgICAgICBsaXN0ZW5lcnMud3JhcHBlZC5zcGxpY2UobGlzdGVuZXJJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLnVzZUNvdW50LnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0YXJnZXQuZXZlbnRzW3R5cGVdICYmIHRhcmdldC5ldmVudHNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRhcmdldC5ldmVudHNbdHlwZV0gPSBudWxsO1xyXG4gICAgICB0YXJnZXQudHlwZUNvdW50LS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXRhcmdldC50eXBlQ291bnQpIHtcclxuICAgIHRhcmdldHMuc3BsaWNlKGVsZW1lbnRJbmRleCwgMSk7XHJcbiAgICBlbGVtZW50cy5zcGxpY2UoZWxlbWVudEluZGV4LCAxKTtcclxuICAgIGF0dGFjaGVkTGlzdGVuZXJzLnNwbGljZShlbGVtZW50SW5kZXgsIDEpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGVsZWdhdGUoc2VsZWN0b3IsIGNvbnRleHQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25hbEFyZykge1xyXG4gIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25hbEFyZyk7XHJcbiAgaWYgKCFkZWxlZ2F0ZWRFdmVudHNbdHlwZV0pIHtcclxuICAgIGRlbGVnYXRlZEV2ZW50c1t0eXBlXSA9IHtcclxuICAgICAgc2VsZWN0b3JzOiBbXSxcclxuICAgICAgY29udGV4dHM6IFtdLFxyXG4gICAgICBsaXN0ZW5lcnM6IFtdXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFkZCBkZWxlZ2F0ZSBsaXN0ZW5lciBmdW5jdGlvbnNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGFkZChkb2N1bWVudHNbaV0sIHR5cGUsIGRlbGVnYXRlTGlzdGVuZXIpO1xyXG4gICAgICBhZGQoZG9jdW1lbnRzW2ldLCB0eXBlLCBkZWxlZ2F0ZVVzZUNhcHR1cmUsIHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGRlbGVnYXRlZCA9IGRlbGVnYXRlZEV2ZW50c1t0eXBlXTtcclxuICB2YXIgaW5kZXggPSB2b2lkIDA7XHJcblxyXG4gIGZvciAoaW5kZXggPSBkZWxlZ2F0ZWQuc2VsZWN0b3JzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcclxuICAgIGlmIChkZWxlZ2F0ZWQuc2VsZWN0b3JzW2luZGV4XSA9PT0gc2VsZWN0b3IgJiYgZGVsZWdhdGVkLmNvbnRleHRzW2luZGV4XSA9PT0gY29udGV4dCkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgIGluZGV4ID0gZGVsZWdhdGVkLnNlbGVjdG9ycy5sZW5ndGg7XHJcblxyXG4gICAgZGVsZWdhdGVkLnNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcclxuICAgIGRlbGVnYXRlZC5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xyXG4gICAgZGVsZWdhdGVkLmxpc3RlbmVycy5wdXNoKFtdKTtcclxuICB9XHJcblxyXG4gIC8vIGtlZXAgbGlzdGVuZXIgYW5kIGNhcHR1cmUgYW5kIHBhc3NpdmUgZmxhZ3NcclxuICBkZWxlZ2F0ZWQubGlzdGVuZXJzW2luZGV4XS5wdXNoKFtsaXN0ZW5lciwgISFvcHRpb25zLmNhcHR1cmUsIG9wdGlvbnMucGFzc2l2ZV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVEZWxlZ2F0ZShzZWxlY3RvciwgY29udGV4dCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbmFsQXJnKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbmFsQXJnKTtcclxuICB2YXIgZGVsZWdhdGVkID0gZGVsZWdhdGVkRXZlbnRzW3R5cGVdO1xyXG4gIHZhciBtYXRjaEZvdW5kID0gZmFsc2U7XHJcbiAgdmFyIGluZGV4ID0gdm9pZCAwO1xyXG5cclxuICBpZiAoIWRlbGVnYXRlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gY291bnQgZnJvbSBsYXN0IGluZGV4IG9mIGRlbGVnYXRlZCB0byAwXHJcbiAgZm9yIChpbmRleCA9IGRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xyXG4gICAgLy8gbG9vayBmb3IgbWF0Y2hpbmcgc2VsZWN0b3IgYW5kIGNvbnRleHQgTm9kZVxyXG4gICAgaWYgKGRlbGVnYXRlZC5zZWxlY3RvcnNbaW5kZXhdID09PSBzZWxlY3RvciAmJiBkZWxlZ2F0ZWQuY29udGV4dHNbaW5kZXhdID09PSBjb250ZXh0KSB7XHJcblxyXG4gICAgICB2YXIgbGlzdGVuZXJzID0gZGVsZWdhdGVkLmxpc3RlbmVyc1tpbmRleF07XHJcblxyXG4gICAgICAvLyBlYWNoIGl0ZW0gb2YgdGhlIGxpc3RlbmVycyBhcnJheSBpcyBhbiBhcnJheTogW2Z1bmN0aW9uLCBjYXB0dXJlLCBwYXNzaXZlXVxyXG4gICAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdmFyIF9saXN0ZW5lcnMkaSA9IGxpc3RlbmVyc1tpXSxcclxuICAgICAgICAgICAgZm4gPSBfbGlzdGVuZXJzJGlbMF0sXHJcbiAgICAgICAgICAgIGNhcHR1cmUgPSBfbGlzdGVuZXJzJGlbMV0sXHJcbiAgICAgICAgICAgIHBhc3NpdmUgPSBfbGlzdGVuZXJzJGlbMl07XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMgYW5kIGNhcHR1cmUgYW5kIHBhc3NpdmUgZmxhZ3MgbWF0Y2hcclxuXHJcbiAgICAgICAgaWYgKGZuID09PSBsaXN0ZW5lciAmJiBjYXB0dXJlID09PSAhIW9wdGlvbnMuY2FwdHVyZSAmJiBwYXNzaXZlID09PSBvcHRpb25zLnBhc3NpdmUpIHtcclxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzXHJcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuICAgICAgICAgIC8vIGlmIGFsbCBsaXN0ZW5lcnMgZm9yIHRoaXMgaW50ZXJhY3RhYmxlIGhhdmUgYmVlbiByZW1vdmVkXHJcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGludGVyYWN0YWJsZSBmcm9tIHRoZSBkZWxlZ2F0ZWQgYXJyYXlzXHJcbiAgICAgICAgICBpZiAoIWxpc3RlbmVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZGVsZWdhdGVkLnNlbGVjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZWQuY29udGV4dHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgZGVsZWdhdGVkLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlbGVnYXRlIGZ1bmN0aW9uIGZyb20gY29udGV4dFxyXG4gICAgICAgICAgICByZW1vdmUoY29udGV4dCwgdHlwZSwgZGVsZWdhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHJlbW92ZShjb250ZXh0LCB0eXBlLCBkZWxlZ2F0ZVVzZUNhcHR1cmUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBhcnJheXMgaWYgdGhleSBhcmUgZW1wdHlcclxuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZWQuc2VsZWN0b3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGRlbGVnYXRlZEV2ZW50c1t0eXBlXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBvbmx5IHJlbW92ZSBvbmUgbGlzdGVuZXJcclxuICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobWF0Y2hGb3VuZCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBib3VuZCB0byB0aGUgaW50ZXJhY3RhYmxlIGNvbnRleHQgd2hlbiBhIERPTSBldmVudFxyXG4vLyBsaXN0ZW5lciBpcyBhZGRlZCB0byBhIHNlbGVjdG9yIGludGVyYWN0YWJsZVxyXG5mdW5jdGlvbiBkZWxlZ2F0ZUxpc3RlbmVyKGV2ZW50LCBvcHRpb25hbEFyZykge1xyXG4gIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25hbEFyZyk7XHJcbiAgdmFyIGZha2VFdmVudCA9IHt9O1xyXG4gIHZhciBkZWxlZ2F0ZWQgPSBkZWxlZ2F0ZWRFdmVudHNbZXZlbnQudHlwZV07XHJcbiAgdmFyIGV2ZW50VGFyZ2V0ID0gZG9tVXRpbHMuZ2V0QWN0dWFsRWxlbWVudChldmVudC5wYXRoID8gZXZlbnQucGF0aFswXSA6IGV2ZW50LnRhcmdldCk7XHJcbiAgdmFyIGVsZW1lbnQgPSBldmVudFRhcmdldDtcclxuXHJcbiAgLy8gZHVwbGljYXRlIHRoZSBldmVudCBzbyB0aGF0IGN1cnJlbnRUYXJnZXQgY2FuIGJlIGNoYW5nZWRcclxuICBwRXh0ZW5kKGZha2VFdmVudCwgZXZlbnQpO1xyXG5cclxuICBmYWtlRXZlbnQub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG4gIGZha2VFdmVudC5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnRPcmlnaW5hbERlZmF1bHQ7XHJcblxyXG4gIC8vIGNsaW1iIHVwIGRvY3VtZW50IHRyZWUgbG9va2luZyBmb3Igc2VsZWN0b3IgbWF0Y2hlc1xyXG4gIHdoaWxlIChpcy5lbGVtZW50KGVsZW1lbnQpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGVnYXRlZC5zZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNlbGVjdG9yID0gZGVsZWdhdGVkLnNlbGVjdG9yc1tpXTtcclxuICAgICAgdmFyIGNvbnRleHQgPSBkZWxlZ2F0ZWQuY29udGV4dHNbaV07XHJcblxyXG4gICAgICBpZiAoZG9tVXRpbHMubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSAmJiBkb21VdGlscy5ub2RlQ29udGFpbnMoY29udGV4dCwgZXZlbnRUYXJnZXQpICYmIGRvbVV0aWxzLm5vZGVDb250YWlucyhjb250ZXh0LCBlbGVtZW50KSkge1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZGVsZWdhdGVkLmxpc3RlbmVyc1tpXTtcclxuXHJcbiAgICAgICAgZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpc3RlbmVycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgdmFyIF9saXN0ZW5lcnMkaiA9IGxpc3RlbmVyc1tqXSxcclxuICAgICAgICAgICAgICBmbiA9IF9saXN0ZW5lcnMkalswXSxcclxuICAgICAgICAgICAgICBjYXB0dXJlID0gX2xpc3RlbmVycyRqWzFdLFxyXG4gICAgICAgICAgICAgIHBhc3NpdmUgPSBfbGlzdGVuZXJzJGpbMl07XHJcblxyXG5cclxuICAgICAgICAgIGlmIChjYXB0dXJlID09PSAhIW9wdGlvbnMuY2FwdHVyZSAmJiBwYXNzaXZlID09PSBvcHRpb25zLnBhc3NpdmUpIHtcclxuICAgICAgICAgICAgZm4oZmFrZUV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50ID0gZG9tVXRpbHMucGFyZW50Tm9kZShlbGVtZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbGVnYXRlVXNlQ2FwdHVyZShldmVudCkge1xyXG4gIHJldHVybiBkZWxlZ2F0ZUxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQsIHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmKCkge1xyXG4gIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJldmVudE9yaWdpbmFsRGVmYXVsdCgpIHtcclxuICB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcFByb3AoKSB7XHJcbiAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdG9wSW1tUHJvcCgpIHtcclxuICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRPcHRpb25zKHBhcmFtKSB7XHJcbiAgcmV0dXJuIGlzLm9iamVjdChwYXJhbSkgPyBwYXJhbSA6IHsgY2FwdHVyZTogcGFyYW0gfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgYWRkOiBhZGQsXHJcbiAgcmVtb3ZlOiByZW1vdmUsXHJcblxyXG4gIGFkZERlbGVnYXRlOiBhZGREZWxlZ2F0ZSxcclxuICByZW1vdmVEZWxlZ2F0ZTogcmVtb3ZlRGVsZWdhdGUsXHJcblxyXG4gIGRlbGVnYXRlTGlzdGVuZXI6IGRlbGVnYXRlTGlzdGVuZXIsXHJcbiAgZGVsZWdhdGVVc2VDYXB0dXJlOiBkZWxlZ2F0ZVVzZUNhcHR1cmUsXHJcbiAgZGVsZWdhdGVkRXZlbnRzOiBkZWxlZ2F0ZWRFdmVudHMsXHJcbiAgZG9jdW1lbnRzOiBkb2N1bWVudHMsXHJcblxyXG4gIHVzZUF0dGFjaEV2ZW50OiB1c2VBdHRhY2hFdmVudCxcclxuICBzdXBwb3J0c09wdGlvbnM6IHN1cHBvcnRzT3B0aW9ucyxcclxuXHJcbiAgX2VsZW1lbnRzOiBlbGVtZW50cyxcclxuICBfdGFyZ2V0czogdGFyZ2V0cyxcclxuICBfYXR0YWNoZWRMaXN0ZW5lcnM6IGF0dGFjaGVkTGlzdGVuZXJzXHJcbn07XHJcblxyXG59LHtcIi4vYXJyXCI6MzYsXCIuL2RvbVV0aWxzXCI6MzksXCIuL2lzXCI6NDYsXCIuL3BvaW50ZXJFeHRlbmRcIjo0OCxcIi4vd2luZG93XCI6NTJ9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc291cmNlKSB7XHJcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgfVxyXG4gIHJldHVybiBkZXN0O1xyXG59O1xyXG5cclxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3JlY3QnKSxcclxuICAgIHJlc29sdmVSZWN0TGlrZSA9IF9yZXF1aXJlLnJlc29sdmVSZWN0TGlrZSxcclxuICAgIHJlY3RUb1hZID0gX3JlcXVpcmUucmVjdFRvWFk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIGVsZW1lbnQsIGFjdGlvbikge1xyXG4gIHZhciBhY3Rpb25PcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnNbYWN0aW9uXTtcclxuICB2YXIgYWN0aW9uT3JpZ2luID0gYWN0aW9uT3B0aW9ucyAmJiBhY3Rpb25PcHRpb25zLm9yaWdpbjtcclxuICB2YXIgb3JpZ2luID0gYWN0aW9uT3JpZ2luIHx8IHRhcmdldC5vcHRpb25zLm9yaWdpbjtcclxuXHJcbiAgdmFyIG9yaWdpblJlY3QgPSByZXNvbHZlUmVjdExpa2Uob3JpZ2luLCB0YXJnZXQsIGVsZW1lbnQsIFt0YXJnZXQgJiYgZWxlbWVudF0pO1xyXG5cclxuICByZXR1cm4gcmVjdFRvWFkob3JpZ2luUmVjdCkgfHwgeyB4OiAwLCB5OiAwIH07XHJcbn07XHJcblxyXG59LHtcIi4vcmVjdFwiOjUxfV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG59O1xyXG5cclxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcclxudmFyIHdpbiA9IHJlcXVpcmUoJy4vd2luZG93Jyk7XHJcblxyXG52YXIgdXRpbHMgPSB7XHJcbiAgd2Fybk9uY2U6IGZ1bmN0aW9uIHdhcm5PbmNlKG1ldGhvZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghd2FybmVkKSB7XHJcbiAgICAgICAgd2luLndpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgd2FybmVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NjM0NTI4LzIyODA4ODhcclxuICBfZ2V0UUJlemllclZhbHVlOiBmdW5jdGlvbiBfZ2V0UUJlemllclZhbHVlKHQsIHAxLCBwMiwgcDMpIHtcclxuICAgIHZhciBpVCA9IDEgLSB0O1xyXG4gICAgcmV0dXJuIGlUICogaVQgKiBwMSArIDIgKiBpVCAqIHQgKiBwMiArIHQgKiB0ICogcDM7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UXVhZHJhdGljQ3VydmVQb2ludDogZnVuY3Rpb24gZ2V0UXVhZHJhdGljQ3VydmVQb2ludChzdGFydFgsIHN0YXJ0WSwgY3BYLCBjcFksIGVuZFgsIGVuZFksIHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB1dGlscy5fZ2V0UUJlemllclZhbHVlKHBvc2l0aW9uLCBzdGFydFgsIGNwWCwgZW5kWCksXHJcbiAgICAgIHk6IHV0aWxzLl9nZXRRQmV6aWVyVmFsdWUocG9zaXRpb24sIHN0YXJ0WSwgY3BZLCBlbmRZKVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvLyBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cclxuICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gZWFzZU91dFF1YWQodCwgYiwgYywgZCkge1xyXG4gICAgdCAvPSBkO1xyXG4gICAgcmV0dXJuIC1jICogdCAqICh0IC0gMikgKyBiO1xyXG4gIH0sXHJcblxyXG4gIGNvcHlBY3Rpb246IGZ1bmN0aW9uIGNvcHlBY3Rpb24oZGVzdCwgc3JjKSB7XHJcbiAgICBkZXN0Lm5hbWUgPSBzcmMubmFtZTtcclxuICAgIGRlc3QuYXhpcyA9IHNyYy5heGlzO1xyXG4gICAgZGVzdC5lZGdlcyA9IHNyYy5lZGdlcztcclxuXHJcbiAgICByZXR1cm4gZGVzdDtcclxuICB9LFxyXG5cclxuICBpczogcmVxdWlyZSgnLi9pcycpLFxyXG4gIGV4dGVuZDogZXh0ZW5kLFxyXG4gIGh5cG90OiByZXF1aXJlKCcuL2h5cG90JyksXHJcbiAgZ2V0T3JpZ2luWFk6IHJlcXVpcmUoJy4vZ2V0T3JpZ2luWFknKVxyXG59O1xyXG5cclxuZXh0ZW5kKHV0aWxzLCByZXF1aXJlKCcuL2FycicpKTtcclxuZXh0ZW5kKHV0aWxzLCByZXF1aXJlKCcuL2RvbVV0aWxzJykpO1xyXG5leHRlbmQodXRpbHMsIHJlcXVpcmUoJy4vcG9pbnRlclV0aWxzJykpO1xyXG5leHRlbmQodXRpbHMsIHJlcXVpcmUoJy4vcmVjdCcpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7XHJcblxyXG59LHtcIi4vYXJyXCI6MzYsXCIuL2RvbVV0aWxzXCI6MzksXCIuL2V4dGVuZFwiOjQxLFwiLi9nZXRPcmlnaW5YWVwiOjQyLFwiLi9oeXBvdFwiOjQzLFwiLi9pc1wiOjQ2LFwiLi9wb2ludGVyVXRpbHNcIjo0OSxcIi4vcmVjdFwiOjUxLFwiLi93aW5kb3dcIjo1Mn1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNjb3BlID0gcmVxdWlyZSgnLi4vc2NvcGUnKTtcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9pbmRleCcpO1xyXG5cclxudmFyIGZpbmRlciA9IHtcclxuICBtZXRob2RPcmRlcjogWydzaW11bGF0aW9uUmVzdW1lJywgJ21vdXNlT3JQZW4nLCAnaGFzUG9pbnRlcicsICdpZGxlJ10sXHJcblxyXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKHBvaW50ZXIsIGV2ZW50VHlwZSwgZXZlbnRUYXJnZXQpIHtcclxuICAgIHZhciBwb2ludGVyVHlwZSA9IHV0aWxzLmdldFBvaW50ZXJUeXBlKHBvaW50ZXIpO1xyXG4gICAgdmFyIHBvaW50ZXJJZCA9IHV0aWxzLmdldFBvaW50ZXJJZChwb2ludGVyKTtcclxuICAgIHZhciBkZXRhaWxzID0geyBwb2ludGVyOiBwb2ludGVyLCBwb2ludGVySWQ6IHBvaW50ZXJJZCwgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLCBldmVudFR5cGU6IGV2ZW50VHlwZSwgZXZlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0IH07XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZmluZGVyLm1ldGhvZE9yZGVyLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xyXG4gICAgICB2YXIgX3JlZjtcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheSkge1xyXG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbWV0aG9kID0gX3JlZjtcclxuXHJcbiAgICAgIHZhciBpbnRlcmFjdGlvbiA9IGZpbmRlclttZXRob2RdKGRldGFpbHMpO1xyXG5cclxuICAgICAgaWYgKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gdHJ5IHRvIHJlc3VtZSBzaW11bGF0aW9uIHdpdGggYSBuZXcgcG9pbnRlclxyXG4gIHNpbXVsYXRpb25SZXN1bWU6IGZ1bmN0aW9uIHNpbXVsYXRpb25SZXN1bWUoX3JlZjIpIHtcclxuICAgIHZhciBwb2ludGVyVHlwZSA9IF9yZWYyLnBvaW50ZXJUeXBlLFxyXG4gICAgICAgIGV2ZW50VHlwZSA9IF9yZWYyLmV2ZW50VHlwZSxcclxuICAgICAgICBldmVudFRhcmdldCA9IF9yZWYyLmV2ZW50VGFyZ2V0O1xyXG5cclxuICAgIGlmICghL2Rvd258c3RhcnQvaS50ZXN0KGV2ZW50VHlwZSkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHNjb3BlLmludGVyYWN0aW9ucywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmMztcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheTIpIHtcclxuICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjJbX2kyKytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWYzO1xyXG5cclxuICAgICAgdmFyIGVsZW1lbnQgPSBldmVudFRhcmdldDtcclxuXHJcbiAgICAgIGlmIChpbnRlcmFjdGlvbi5zaW11bGF0aW9uICYmIGludGVyYWN0aW9uLnNpbXVsYXRpb24uYWxsb3dSZXN1bWUgJiYgaW50ZXJhY3Rpb24ucG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlKSB7XHJcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGlvbiBlbGVtZW50XHJcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gaW50ZXJhY3Rpb24uZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbGVtZW50ID0gdXRpbHMucGFyZW50Tm9kZShlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9LFxyXG5cclxuICAvLyBpZiBpdCdzIGEgbW91c2Ugb3IgcGVuIGludGVyYWN0aW9uXHJcbiAgbW91c2VPclBlbjogZnVuY3Rpb24gbW91c2VPclBlbihfcmVmNCkge1xyXG4gICAgdmFyIHBvaW50ZXJJZCA9IF9yZWY0LnBvaW50ZXJJZCxcclxuICAgICAgICBwb2ludGVyVHlwZSA9IF9yZWY0LnBvaW50ZXJUeXBlLFxyXG4gICAgICAgIGV2ZW50VHlwZSA9IF9yZWY0LmV2ZW50VHlwZTtcclxuXHJcbiAgICBpZiAocG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgcG9pbnRlclR5cGUgIT09ICdwZW4nKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaXJzdE5vbkFjdGl2ZSA9IHZvaWQgMDtcclxuXHJcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gc2NvcGUuaW50ZXJhY3Rpb25zLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWY1O1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5Mykge1xyXG4gICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yM1tfaTMrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pMy5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmNSA9IF9pMy52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGludGVyYWN0aW9uID0gX3JlZjU7XHJcblxyXG4gICAgICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlKSB7XHJcbiAgICAgICAgLy8gaWYgaXQncyBhIGRvd24gZXZlbnQsIHNraXAgaW50ZXJhY3Rpb25zIHdpdGggcnVubmluZyBzaW11bGF0aW9uc1xyXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5zaW11bGF0aW9uICYmICF1dGlscy5jb250YWlucyhpbnRlcmFjdGlvbi5wb2ludGVySWRzLCBwb2ludGVySWQpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIHJldHVybiBpdCBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBzYXZlIGl0IGFuZCBsb29rIGZvciBhbm90aGVyIGFjdGl2ZSBpbnRlcmFjdGlvblxyXG4gICAgICAgIGVsc2UgaWYgKCFmaXJzdE5vbkFjdGl2ZSkge1xyXG4gICAgICAgICAgICBmaXJzdE5vbkFjdGl2ZSA9IGludGVyYWN0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgbm8gYWN0aXZlIG1vdXNlIGludGVyYWN0aW9uIHdhcyBmb3VuZCB1c2UgdGhlIGZpcnN0IGluYWN0aXZlIG1vdXNlXHJcbiAgICAvLyBpbnRlcmFjdGlvblxyXG4gICAgaWYgKGZpcnN0Tm9uQWN0aXZlKSB7XHJcbiAgICAgIHJldHVybiBmaXJzdE5vbkFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaW5kIGFueSBtb3VzZSBvciBwZW4gaW50ZXJhY3Rpb24uXHJcbiAgICAvLyBpZ25vcmUgdGhlIGludGVyYWN0aW9uIGlmIHRoZSBldmVudFR5cGUgaXMgYSAqZG93biwgYW5kIGEgc2ltdWxhdGlvblxyXG4gICAgLy8gaXMgYWN0aXZlXHJcbiAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gc2NvcGUuaW50ZXJhY3Rpb25zLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLCBfaTQgPSAwLCBfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID8gX2l0ZXJhdG9yNCA6IF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWY2O1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5NCkge1xyXG4gICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWY2ID0gX2l0ZXJhdG9yNFtfaTQrK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2k0ID0gX2l0ZXJhdG9yNC5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pNC5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmNiA9IF9pNC52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIF9pbnRlcmFjdGlvbiA9IF9yZWY2O1xyXG5cclxuICAgICAgaWYgKF9pbnRlcmFjdGlvbi5wb2ludGVyVHlwZSA9PT0gcG9pbnRlclR5cGUgJiYgISgvZG93bi9pLnRlc3QoZXZlbnRUeXBlKSAmJiBfaW50ZXJhY3Rpb24uc2ltdWxhdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gX2ludGVyYWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuXHJcbiAgLy8gZ2V0IGludGVyYWN0aW9uIHRoYXQgaGFzIHRoaXMgcG9pbnRlclxyXG4gIGhhc1BvaW50ZXI6IGZ1bmN0aW9uIGhhc1BvaW50ZXIoX3JlZjcpIHtcclxuICAgIHZhciBwb2ludGVySWQgPSBfcmVmNy5wb2ludGVySWQ7XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IHNjb3BlLmludGVyYWN0aW9ucywgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k1ID0gMCwgX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/IF9pdGVyYXRvcjUgOiBfaXRlcmF0b3I1W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmODtcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheTUpIHtcclxuICAgICAgICBpZiAoX2k1ID49IF9pdGVyYXRvcjUubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmOCA9IF9pdGVyYXRvcjVbX2k1KytdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9pNSA9IF9pdGVyYXRvcjUubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XHJcbiAgICAgICAgX3JlZjggPSBfaTUudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9yZWY4O1xyXG5cclxuICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKGludGVyYWN0aW9uLnBvaW50ZXJJZHMsIHBvaW50ZXJJZCkpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBnZXQgZmlyc3QgaWRsZSBpbnRlcmFjdGlvbiB3aXRoIGEgbWF0Y2hpbmcgcG9pbnRlclR5cGVcclxuICBpZGxlOiBmdW5jdGlvbiBpZGxlKF9yZWY5KSB7XHJcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBfcmVmOS5wb2ludGVyVHlwZTtcclxuXHJcbiAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gc2NvcGUuaW50ZXJhY3Rpb25zLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTYgPSAwLCBfaXRlcmF0b3I2ID0gX2lzQXJyYXk2ID8gX2l0ZXJhdG9yNiA6IF9pdGVyYXRvcjZbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcclxuICAgICAgdmFyIF9yZWYxMDtcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheTYpIHtcclxuICAgICAgICBpZiAoX2k2ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmMTAgPSBfaXRlcmF0b3I2W19pNisrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaTYgPSBfaXRlcmF0b3I2Lm5leHQoKTtcclxuICAgICAgICBpZiAoX2k2LmRvbmUpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYxMCA9IF9pNi52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGludGVyYWN0aW9uID0gX3JlZjEwO1xyXG5cclxuICAgICAgLy8gaWYgdGhlcmUncyBhbHJlYWR5IGEgcG9pbnRlciBoZWxkIGRvd25cclxuICAgICAgaWYgKGludGVyYWN0aW9uLnBvaW50ZXJJZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGludGVyYWN0aW9uLnRhcmdldDtcclxuICAgICAgICAvLyBkb24ndCBhZGQgdGhpcyBwb2ludGVyIGlmIHRoZXJlIGlzIGEgdGFyZ2V0IGludGVyYWN0YWJsZSBhbmQgaXRcclxuICAgICAgICAvLyBpc24ndCBnZXN0dXJhYmxlXHJcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhdGFyZ2V0Lm9wdGlvbnMuZ2VzdHVyZS5lbmFibGVkKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gbWF4aW11bSBvZiAyIHBvaW50ZXJzIHBlciBpbnRlcmFjdGlvblxyXG4gICAgICBlbHNlIGlmIChpbnRlcmFjdGlvbi5wb2ludGVySWRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICBpZiAoIWludGVyYWN0aW9uLmludGVyYWN0aW5nKCkgJiYgcG9pbnRlclR5cGUgPT09IGludGVyYWN0aW9uLnBvaW50ZXJUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmaW5kZXI7XHJcblxyXG59LHtcIi4uL3Njb3BlXCI6MzQsXCIuL2luZGV4XCI6NDR9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbnZhciB3aW4gPSByZXF1aXJlKCcuL3dpbmRvdycpO1xyXG52YXIgaXNXaW5kb3cgPSByZXF1aXJlKCcuL2lzV2luZG93Jyk7XHJcblxyXG52YXIgaXMgPSB7XHJcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KCkge30sXHJcblxyXG4gIHdpbmRvdzogZnVuY3Rpb24gd2luZG93KHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpbmcgPT09IHdpbi53aW5kb3cgfHwgaXNXaW5kb3codGhpbmcpO1xyXG4gIH0sXHJcblxyXG4gIGRvY0ZyYWc6IGZ1bmN0aW9uIGRvY0ZyYWcodGhpbmcpIHtcclxuICAgIHJldHVybiBpcy5vYmplY3QodGhpbmcpICYmIHRoaW5nLm5vZGVUeXBlID09PSAxMTtcclxuICB9LFxyXG5cclxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh0aGluZykge1xyXG4gICAgcmV0dXJuICEhdGhpbmcgJiYgKHR5cGVvZiB0aGluZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGhpbmcpKSA9PT0gJ29iamVjdCc7XHJcbiAgfSxcclxuXHJcbiAgZnVuY3Rpb246IGZ1bmN0aW9uIF9mdW5jdGlvbih0aGluZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcclxuICB9LFxyXG5cclxuICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih0aGluZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ251bWJlcic7XHJcbiAgfSxcclxuXHJcbiAgYm9vbDogZnVuY3Rpb24gYm9vbCh0aGluZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Jvb2xlYW4nO1xyXG4gIH0sXHJcblxyXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJztcclxuICB9LFxyXG5cclxuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KHRoaW5nKSB7XHJcbiAgICBpZiAoIXRoaW5nIHx8ICh0eXBlb2YgdGhpbmcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRoaW5nKSkgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3dpbmRvdyA9IHdpbi5nZXRXaW5kb3codGhpbmcpIHx8IHdpbi53aW5kb3c7XHJcblxyXG4gICAgcmV0dXJuICgvb2JqZWN0fGZ1bmN0aW9uLy50ZXN0KF90eXBlb2YoX3dpbmRvdy5FbGVtZW50KSkgPyB0aGluZyBpbnN0YW5jZW9mIF93aW5kb3cuRWxlbWVudCAvL0RPTTJcclxuICAgICAgOiB0aGluZy5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2YgdGhpbmcubm9kZU5hbWUgPT09ICdzdHJpbmcnXHJcbiAgICApO1xyXG4gIH1cclxufTtcclxuXHJcbmlzLmFycmF5ID0gZnVuY3Rpb24gKHRoaW5nKSB7XHJcbiAgcmV0dXJuIGlzLm9iamVjdCh0aGluZykgJiYgdHlwZW9mIHRoaW5nLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuZnVuY3Rpb24odGhpbmcuc3BsaWNlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXM7XHJcblxyXG59LHtcIi4vaXNXaW5kb3dcIjo0NyxcIi4vd2luZG93XCI6NTJ9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhpbmcpIHtcclxuICByZXR1cm4gISEodGhpbmcgJiYgdGhpbmcuV2luZG93KSAmJiB0aGluZyBpbnN0YW5jZW9mIHRoaW5nLldpbmRvdztcclxufTtcclxuXHJcbn0se31dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gcG9pbnRlckV4dGVuZChkZXN0LCBzb3VyY2UpIHtcclxuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xyXG4gICAgdmFyIHByZWZpeGVkUHJvcFJFcyA9IG1vZHVsZS5leHBvcnRzLnByZWZpeGVkUHJvcFJFcztcclxuICAgIHZhciBkZXByZWNhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gc2tpcCBkZXByZWNhdGVkIHByZWZpeGVkIHByb3BlcnRpZXNcclxuICAgIGZvciAodmFyIHZlbmRvciBpbiBwcmVmaXhlZFByb3BSRXMpIHtcclxuICAgICAgaWYgKHByb3AuaW5kZXhPZih2ZW5kb3IpID09PSAwICYmIHByZWZpeGVkUHJvcFJFc1t2ZW5kb3JdLnRlc3QocHJvcCkpIHtcclxuICAgICAgICBkZXByZWNhdGVkID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghZGVwcmVjYXRlZCAmJiB0eXBlb2Ygc291cmNlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBkZXN0O1xyXG59XHJcblxyXG5wb2ludGVyRXh0ZW5kLnByZWZpeGVkUHJvcFJFcyA9IHtcclxuICB3ZWJraXQ6IC8oTW92ZW1lbnRbWFldfFJhZGl1c1tYWV18Um90YXRpb25BbmdsZXxGb3JjZSkkL1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwb2ludGVyRXh0ZW5kO1xyXG5cclxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaHlwb3QgPSByZXF1aXJlKCcuL2h5cG90Jyk7XHJcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuL2RvbU9iamVjdHMnKTtcclxudmFyIGRvbVV0aWxzID0gcmVxdWlyZSgnLi9kb21VdGlscycpO1xyXG52YXIgZG9tT2JqZWN0cyA9IHJlcXVpcmUoJy4vZG9tT2JqZWN0cycpO1xyXG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XHJcbnZhciBwb2ludGVyRXh0ZW5kID0gcmVxdWlyZSgnLi9wb2ludGVyRXh0ZW5kJyk7XHJcblxyXG52YXIgcG9pbnRlclV0aWxzID0ge1xyXG4gIGNvcHlDb29yZHM6IGZ1bmN0aW9uIGNvcHlDb29yZHMoZGVzdCwgc3JjKSB7XHJcbiAgICBkZXN0LnBhZ2UgPSBkZXN0LnBhZ2UgfHwge307XHJcbiAgICBkZXN0LnBhZ2UueCA9IHNyYy5wYWdlLng7XHJcbiAgICBkZXN0LnBhZ2UueSA9IHNyYy5wYWdlLnk7XHJcblxyXG4gICAgZGVzdC5jbGllbnQgPSBkZXN0LmNsaWVudCB8fCB7fTtcclxuICAgIGRlc3QuY2xpZW50LnggPSBzcmMuY2xpZW50Lng7XHJcbiAgICBkZXN0LmNsaWVudC55ID0gc3JjLmNsaWVudC55O1xyXG5cclxuICAgIGRlc3QudGltZVN0YW1wID0gc3JjLnRpbWVTdGFtcDtcclxuICB9LFxyXG5cclxuICBzZXRDb29yZERlbHRhczogZnVuY3Rpb24gc2V0Q29vcmREZWx0YXModGFyZ2V0T2JqLCBwcmV2LCBjdXIpIHtcclxuICAgIHRhcmdldE9iai5wYWdlLnggPSBjdXIucGFnZS54IC0gcHJldi5wYWdlLng7XHJcbiAgICB0YXJnZXRPYmoucGFnZS55ID0gY3VyLnBhZ2UueSAtIHByZXYucGFnZS55O1xyXG4gICAgdGFyZ2V0T2JqLmNsaWVudC54ID0gY3VyLmNsaWVudC54IC0gcHJldi5jbGllbnQueDtcclxuICAgIHRhcmdldE9iai5jbGllbnQueSA9IGN1ci5jbGllbnQueSAtIHByZXYuY2xpZW50Lnk7XHJcbiAgICB0YXJnZXRPYmoudGltZVN0YW1wID0gY3VyLnRpbWVTdGFtcCAtIHByZXYudGltZVN0YW1wO1xyXG5cclxuICAgIC8vIHNldCBwb2ludGVyIHZlbG9jaXR5XHJcbiAgICB2YXIgZHQgPSBNYXRoLm1heCh0YXJnZXRPYmoudGltZVN0YW1wIC8gMTAwMCwgMC4wMDEpO1xyXG5cclxuICAgIHRhcmdldE9iai5wYWdlLnNwZWVkID0gaHlwb3QodGFyZ2V0T2JqLnBhZ2UueCwgdGFyZ2V0T2JqLnBhZ2UueSkgLyBkdDtcclxuICAgIHRhcmdldE9iai5wYWdlLnZ4ID0gdGFyZ2V0T2JqLnBhZ2UueCAvIGR0O1xyXG4gICAgdGFyZ2V0T2JqLnBhZ2UudnkgPSB0YXJnZXRPYmoucGFnZS55IC8gZHQ7XHJcblxyXG4gICAgdGFyZ2V0T2JqLmNsaWVudC5zcGVlZCA9IGh5cG90KHRhcmdldE9iai5jbGllbnQueCwgdGFyZ2V0T2JqLnBhZ2UueSkgLyBkdDtcclxuICAgIHRhcmdldE9iai5jbGllbnQudnggPSB0YXJnZXRPYmouY2xpZW50LnggLyBkdDtcclxuICAgIHRhcmdldE9iai5jbGllbnQudnkgPSB0YXJnZXRPYmouY2xpZW50LnkgLyBkdDtcclxuICB9LFxyXG5cclxuICBpc05hdGl2ZVBvaW50ZXI6IGZ1bmN0aW9uIGlzTmF0aXZlUG9pbnRlcihwb2ludGVyKSB7XHJcbiAgICByZXR1cm4gcG9pbnRlciBpbnN0YW5jZW9mIGRvbS5FdmVudCB8fCBwb2ludGVyIGluc3RhbmNlb2YgZG9tLlRvdWNoO1xyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBzcGVjaWZpZWQgWC9ZIGNvb3JkcyBmb3IgbW91c2Ugb3IgZXZlbnQudG91Y2hlc1swXVxyXG4gIGdldFhZOiBmdW5jdGlvbiBnZXRYWSh0eXBlLCBwb2ludGVyLCB4eSkge1xyXG4gICAgeHkgPSB4eSB8fCB7fTtcclxuICAgIHR5cGUgPSB0eXBlIHx8ICdwYWdlJztcclxuXHJcbiAgICB4eS54ID0gcG9pbnRlclt0eXBlICsgJ1gnXTtcclxuICAgIHh5LnkgPSBwb2ludGVyW3R5cGUgKyAnWSddO1xyXG5cclxuICAgIHJldHVybiB4eTtcclxuICB9LFxyXG5cclxuICBnZXRQYWdlWFk6IGZ1bmN0aW9uIGdldFBhZ2VYWShwb2ludGVyLCBwYWdlKSB7XHJcbiAgICBwYWdlID0gcGFnZSB8fCB7fTtcclxuXHJcbiAgICAvLyBPcGVyYSBNb2JpbGUgaGFuZGxlcyB0aGUgdmlld3BvcnQgYW5kIHNjcm9sbGluZyBvZGRseVxyXG4gICAgaWYgKGJyb3dzZXIuaXNPcGVyYU1vYmlsZSAmJiBwb2ludGVyVXRpbHMuaXNOYXRpdmVQb2ludGVyKHBvaW50ZXIpKSB7XHJcbiAgICAgIHBvaW50ZXJVdGlscy5nZXRYWSgnc2NyZWVuJywgcG9pbnRlciwgcGFnZSk7XHJcblxyXG4gICAgICBwYWdlLnggKz0gd2luZG93LnNjcm9sbFg7XHJcbiAgICAgIHBhZ2UueSArPSB3aW5kb3cuc2Nyb2xsWTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50ZXJVdGlscy5nZXRYWSgncGFnZScsIHBvaW50ZXIsIHBhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYWdlO1xyXG4gIH0sXHJcblxyXG4gIGdldENsaWVudFhZOiBmdW5jdGlvbiBnZXRDbGllbnRYWShwb2ludGVyLCBjbGllbnQpIHtcclxuICAgIGNsaWVudCA9IGNsaWVudCB8fCB7fTtcclxuXHJcbiAgICBpZiAoYnJvd3Nlci5pc09wZXJhTW9iaWxlICYmIHBvaW50ZXJVdGlscy5pc05hdGl2ZVBvaW50ZXIocG9pbnRlcikpIHtcclxuICAgICAgLy8gT3BlcmEgTW9iaWxlIGhhbmRsZXMgdGhlIHZpZXdwb3J0IGFuZCBzY3JvbGxpbmcgb2RkbHlcclxuICAgICAgcG9pbnRlclV0aWxzLmdldFhZKCdzY3JlZW4nLCBwb2ludGVyLCBjbGllbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9pbnRlclV0aWxzLmdldFhZKCdjbGllbnQnLCBwb2ludGVyLCBjbGllbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGllbnQ7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UG9pbnRlcklkOiBmdW5jdGlvbiBnZXRQb2ludGVySWQocG9pbnRlcikge1xyXG4gICAgcmV0dXJuIGlzLm51bWJlcihwb2ludGVyLnBvaW50ZXJJZCkgPyBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcclxuICB9LFxyXG5cclxuICBzZXRDb29yZHM6IGZ1bmN0aW9uIHNldENvb3Jkcyh0YXJnZXRPYmosIHBvaW50ZXJzLCB0aW1lU3RhbXApIHtcclxuICAgIHZhciBwb2ludGVyID0gcG9pbnRlcnMubGVuZ3RoID4gMSA/IHBvaW50ZXJVdGlscy5wb2ludGVyQXZlcmFnZShwb2ludGVycykgOiBwb2ludGVyc1swXTtcclxuXHJcbiAgICB2YXIgdG1wWFkgPSB7fTtcclxuXHJcbiAgICBwb2ludGVyVXRpbHMuZ2V0UGFnZVhZKHBvaW50ZXIsIHRtcFhZKTtcclxuICAgIHRhcmdldE9iai5wYWdlLnggPSB0bXBYWS54O1xyXG4gICAgdGFyZ2V0T2JqLnBhZ2UueSA9IHRtcFhZLnk7XHJcblxyXG4gICAgcG9pbnRlclV0aWxzLmdldENsaWVudFhZKHBvaW50ZXIsIHRtcFhZKTtcclxuICAgIHRhcmdldE9iai5jbGllbnQueCA9IHRtcFhZLng7XHJcbiAgICB0YXJnZXRPYmouY2xpZW50LnkgPSB0bXBYWS55O1xyXG5cclxuICAgIHRhcmdldE9iai50aW1lU3RhbXAgPSBpcy5udW1iZXIodGltZVN0YW1wKSA/IHRpbWVTdGFtcCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH0sXHJcblxyXG4gIHBvaW50ZXJFeHRlbmQ6IHBvaW50ZXJFeHRlbmQsXHJcblxyXG4gIGdldFRvdWNoUGFpcjogZnVuY3Rpb24gZ2V0VG91Y2hQYWlyKGV2ZW50KSB7XHJcbiAgICB2YXIgdG91Y2hlcyA9IFtdO1xyXG5cclxuICAgIC8vIGFycmF5IG9mIHRvdWNoZXMgaXMgc3VwcGxpZWRcclxuICAgIGlmIChpcy5hcnJheShldmVudCkpIHtcclxuICAgICAgdG91Y2hlc1swXSA9IGV2ZW50WzBdO1xyXG4gICAgICB0b3VjaGVzWzFdID0gZXZlbnRbMV07XHJcbiAgICB9XHJcbiAgICAvLyBhbiBldmVudFxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcclxuICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0b3VjaGVzWzBdID0gZXZlbnQudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgdG91Y2hlc1sxXSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0b3VjaGVzWzBdID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgIHRvdWNoZXNbMV0gPSBldmVudC5jaGFuZ2VkVG91Y2hlc1sxXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdG91Y2hlc1swXSA9IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgICAgICAgICB0b3VjaGVzWzFdID0gZXZlbnQudG91Y2hlc1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG91Y2hlcztcclxuICB9LFxyXG5cclxuICBwb2ludGVyQXZlcmFnZTogZnVuY3Rpb24gcG9pbnRlckF2ZXJhZ2UocG9pbnRlcnMpIHtcclxuICAgIHZhciBhdmVyYWdlID0ge1xyXG4gICAgICBwYWdlWDogMCxcclxuICAgICAgcGFnZVk6IDAsXHJcbiAgICAgIGNsaWVudFg6IDAsXHJcbiAgICAgIGNsaWVudFk6IDAsXHJcbiAgICAgIHNjcmVlblg6IDAsXHJcbiAgICAgIHNjcmVlblk6IDBcclxuICAgIH07XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcG9pbnRlcnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmO1xyXG5cclxuICAgICAgaWYgKF9pc0FycmF5KSB7XHJcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xyXG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcclxuICAgICAgICBfcmVmID0gX2kudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwb2ludGVyID0gX3JlZjtcclxuXHJcbiAgICAgIGZvciAodmFyIF9wcm9wIGluIGF2ZXJhZ2UpIHtcclxuICAgICAgICBhdmVyYWdlW19wcm9wXSArPSBwb2ludGVyW19wcm9wXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdmVyYWdlKSB7XHJcbiAgICAgIGF2ZXJhZ2VbcHJvcF0gLz0gcG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhdmVyYWdlO1xyXG4gIH0sXHJcblxyXG4gIHRvdWNoQkJveDogZnVuY3Rpb24gdG91Y2hCQm94KGV2ZW50KSB7XHJcbiAgICBpZiAoIWV2ZW50Lmxlbmd0aCAmJiAhKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRvdWNoZXMgPSBwb2ludGVyVXRpbHMuZ2V0VG91Y2hQYWlyKGV2ZW50KTtcclxuICAgIHZhciBtaW5YID0gTWF0aC5taW4odG91Y2hlc1swXS5wYWdlWCwgdG91Y2hlc1sxXS5wYWdlWCk7XHJcbiAgICB2YXIgbWluWSA9IE1hdGgubWluKHRvdWNoZXNbMF0ucGFnZVksIHRvdWNoZXNbMV0ucGFnZVkpO1xyXG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh0b3VjaGVzWzBdLnBhZ2VYLCB0b3VjaGVzWzFdLnBhZ2VYKTtcclxuICAgIHZhciBtYXhZID0gTWF0aC5tYXgodG91Y2hlc1swXS5wYWdlWSwgdG91Y2hlc1sxXS5wYWdlWSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogbWluWCxcclxuICAgICAgeTogbWluWSxcclxuICAgICAgbGVmdDogbWluWCxcclxuICAgICAgdG9wOiBtaW5ZLFxyXG4gICAgICB3aWR0aDogbWF4WCAtIG1pblgsXHJcbiAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgdG91Y2hEaXN0YW5jZTogZnVuY3Rpb24gdG91Y2hEaXN0YW5jZShldmVudCwgZGVsdGFTb3VyY2UpIHtcclxuICAgIHZhciBzb3VyY2VYID0gZGVsdGFTb3VyY2UgKyAnWCc7XHJcbiAgICB2YXIgc291cmNlWSA9IGRlbHRhU291cmNlICsgJ1knO1xyXG4gICAgdmFyIHRvdWNoZXMgPSBwb2ludGVyVXRpbHMuZ2V0VG91Y2hQYWlyKGV2ZW50KTtcclxuXHJcbiAgICB2YXIgZHggPSB0b3VjaGVzWzBdW3NvdXJjZVhdIC0gdG91Y2hlc1sxXVtzb3VyY2VYXTtcclxuICAgIHZhciBkeSA9IHRvdWNoZXNbMF1bc291cmNlWV0gLSB0b3VjaGVzWzFdW3NvdXJjZVldO1xyXG5cclxuICAgIHJldHVybiBoeXBvdChkeCwgZHkpO1xyXG4gIH0sXHJcblxyXG4gIHRvdWNoQW5nbGU6IGZ1bmN0aW9uIHRvdWNoQW5nbGUoZXZlbnQsIHByZXZBbmdsZSwgZGVsdGFTb3VyY2UpIHtcclxuICAgIHZhciBzb3VyY2VYID0gZGVsdGFTb3VyY2UgKyAnWCc7XHJcbiAgICB2YXIgc291cmNlWSA9IGRlbHRhU291cmNlICsgJ1knO1xyXG4gICAgdmFyIHRvdWNoZXMgPSBwb2ludGVyVXRpbHMuZ2V0VG91Y2hQYWlyKGV2ZW50KTtcclxuICAgIHZhciBkeCA9IHRvdWNoZXNbMV1bc291cmNlWF0gLSB0b3VjaGVzWzBdW3NvdXJjZVhdO1xyXG4gICAgdmFyIGR5ID0gdG91Y2hlc1sxXVtzb3VyY2VZXSAtIHRvdWNoZXNbMF1bc291cmNlWV07XHJcbiAgICB2YXIgYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKGR5LCBkeCkgLyBNYXRoLlBJO1xyXG5cclxuICAgIHJldHVybiBhbmdsZTtcclxuICB9LFxyXG5cclxuICBnZXRQb2ludGVyVHlwZTogZnVuY3Rpb24gZ2V0UG9pbnRlclR5cGUocG9pbnRlcikge1xyXG4gICAgcmV0dXJuIGlzLnN0cmluZyhwb2ludGVyLnBvaW50ZXJUeXBlKSA/IHBvaW50ZXIucG9pbnRlclR5cGUgOiBpcy5udW1iZXIocG9pbnRlci5wb2ludGVyVHlwZSkgPyBbdW5kZWZpbmVkLCB1bmRlZmluZWQsICd0b3VjaCcsICdwZW4nLCAnbW91c2UnXVtwb2ludGVyLnBvaW50ZXJUeXBlXVxyXG4gICAgLy8gaWYgdGhlIFBvaW50ZXJFdmVudCBBUEkgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIHRoZSBcInBvaW50ZXJcIiBtdXN0XHJcbiAgICAvLyBiZSBlaXRoZXIgYSBNb3VzZUV2ZW50LCBUb3VjaEV2ZW50LCBvciBUb3VjaCBvYmplY3RcclxuICAgIDogL3RvdWNoLy50ZXN0KHBvaW50ZXIudHlwZSkgfHwgcG9pbnRlciBpbnN0YW5jZW9mIGRvbU9iamVjdHMuVG91Y2ggPyAndG91Y2gnIDogJ21vdXNlJztcclxuICB9LFxyXG5cclxuICAvLyBbIGV2ZW50LnRhcmdldCwgZXZlbnQuY3VycmVudFRhcmdldCBdXHJcbiAgZ2V0RXZlbnRUYXJnZXRzOiBmdW5jdGlvbiBnZXRFdmVudFRhcmdldHMoZXZlbnQpIHtcclxuICAgIHJldHVybiBbZG9tVXRpbHMuZ2V0QWN0dWFsRWxlbWVudChldmVudC5wYXRoID8gZXZlbnQucGF0aFswXSA6IGV2ZW50LnRhcmdldCksIGRvbVV0aWxzLmdldEFjdHVhbEVsZW1lbnQoZXZlbnQuY3VycmVudFRhcmdldCldO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcG9pbnRlclV0aWxzO1xyXG5cclxufSx7XCIuL2Jyb3dzZXJcIjozNyxcIi4vZG9tT2JqZWN0c1wiOjM4LFwiLi9kb21VdGlsc1wiOjM5LFwiLi9oeXBvdFwiOjQzLFwiLi9pc1wiOjQ2LFwiLi9wb2ludGVyRXh0ZW5kXCI6NDh9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vd2luZG93JyksXHJcbiAgICB3aW5kb3cgPSBfcmVxdWlyZS53aW5kb3c7XHJcblxyXG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcbnZhciBsYXN0VGltZSA9IDA7XHJcbnZhciByZXF1ZXN0ID0gdm9pZCAwO1xyXG52YXIgY2FuY2VsID0gdm9pZCAwO1xyXG5cclxuZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgeCsrKSB7XHJcbiAgcmVxdWVzdCA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIGNhbmNlbCA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcbn1cclxuXHJcbmlmICghcmVxdWVzdCkge1xyXG4gIHJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xyXG4gICAgdmFyIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICB9LCB0aW1lVG9DYWxsKTtcclxuXHJcbiAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgIHJldHVybiBpZDtcclxuICB9O1xyXG59XHJcblxyXG5pZiAoIWNhbmNlbCkge1xyXG4gIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbChpZCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICByZXF1ZXN0OiByZXF1ZXN0LFxyXG4gIGNhbmNlbDogY2FuY2VsXHJcbn07XHJcblxyXG59LHtcIi4vd2luZG93XCI6NTJ9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xyXG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2RvbVV0aWxzJyksXHJcbiAgICBjbG9zZXN0ID0gX3JlcXVpcmUuY2xvc2VzdCxcclxuICAgIHBhcmVudE5vZGUgPSBfcmVxdWlyZS5wYXJlbnROb2RlLFxyXG4gICAgZ2V0RWxlbWVudFJlY3QgPSBfcmVxdWlyZS5nZXRFbGVtZW50UmVjdDtcclxuXHJcbnZhciByZWN0VXRpbHMgPSB7XHJcbiAgZ2V0U3RyaW5nT3B0aW9uUmVzdWx0OiBmdW5jdGlvbiBnZXRTdHJpbmdPcHRpb25SZXN1bHQodmFsdWUsIGludGVyYWN0YWJsZSwgZWxlbWVudCkge1xyXG4gICAgaWYgKCFpcy5zdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgdmFsdWUgPSBwYXJlbnROb2RlKGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3NlbGYnKSB7XHJcbiAgICAgIHZhbHVlID0gaW50ZXJhY3RhYmxlLmdldFJlY3QoZWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZSA9IGNsb3Nlc3QoZWxlbWVudCwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9LFxyXG5cclxuICByZXNvbHZlUmVjdExpa2U6IGZ1bmN0aW9uIHJlc29sdmVSZWN0TGlrZSh2YWx1ZSwgaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBmdW5jdGlvbkFyZ3MpIHtcclxuICAgIHZhbHVlID0gcmVjdFV0aWxzLmdldFN0cmluZ09wdGlvblJlc3VsdCh2YWx1ZSwgaW50ZXJhY3RhYmxlLCBlbGVtZW50KSB8fCB2YWx1ZTtcclxuXHJcbiAgICBpZiAoaXMuZnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkobnVsbCwgZnVuY3Rpb25BcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXMuZWxlbWVudCh2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSBnZXRFbGVtZW50UmVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH0sXHJcblxyXG4gIHJlY3RUb1hZOiBmdW5jdGlvbiByZWN0VG9YWShyZWN0KSB7XHJcbiAgICByZXR1cm4gcmVjdCAmJiB7XHJcbiAgICAgIHg6ICd4JyBpbiByZWN0ID8gcmVjdC54IDogcmVjdC5sZWZ0LFxyXG4gICAgICB5OiAneScgaW4gcmVjdCA/IHJlY3QueSA6IHJlY3QudG9wXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHh5d2hUb1RsYnI6IGZ1bmN0aW9uIHh5d2hUb1RsYnIocmVjdCkge1xyXG4gICAgaWYgKHJlY3QgJiYgISgnbGVmdCcgaW4gcmVjdCAmJiAndG9wJyBpbiByZWN0KSkge1xyXG4gICAgICByZWN0ID0gZXh0ZW5kKHt9LCByZWN0KTtcclxuXHJcbiAgICAgIHJlY3QubGVmdCA9IHJlY3QueCB8fCAwO1xyXG4gICAgICByZWN0LnRvcCA9IHJlY3QueSB8fCAwO1xyXG4gICAgICByZWN0LnJpZ2h0ID0gcmVjdC5yaWdodCB8fCByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xyXG4gICAgICByZWN0LmJvdHRvbSA9IHJlY3QuYm90dG9tIHx8IHJlY3QudG9wICsgcmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbiAgfSxcclxuXHJcbiAgdGxiclRvWHl3aDogZnVuY3Rpb24gdGxiclRvWHl3aChyZWN0KSB7XHJcbiAgICBpZiAocmVjdCAmJiAhKCd4JyBpbiByZWN0ICYmICd5JyBpbiByZWN0KSkge1xyXG4gICAgICByZWN0ID0gZXh0ZW5kKHt9LCByZWN0KTtcclxuXHJcbiAgICAgIHJlY3QueCA9IHJlY3QubGVmdCB8fCAwO1xyXG4gICAgICByZWN0LnRvcCA9IHJlY3QudG9wIHx8IDA7XHJcbiAgICAgIHJlY3Qud2lkdGggPSByZWN0LndpZHRoIHx8IHJlY3QucmlnaHQgLSByZWN0Lng7XHJcbiAgICAgIHJlY3QuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgfHwgcmVjdC5ib3R0b20gLSByZWN0Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZWN0VXRpbHM7XHJcblxyXG59LHtcIi4vZG9tVXRpbHNcIjozOSxcIi4vZXh0ZW5kXCI6NDEsXCIuL2lzXCI6NDZ9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB3aW4gPSBtb2R1bGUuZXhwb3J0cztcclxudmFyIGlzV2luZG93ID0gcmVxdWlyZSgnLi9pc1dpbmRvdycpO1xyXG5cclxuZnVuY3Rpb24gaW5pdCh3aW5kb3cpIHtcclxuICAvLyBnZXQgd3JhcHBlZCB3aW5kb3cgaWYgdXNpbmcgU2hhZG93IERPTSBwb2x5ZmlsbFxyXG5cclxuICB3aW4ucmVhbFdpbmRvdyA9IHdpbmRvdztcclxuXHJcbiAgLy8gY3JlYXRlIGEgVGV4dE5vZGVcclxuICB2YXIgZWwgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xyXG5cclxuICAvLyBjaGVjayBpZiBpdCdzIHdyYXBwZWQgYnkgYSBwb2x5ZmlsbFxyXG4gIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSB3aW5kb3cuZG9jdW1lbnQgJiYgdHlwZW9mIHdpbmRvdy53cmFwID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy53cmFwKGVsKSA9PT0gZWwpIHtcclxuICAgIC8vIHVzZSB3cmFwcGVkIHdpbmRvd1xyXG4gICAgd2luZG93ID0gd2luZG93LndyYXAod2luZG93KTtcclxuICB9XHJcblxyXG4gIHdpbi53aW5kb3cgPSB3aW5kb3c7XHJcbn1cclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gIHdpbi53aW5kb3cgPSB1bmRlZmluZWQ7XHJcbiAgd2luLnJlYWxXaW5kb3cgPSB1bmRlZmluZWQ7XHJcbn0gZWxzZSB7XHJcbiAgaW5pdCh3aW5kb3cpO1xyXG59XHJcblxyXG53aW4uZ2V0V2luZG93ID0gZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcclxuICBpZiAoaXNXaW5kb3cobm9kZSkpIHtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJvb3ROb2RlID0gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGU7XHJcblxyXG4gIHJldHVybiByb290Tm9kZS5kZWZhdWx0VmlldyB8fCByb290Tm9kZS5wYXJlbnRXaW5kb3cgfHwgd2luLndpbmRvdztcclxufTtcclxuXHJcbndpbi5pbml0ID0gaW5pdDtcclxuXHJcbn0se1wiLi9pc1dpbmRvd1wiOjQ3fV19LHt9LFsxXSkoMSlcclxufSk7XHJcblxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3QuanMubWFwXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludGVyYWN0anMvZGlzdC9pbnRlcmFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"item\",\n    staticClass: \"vue-grid-item\",\n    class: {\n      'vue-resizable': _vm.resizable, 'resizing': _vm.isResizing, 'vue-draggable-dragging': _vm.isDragging, 'cssTransforms': _vm.useCssTransforms, 'render-rtl': _vm.renderRtl\n    },\n    style: (_vm.style)\n  }, [_vm._t(\"default\"), _vm._v(\" \"), (_vm.resizable) ? _c('span', {\n    ref: \"handle\",\n    class: _vm.resizableHandleClass\n  }) : _vm._e()], 2)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZEl0ZW0udnVlPzEyMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHJlZjogXCJpdGVtXCIsXG4gICAgc3RhdGljQ2xhc3M6IFwidnVlLWdyaWQtaXRlbVwiLFxuICAgIGNsYXNzOiB7XG4gICAgICAndnVlLXJlc2l6YWJsZSc6IF92bS5yZXNpemFibGUsICdyZXNpemluZyc6IF92bS5pc1Jlc2l6aW5nLCAndnVlLWRyYWdnYWJsZS1kcmFnZ2luZyc6IF92bS5pc0RyYWdnaW5nLCAnY3NzVHJhbnNmb3Jtcyc6IF92bS51c2VDc3NUcmFuc2Zvcm1zLCAncmVuZGVyLXJ0bCc6IF92bS5yZW5kZXJSdGxcbiAgICB9LFxuICAgIHN0eWxlOiAoX3ZtLnN0eWxlKVxuICB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5yZXNpemFibGUpID8gX2MoJ3NwYW4nLCB7XG4gICAgcmVmOiBcImhhbmRsZVwiLFxuICAgIGNsYXNzOiBfdm0ucmVzaXphYmxlSGFuZGxlQ2xhc3NcbiAgfSkgOiBfdm0uX2UoKV0sIDIpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mMmVmOWNkMlwifSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvR3JpZEl0ZW0udnVlXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(25)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(27),\n  /* template */\n  __webpack_require__(39),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZExheW91dC52dWU/OGFiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQSxzQkFBbU07O0FBRW5NO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP21pbmltaXplIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTNkNGJiOWE0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9HcmlkTGF5b3V0LnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9HcmlkTGF5b3V0LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2Q0YmI5YTRcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vR3JpZExheW91dC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0dyaWRMYXlvdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(26);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1)(\"6c77225e\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZExheW91dC52dWU/OTdkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLG9DQUFvTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9taW5pbWl6ZSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zZDRiYjlhNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vR3JpZExheW91dC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjZjNzcyMjVlXCIsIGNvbnRlbnQsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9taW5pbWl6ZSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNkNGJiOWE0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0dyaWRMYXlvdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)();\n// imports\n\n\n// module\nexports.push([module.i, \".vue-grid-layout{position:relative;transition:height .2s ease}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZExheW91dC52dWU/ZTZkNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLDBDQUEyQyxrQkFBa0IsMkJBQTJCOztBQUV4RiIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi52dWUtZ3JpZC1sYXlvdXR7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjpoZWlnaHQgLjJzIGVhc2V9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9taW5pbWl6ZSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNkNGJiOWE0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0dyaWRMYXlvdXQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _vue = __webpack_require__(4);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _utils = __webpack_require__(7);\n\nvar _GridItem = __webpack_require__(6);\n\nvar _GridItem2 = _interopRequireDefault(_GridItem);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar elementResizeDetectorMaker = __webpack_require__(28); //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n//var eventBus = require('./eventBus');\nexports.default = {\n    name: \"GridLayout\",\n    provide: function provide() {\n        return {\n            eventBus: null\n        };\n    },\n\n    components: {\n        GridItem: _GridItem2.default\n    },\n    props: {\n        // If true, the container height swells and contracts to fit contents\n        autoSize: {\n            type: Boolean,\n            default: true\n        },\n        colNum: {\n            type: Number,\n            default: 12\n        },\n        rowHeight: {\n            type: Number,\n            default: 150\n        },\n        maxRows: {\n            type: Number,\n            default: Infinity\n        },\n        margin: {\n            type: Array,\n            default: function _default() {\n                return [10, 10];\n            }\n        },\n        isDraggable: {\n            type: Boolean,\n            default: true\n        },\n        isResizable: {\n            type: Boolean,\n            default: true\n        },\n        isMirrored: {\n            type: Boolean,\n            default: false\n        },\n        useCssTransforms: {\n            type: Boolean,\n            default: true\n        },\n        verticalCompact: {\n            type: Boolean,\n            default: true\n        },\n        layout: {\n            type: Array,\n            required: true\n        }\n    },\n    data: function data() {\n        return {\n            width: null,\n            mergedStyle: {},\n            lastLayoutLength: 0,\n            isDragging: false,\n            placeholder: {\n                x: 0,\n                y: 0,\n                w: 0,\n                h: 0,\n                i: -1\n            }\n        };\n    },\n    created: function created() {\n        var self = this;\n\n        // Accessible refernces of functions for removing in beforeDestroy\n        self.resizeEventHandler = function (eventType, i, x, y, h, w) {\n            self.resizeEvent(eventType, i, x, y, h, w);\n        };\n\n        self.dragEventHandler = function (eventType, i, x, y, h, w) {\n            self.dragEvent(eventType, i, x, y, h, w);\n        };\n\n        self._provided.eventBus = new _vue2.default();\n        self.eventBus = self._provided.eventBus;\n        self.eventBus.$on('resizeEvent', self.resizeEventHandler);\n        self.eventBus.$on('dragEvent', self.dragEventHandler);\n    },\n\n    beforeDestroy: function beforeDestroy() {\n        //Remove listeners\n        this.eventBus.$off('resizeEvent', self.resizeEventHandler);\n        this.eventBus.$off('dragEvent', self.dragEventHandler);\n        window.removeEventListener(\"resize\", self.onWindowResize);\n    },\n    mounted: function mounted() {\n        this.$nextTick(function () {\n            (0, _utils.validateLayout)(this.layout);\n            var self = this;\n            this.$nextTick(function () {\n                if (self.width === null) {\n                    self.onWindowResize();\n                    //self.width = self.$el.offsetWidth;\n                    window.addEventListener('resize', self.onWindowResize);\n                }\n                (0, _utils.compact)(self.layout, self.verticalCompact);\n\n                self.updateHeight();\n                self.$nextTick(function () {\n                    var erd = elementResizeDetectorMaker({\n                        strategy: \"scroll\" //<- For ultra performance.\n                    });\n                    erd.listenTo(self.$refs.item, function (element) {\n                        self.onWindowResize();\n                    });\n                });\n            });\n            window.onload = function () {\n                if (self.width === null) {\n                    self.onWindowResize();\n                    //self.width = self.$el.offsetWidth;\n                    window.addEventListener('resize', self.onWindowResize);\n                }\n                (0, _utils.compact)(self.layout, self.verticalCompact);\n\n                self.updateHeight();\n                self.$nextTick(function () {\n                    var erd = elementResizeDetectorMaker({\n                        strategy: \"scroll\" //<- For ultra performance.\n                    });\n                    erd.listenTo(self.$refs.item, function (element) {\n                        self.onWindowResize();\n                    });\n                });\n            };\n        });\n    },\n    watch: {\n        width: function width() {\n            this.$nextTick(function () {\n                //this.$broadcast(\"updateWidth\", this.width);\n                this.eventBus.$emit(\"updateWidth\", this.width);\n                this.updateHeight();\n            });\n        },\n        layout: function layout() {\n            this.layoutUpdate();\n        },\n        rowHeight: function rowHeight() {\n            this.eventBus.$emit(\"setRowHeight\", this.rowHeight);\n        },\n        isDraggable: function isDraggable() {\n            this.eventBus.$emit(\"setDraggable\", this.isDraggable);\n        },\n        isResizable: function isResizable() {\n            this.eventBus.$emit(\"setResizable\", this.isResizable);\n        }\n    },\n    methods: {\n        layoutUpdate: function layoutUpdate() {\n            if (this.layout !== undefined) {\n                if (this.layout.length !== this.lastLayoutLength) {\n                    //console.log(\"### LAYOUT UPDATE!\");\n                    this.lastLayoutLength = this.layout.length;\n                }\n                (0, _utils.compact)(this.layout, this.verticalCompact);\n                this.eventBus.$emit(\"updateWidth\", this.width);\n                this.updateHeight();\n            }\n        },\n\n        updateHeight: function updateHeight() {\n            this.mergedStyle = {\n                height: this.containerHeight()\n            };\n        },\n        onWindowResize: function onWindowResize() {\n            if (this.$refs !== null && this.$refs.item !== null && this.$refs.item !== undefined) {\n                this.width = this.$refs.item.offsetWidth;\n            }\n        },\n        containerHeight: function containerHeight() {\n            if (!this.autoSize) return;\n            return (0, _utils.bottom)(this.layout) * (this.rowHeight + this.margin[1]) + this.margin[1] + 'px';\n        },\n        dragEvent: function dragEvent(eventName, id, x, y, h, w) {\n            if (eventName === \"dragmove\" || eventName === \"dragstart\") {\n                this.placeholder.i = id;\n                this.placeholder.x = x;\n                this.placeholder.y = y;\n                this.placeholder.w = w;\n                this.placeholder.h = h;\n                this.$nextTick(function () {\n                    this.isDragging = true;\n                });\n                //this.$broadcast(\"updateWidth\", this.width);\n                this.eventBus.$emit(\"updateWidth\", this.width);\n            } else {\n                this.$nextTick(function () {\n                    this.isDragging = false;\n                });\n            }\n            //console.log(eventName + \" id=\" + id + \", x=\" + x + \", y=\" + y);\n            var l = (0, _utils.getLayoutItem)(this.layout, id);\n            //GetLayoutItem sometimes returns null object\n            if (l === undefined || l === null) {\n                l = { x: 0, y: 0 };\n            }\n            l.x = x;\n            l.y = y;\n            // Move the element to the dragged location.\n            this.layout = (0, _utils.moveElement)(this.layout, l, x, y, true);\n            (0, _utils.compact)(this.layout, this.verticalCompact);\n            // needed because vue can't detect changes on array element properties\n            this.eventBus.$emit(\"compact\");\n            this.updateHeight();\n            if (eventName === 'dragend') this.$emit('layout-updated', this.layout);\n        },\n        resizeEvent: function resizeEvent(eventName, id, x, y, h, w) {\n            if (eventName === \"resizestart\" || eventName === \"resizemove\") {\n                this.placeholder.i = id;\n                this.placeholder.x = x;\n                this.placeholder.y = y;\n                this.placeholder.w = w;\n                this.placeholder.h = h;\n                this.$nextTick(function () {\n                    this.isDragging = true;\n                });\n                //this.$broadcast(\"updateWidth\", this.width);\n                this.eventBus.$emit(\"updateWidth\", this.width);\n            } else {\n                this.$nextTick(function () {\n                    this.isDragging = false;\n                });\n            }\n            var l = (0, _utils.getLayoutItem)(this.layout, id);\n            //GetLayoutItem sometimes return null object\n            if (l === undefined || l === null) {\n                l = { h: 0, w: 0 };\n            }\n            l.h = h;\n            l.w = w;\n            (0, _utils.compact)(this.layout, this.verticalCompact);\n            this.eventBus.$emit(\"compact\");\n            this.updateHeight();\n            if (eventName === 'resizeend') this.$emit('layout-updated', this.layout);\n        }\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vR3JpZExheW91dC52dWU/MTE1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBbUJBOzs7O0FBR0E7O0FBSUE7Ozs7OztBQU5BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7O1VBS0E7Z0NBQ0E7O3NCQUdBO0FBRkE7QUFHQTs7O0FBR0E7QUFGQTs7QUFJQTs7a0JBRUE7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTs7a0JBS0E7cUJBRUE7QUFIQTs7a0JBS0E7eUNBQ0E7NEJBQ0E7QUFFQTtBQUxBOztrQkFPQTtxQkFFQTtBQUhBOztrQkFLQTtxQkFFQTtBQUhBOztrQkFLQTtxQkFFQTtBQUhBOztrQkFLQTtxQkFFQTtBQUhBOztrQkFLQTtxQkFFQTtBQUhBOztrQkFLQTtzQkFHQTtBQUpBO0FBNUNBOzBCQWlEQTs7bUJBRUE7eUJBQ0E7OEJBQ0E7d0JBQ0E7O21CQUVBO21CQUNBO21CQUNBO21CQUNBO29CQUdBO0FBUEE7QUFMQTtBQWFBO2dDQUNBO21CQUVBOztBQUNBO3NFQUNBO29EQUNBO0FBRUE7O29FQUNBO2tEQUNBO0FBRUE7O2tDQUNBO3VDQUNBOzhDQUNBOzRDQUNBO0FBQ0E7OzRDQUNBO0FBQ0E7K0NBQ0E7NkNBQ0E7a0RBQ0E7QUFDQTtnQ0FDQTttQ0FDQTs0Q0FDQTt1QkFDQTt1Q0FDQTt5Q0FDQTt5QkFDQTtBQUNBOzJEQUNBO0FBQ0E7c0RBRUE7O3FCQUNBOzJDQUNBOzsyQ0FHQTtBQUZBO3FFQUdBOzZCQUNBO0FBQ0E7QUFDQTtBQUNBO3dDQUNBO3lDQUNBO3lCQUNBO0FBQ0E7MkRBQ0E7QUFDQTtzREFFQTs7cUJBQ0E7MkNBQ0E7OzJDQUdBO0FBRkE7cUVBR0E7NkJBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztnQ0FFQTt1Q0FDQTtBQUNBO3dEQUNBO3FCQUNBO0FBQ0E7QUFDQTtrQ0FDQTtpQkFDQTtBQUNBO3dDQUNBO3FEQUNBO0FBQ0E7NENBQ0E7cURBQ0E7QUFDQTs0Q0FDQTtxREFDQTtBQUVBO0FBcEJBOzs4Q0FzQkE7MkNBQ0E7a0VBQ0E7QUFDQTt3REFDQTtBQUNBO3NEQUNBO3dEQUNBO3FCQUNBO0FBQ0E7QUFDQTs7OENBQ0E7OzZCQUdBO0FBRkE7QUFHQTtrREFDQTtrR0FDQTs2Q0FDQTtBQUNBO0FBQ0E7b0RBQ0E7Z0NBQ0E7MEdBQ0E7QUFDQTtpRUFDQTt1RUFDQTtxQ0FDQTtxQ0FDQTtxQ0FDQTtxQ0FDQTtxQ0FDQTsyQ0FDQTtzQ0FDQTtBQUNBO0FBQ0E7d0RBQ0E7bUJBQ0E7MkNBQ0E7c0NBQ0E7QUFDQTtBQUNBO0FBQ0E7MkRBQ0E7QUFDQTsrQ0FDQTsrQkFDQTtBQUNBO2tCQUNBO2tCQUNBO0FBQ0E7d0VBQ0E7a0RBQ0E7QUFDQTtnQ0FDQTtpQkFDQTsyRUFDQTtBQUNBO3FFQUNBOzJFQUNBO3FDQUNBO3FDQUNBO3FDQUNBO3FDQUNBO3FDQUNBOzJDQUNBO3NDQUNBO0FBQ0E7QUFDQTt3REFFQTttQkFDQTsyQ0FDQTtzQ0FDQTtBQUNBO0FBQ0E7MkRBQ0E7QUFDQTsrQ0FDQTsrQkFDQTtBQUNBO2tCQUNBO2tCQUNBO2tEQUNBO2dDQUNBO2lCQUNBOzZFQUNBO0FBRUE7QUF6RkE7QUFqS0EiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IHJlZj1cIml0ZW1cIiBjbGFzcz1cInZ1ZS1ncmlkLWxheW91dFwiIDpzdHlsZT1cIm1lcmdlZFN0eWxlXCI+XHJcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgICAgIDxncmlkLWl0ZW0gY2xhc3M9XCJ2dWUtZ3JpZC1wbGFjZWhvbGRlclwiXHJcbiAgICAgICAgICAgICAgICAgICB2LXNob3c9XCJpc0RyYWdnaW5nXCJcclxuICAgICAgICAgICAgICAgICAgIDp4PVwicGxhY2Vob2xkZXIueFwiXHJcbiAgICAgICAgICAgICAgICAgICA6eT1cInBsYWNlaG9sZGVyLnlcIlxyXG4gICAgICAgICAgICAgICAgICAgOnc9XCJwbGFjZWhvbGRlci53XCJcclxuICAgICAgICAgICAgICAgICAgIDpoPVwicGxhY2Vob2xkZXIuaFwiXHJcbiAgICAgICAgICAgICAgICAgICA6aT1cInBsYWNlaG9sZGVyLmlcIj48L2dyaWQtaXRlbT5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c3R5bGU+XHJcbiAgICAudnVlLWdyaWQtbGF5b3V0IHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IDIwMG1zIGVhc2U7XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcbjxzY3JpcHQ+XHJcbiAgICBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbiAgICB2YXIgZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIgPSByZXF1aXJlKFwiZWxlbWVudC1yZXNpemUtZGV0ZWN0b3JcIik7XHJcblxyXG4gICAgaW1wb3J0IHtib3R0b20sIGNvbXBhY3QsIGdldExheW91dEl0ZW0sIG1vdmVFbGVtZW50LCB2YWxpZGF0ZUxheW91dH0gZnJvbSAnLi91dGlscyc7XHJcbiAgICAvL3ZhciBldmVudEJ1cyA9IHJlcXVpcmUoJy4vZXZlbnRCdXMnKTtcclxuICAgIGltcG9ydCBHcmlkSXRlbSBmcm9tICcuL0dyaWRJdGVtLnZ1ZSdcclxuXHJcbiAgICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICAgICAgbmFtZTogXCJHcmlkTGF5b3V0XCIsXHJcbiAgICAgICAgcHJvdmlkZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50QnVzOiBudWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICAgICAgR3JpZEl0ZW0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAvLyBJZiB0cnVlLCB0aGUgY29udGFpbmVyIGhlaWdodCBzd2VsbHMgYW5kIGNvbnRyYWN0cyB0byBmaXQgY29udGVudHNcclxuICAgICAgICAgICAgYXV0b1NpemU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbE51bToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMTJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcm93SGVpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxNTBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF4Um93czoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogSW5maW5pdHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFyZ2luOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzEwLCAxMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1Jlc2l6YWJsZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNNaXJyb3JlZDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZUNzc1RyYW5zZm9ybXM6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHZlcnRpY2FsQ29tcGFjdDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBBcnJheSxcclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtZXJnZWRTdHlsZToge30sXHJcbiAgICAgICAgICAgICAgICBsYXN0TGF5b3V0TGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgICAgICB3OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaTogLTFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVkICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gQWNjZXNzaWJsZSByZWZlcm5jZXMgb2YgZnVuY3Rpb25zIGZvciByZW1vdmluZyBpbiBiZWZvcmVEZXN0cm95XHJcbiAgICAgICAgICAgIHNlbGYucmVzaXplRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBpLCB4LCB5LCBoLCB3KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZUV2ZW50KGV2ZW50VHlwZSwgaSwgeCwgeSwgaCwgdyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBzZWxmLmRyYWdFdmVudEhhbmRsZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGksIHgsIHksIGgsIHcpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuZHJhZ0V2ZW50KGV2ZW50VHlwZSwgaSwgeCwgeSwgaCwgdyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9wcm92aWRlZC5ldmVudEJ1cyA9ICBuZXcgVnVlKCk7XHJcbiAgICAgICAgICAgIHNlbGYuZXZlbnRCdXMgPSBzZWxmLl9wcm92aWRlZC5ldmVudEJ1cztcclxuICAgICAgICAgICAgc2VsZi5ldmVudEJ1cy4kb24oJ3Jlc2l6ZUV2ZW50Jywgc2VsZi5yZXNpemVFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICBzZWxmLmV2ZW50QnVzLiRvbignZHJhZ0V2ZW50Jywgc2VsZi5kcmFnRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8vUmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ3Jlc2l6ZUV2ZW50Jywgc2VsZi5yZXNpemVFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ2RyYWdFdmVudCcsIHNlbGYuZHJhZ0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHNlbGYub25XaW5kb3dSZXNpemUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3VudGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVMYXlvdXQodGhpcy5sYXlvdXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYud2lkdGggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldpbmRvd1Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlbGYud2lkdGggPSBzZWxmLiRlbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYub25XaW5kb3dSZXNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0KHNlbGYubGF5b3V0LCBzZWxmLnZlcnRpY2FsQ29tcGFjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJkID0gZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6IFwic2Nyb2xsXCIgLy88LSBGb3IgdWx0cmEgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcmQubGlzdGVuVG8oc2VsZi4kcmVmcy5pdGVtLCBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbldpbmRvd1Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLndpZHRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25XaW5kb3dSZXNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxmLndpZHRoID0gc2VsZi4kZWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZWxmLm9uV2luZG93UmVzaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdChzZWxmLmxheW91dCwgc2VsZi52ZXJ0aWNhbENvbXBhY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyZCA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBcInNjcm9sbFwiIC8vPC0gRm9yIHVsdHJhIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJkLmxpc3RlblRvKHNlbGYuJHJlZnMuaXRlbSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25XaW5kb3dSZXNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXRjaDoge1xyXG4gICAgICAgICAgICB3aWR0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy4kYnJvYWRjYXN0KFwidXBkYXRlV2lkdGhcIiwgdGhpcy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dFVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByb3dIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInNldFJvd0hlaWdodFwiLCB0aGlzLnJvd0hlaWdodCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJzZXREcmFnZ2FibGVcIiwgdGhpcy5pc0RyYWdnYWJsZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzUmVzaXphYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJzZXRSZXNpemFibGVcIiwgdGhpcy5pc1Jlc2l6YWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgbGF5b3V0VXBkYXRlKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQubGVuZ3RoICE9PSB0aGlzLmxhc3RMYXlvdXRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIiMjIyBMQVlPVVQgVVBEQVRFIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGF5b3V0TGVuZ3RoID0gdGhpcy5sYXlvdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0KHRoaXMubGF5b3V0LCB0aGlzLnZlcnRpY2FsQ29tcGFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZUhlaWdodDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZWRTdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVySGVpZ2h0KClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uV2luZG93UmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kcmVmcyAhPT0gbnVsbCAmJiB0aGlzLiRyZWZzLml0ZW0gIT09IG51bGwgJiYgdGhpcy4kcmVmcy5pdGVtICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy4kcmVmcy5pdGVtLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdXRvU2l6ZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdHRvbSh0aGlzLmxheW91dCkgKiAodGhpcy5yb3dIZWlnaHQgKyB0aGlzLm1hcmdpblsxXSkgKyB0aGlzLm1hcmdpblsxXSArICdweCc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgaWQsIHgsIHksIGgsIHcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZHJhZ21vdmVcIiB8fCBldmVudE5hbWUgPT09IFwiZHJhZ3N0YXJ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmkgPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLnggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIueSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci53ID0gdztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmggPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy4kYnJvYWRjYXN0KFwidXBkYXRlV2lkdGhcIiwgdGhpcy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50TmFtZSArIFwiIGlkPVwiICsgaWQgKyBcIiwgeD1cIiArIHggKyBcIiwgeT1cIiArIHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBnZXRMYXlvdXRJdGVtKHRoaXMubGF5b3V0LCBpZCk7XHJcbiAgICAgICAgICAgICAgICAvL0dldExheW91dEl0ZW0gc29tZXRpbWVzIHJldHVybnMgbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgIGlmIChsID09PSB1bmRlZmluZWQgfHwgbCA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHt4OjAsIHk6MH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGwueCA9IHg7XHJcbiAgICAgICAgICAgICAgICBsLnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCB0byB0aGUgZHJhZ2dlZCBsb2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gbW92ZUVsZW1lbnQodGhpcy5sYXlvdXQsIGwsIHgsIHksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFjdCh0aGlzLmxheW91dCwgdGhpcy52ZXJ0aWNhbENvbXBhY3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJlY2F1c2UgdnVlIGNhbid0IGRldGVjdCBjaGFuZ2VzIG9uIGFycmF5IGVsZW1lbnQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcImNvbXBhY3RcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2RyYWdlbmQnKSB0aGlzLiRlbWl0KCdsYXlvdXQtdXBkYXRlZCcsIHRoaXMubGF5b3V0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzaXplRXZlbnQ6IGZ1bmN0aW9uIChldmVudE5hbWUsIGlkLCB4LCB5LCBoLCB3KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcInJlc2l6ZXN0YXJ0XCIgfHwgZXZlbnROYW1lID09PSBcInJlc2l6ZW1vdmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaSA9IGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIueCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlci55ID0geTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLncgPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaCA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLiRicm9hZGNhc3QoXCJ1cGRhdGVXaWR0aFwiLCB0aGlzLndpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLiRlbWl0KFwidXBkYXRlV2lkdGhcIiwgdGhpcy53aWR0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGdldExheW91dEl0ZW0odGhpcy5sYXlvdXQsIGlkKTtcclxuICAgICAgICAgICAgICAgIC8vR2V0TGF5b3V0SXRlbSBzb21ldGltZXMgcmV0dXJuIG51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBpZiAobCA9PT0gdW5kZWZpbmVkIHx8IGwgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSB7aDowLCB3OjB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsLmggPSBoO1xyXG4gICAgICAgICAgICAgICAgbC53ID0gdztcclxuICAgICAgICAgICAgICAgIGNvbXBhY3QodGhpcy5sYXlvdXQsIHRoaXMudmVydGljYWxDb21wYWN0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJjb21wYWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyZXNpemVlbmQnKSB0aGlzLiRlbWl0KCdsYXlvdXQtdXBkYXRlZCcsIHRoaXMubGF5b3V0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEdyaWRMYXlvdXQudnVlPzM0NzBmMzMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar forEach                 = __webpack_require__(8).forEach;\nvar elementUtilsMaker       = __webpack_require__(29);\nvar listenerHandlerMaker    = __webpack_require__(30);\nvar idGeneratorMaker        = __webpack_require__(31);\nvar idHandlerMaker          = __webpack_require__(32);\nvar reporterMaker           = __webpack_require__(33);\nvar browserDetector         = __webpack_require__(9);\nvar batchProcessorMaker     = __webpack_require__(34);\nvar stateHandler            = __webpack_require__(36);\n\n//Detection strategies.\nvar objectStrategyMaker     = __webpack_require__(37);\nvar scrollStrategyMaker     = __webpack_require__(38);\n\nfunction isCollection(obj) {\n    return Array.isArray(obj) || obj.length !== undefined;\n}\n\nfunction toArray(collection) {\n    if (!Array.isArray(collection)) {\n        var array = [];\n        forEach(collection, function (obj) {\n            array.push(obj);\n        });\n        return array;\n    } else {\n        return collection;\n    }\n}\n\nfunction isElement(obj) {\n    return obj && obj.nodeType === 1;\n}\n\n/**\n * @typedef idHandler\n * @type {object}\n * @property {function} get Gets the resize detector id of the element.\n * @property {function} set Generate and sets the resize detector id of the element.\n */\n\n/**\n * @typedef Options\n * @type {object}\n * @property {boolean} callOnAdd    Determines if listeners should be called when they are getting added.\n                                    Default is true. If true, the listener is guaranteed to be called when it has been added.\n                                    If false, the listener will not be guarenteed to be called when it has been added (does not prevent it from being called).\n * @property {idHandler} idHandler  A custom id handler that is responsible for generating, setting and retrieving id's for elements.\n                                    If not provided, a default id handler will be used.\n * @property {reporter} reporter    A custom reporter that handles reporting logs, warnings and errors.\n                                    If not provided, a default id handler will be used.\n                                    If set to false, then nothing will be reported.\n * @property {boolean} debug        If set to true, the the system will report debug messages as default for the listenTo method.\n */\n\n/**\n * Creates an element resize detector instance.\n * @public\n * @param {Options?} options Optional global options object that will decide how this instance will work.\n */\nmodule.exports = function(options) {\n    options = options || {};\n\n    //idHandler is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var idHandler;\n\n    if (options.idHandler) {\n        // To maintain compatability with idHandler.get(element, readonly), make sure to wrap the given idHandler\n        // so that readonly flag always is true when it's used here. This may be removed next major version bump.\n        idHandler = {\n            get: function (element) { return options.idHandler.get(element, true); },\n            set: options.idHandler.set\n        };\n    } else {\n        var idGenerator = idGeneratorMaker();\n        var defaultIdHandler = idHandlerMaker({\n            idGenerator: idGenerator,\n            stateHandler: stateHandler\n        });\n        idHandler = defaultIdHandler;\n    }\n\n    //reporter is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var reporter = options.reporter;\n\n    if(!reporter) {\n        //If options.reporter is false, then the reporter should be quiet.\n        var quiet = reporter === false;\n        reporter = reporterMaker(quiet);\n    }\n\n    //batchProcessor is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var batchProcessor = getOption(options, \"batchProcessor\", batchProcessorMaker({ reporter: reporter }));\n\n    //Options to be used as default for the listenTo function.\n    var globalOptions = {};\n    globalOptions.callOnAdd     = !!getOption(options, \"callOnAdd\", true);\n    globalOptions.debug         = !!getOption(options, \"debug\", false);\n\n    var eventListenerHandler    = listenerHandlerMaker(idHandler);\n    var elementUtils            = elementUtilsMaker({\n        stateHandler: stateHandler\n    });\n\n    //The detection strategy to be used.\n    var detectionStrategy;\n    var desiredStrategy = getOption(options, \"strategy\", \"object\");\n    var strategyOptions = {\n        reporter: reporter,\n        batchProcessor: batchProcessor,\n        stateHandler: stateHandler,\n        idHandler: idHandler\n    };\n\n    if(desiredStrategy === \"scroll\") {\n        if (browserDetector.isLegacyOpera()) {\n            reporter.warn(\"Scroll strategy is not supported on legacy Opera. Changing to object strategy.\");\n            desiredStrategy = \"object\";\n        } else if (browserDetector.isIE(9)) {\n            reporter.warn(\"Scroll strategy is not supported on IE9. Changing to object strategy.\");\n            desiredStrategy = \"object\";\n        }\n    }\n\n    if(desiredStrategy === \"scroll\") {\n        detectionStrategy = scrollStrategyMaker(strategyOptions);\n    } else if(desiredStrategy === \"object\") {\n        detectionStrategy = objectStrategyMaker(strategyOptions);\n    } else {\n        throw new Error(\"Invalid strategy name: \" + desiredStrategy);\n    }\n\n    //Calls can be made to listenTo with elements that are still being installed.\n    //Also, same elements can occur in the elements list in the listenTo function.\n    //With this map, the ready callbacks can be synchronized between the calls\n    //so that the ready callback can always be called when an element is ready - even if\n    //it wasn't installed from the function itself.\n    var onReadyCallbacks = {};\n\n    /**\n     * Makes the given elements resize-detectable and starts listening to resize events on the elements. Calls the event callback for each event for each element.\n     * @public\n     * @param {Options?} options Optional options object. These options will override the global options. Some options may not be overriden, such as idHandler.\n     * @param {element[]|element} elements The given array of elements to detect resize events of. Single element is also valid.\n     * @param {function} listener The callback to be executed for each resize event for each element.\n     */\n    function listenTo(options, elements, listener) {\n        function onResizeCallback(element) {\n            var listeners = eventListenerHandler.get(element);\n            forEach(listeners, function callListenerProxy(listener) {\n                listener(element);\n            });\n        }\n\n        function addListener(callOnAdd, element, listener) {\n            eventListenerHandler.add(element, listener);\n\n            if(callOnAdd) {\n                listener(element);\n            }\n        }\n\n        //Options object may be omitted.\n        if(!listener) {\n            listener = elements;\n            elements = options;\n            options = {};\n        }\n\n        if(!elements) {\n            throw new Error(\"At least one element required.\");\n        }\n\n        if(!listener) {\n            throw new Error(\"Listener required.\");\n        }\n\n        if (isElement(elements)) {\n            // A single element has been passed in.\n            elements = [elements];\n        } else if (isCollection(elements)) {\n            // Convert collection to array for plugins.\n            // TODO: May want to check so that all the elements in the collection are valid elements.\n            elements = toArray(elements);\n        } else {\n            return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n\n        var elementsReady = 0;\n\n        var callOnAdd = getOption(options, \"callOnAdd\", globalOptions.callOnAdd);\n        var onReadyCallback = getOption(options, \"onReady\", function noop() {});\n        var debug = getOption(options, \"debug\", globalOptions.debug);\n\n        forEach(elements, function attachListenerToElement(element) {\n            if (!stateHandler.getState(element)) {\n                stateHandler.initState(element);\n                idHandler.set(element);\n            }\n\n            var id = idHandler.get(element);\n\n            debug && reporter.log(\"Attaching listener to element\", id, element);\n\n            if(!elementUtils.isDetectable(element)) {\n                debug && reporter.log(id, \"Not detectable.\");\n                if(elementUtils.isBusy(element)) {\n                    debug && reporter.log(id, \"System busy making it detectable\");\n\n                    //The element is being prepared to be detectable. Do not make it detectable.\n                    //Just add the listener, because the element will soon be detectable.\n                    addListener(callOnAdd, element, listener);\n                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];\n                    onReadyCallbacks[id].push(function onReady() {\n                        elementsReady++;\n\n                        if(elementsReady === elements.length) {\n                            onReadyCallback();\n                        }\n                    });\n                    return;\n                }\n\n                debug && reporter.log(id, \"Making detectable...\");\n                //The element is not prepared to be detectable, so do prepare it and add a listener to it.\n                elementUtils.markBusy(element, true);\n                return detectionStrategy.makeDetectable({ debug: debug }, element, function onElementDetectable(element) {\n                    debug && reporter.log(id, \"onElementDetectable\");\n\n                    if (stateHandler.getState(element)) {\n                        elementUtils.markAsDetectable(element);\n                        elementUtils.markBusy(element, false);\n                        detectionStrategy.addListener(element, onResizeCallback);\n                        addListener(callOnAdd, element, listener);\n\n                        // Since the element size might have changed since the call to \"listenTo\", we need to check for this change,\n                        // so that a resize event may be emitted.\n                        // Having the startSize object is optional (since it does not make sense in some cases such as unrendered elements), so check for its existance before.\n                        // Also, check the state existance before since the element may have been uninstalled in the installation process.\n                        var state = stateHandler.getState(element);\n                        if (state && state.startSize) {\n                            var width = element.offsetWidth;\n                            var height = element.offsetHeight;\n                            if (state.startSize.width !== width || state.startSize.height !== height) {\n                                onResizeCallback(element);\n                            }\n                        }\n\n                        if(onReadyCallbacks[id]) {\n                            forEach(onReadyCallbacks[id], function(callback) {\n                                callback();\n                            });\n                        }\n                    } else {\n                        // The element has been unisntalled before being detectable.\n                        debug && reporter.log(id, \"Element uninstalled before being detectable.\");\n                    }\n\n                    delete onReadyCallbacks[id];\n\n                    elementsReady++;\n                    if(elementsReady === elements.length) {\n                        onReadyCallback();\n                    }\n                });\n            }\n\n            debug && reporter.log(id, \"Already detecable, adding listener.\");\n\n            //The element has been prepared to be detectable and is ready to be listened to.\n            addListener(callOnAdd, element, listener);\n            elementsReady++;\n        });\n\n        if(elementsReady === elements.length) {\n            onReadyCallback();\n        }\n    }\n\n    function uninstall(elements) {\n        if(!elements) {\n            return reporter.error(\"At least one element is required.\");\n        }\n\n        if (isElement(elements)) {\n            // A single element has been passed in.\n            elements = [elements];\n        } else if (isCollection(elements)) {\n            // Convert collection to array for plugins.\n            // TODO: May want to check so that all the elements in the collection are valid elements.\n            elements = toArray(elements);\n        } else {\n            return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n\n        forEach(elements, function (element) {\n            eventListenerHandler.removeAllListeners(element);\n            detectionStrategy.uninstall(element);\n            stateHandler.cleanState(element);\n        });\n    }\n\n    return {\n        listenTo: listenTo,\n        removeListener: eventListenerHandler.removeListener,\n        removeAllListeners: eventListenerHandler.removeAllListeners,\n        uninstall: uninstall\n    };\n};\n\nfunction getOption(options, name, defaultValue) {\n    var value = options[name];\n\n    if((value === undefined || value === null) && defaultValue !== undefined) {\n        return defaultValue;\n    }\n\n    return value;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLmpzP2JhNGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZDQUE2QyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUYscUJBQXFCOztBQUV4RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yRWFjaCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9jb2xsZWN0aW9uLXV0aWxzXCIpLmZvckVhY2g7XG52YXIgZWxlbWVudFV0aWxzTWFrZXIgICAgICAgPSByZXF1aXJlKFwiLi9lbGVtZW50LXV0aWxzXCIpO1xudmFyIGxpc3RlbmVySGFuZGxlck1ha2VyICAgID0gcmVxdWlyZShcIi4vbGlzdGVuZXItaGFuZGxlclwiKTtcbnZhciBpZEdlbmVyYXRvck1ha2VyICAgICAgICA9IHJlcXVpcmUoXCIuL2lkLWdlbmVyYXRvclwiKTtcbnZhciBpZEhhbmRsZXJNYWtlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2lkLWhhbmRsZXJcIik7XG52YXIgcmVwb3J0ZXJNYWtlciAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yZXBvcnRlclwiKTtcbnZhciBicm93c2VyRGV0ZWN0b3IgICAgICAgICA9IHJlcXVpcmUoXCIuL2Jyb3dzZXItZGV0ZWN0b3JcIik7XG52YXIgYmF0Y2hQcm9jZXNzb3JNYWtlciAgICAgPSByZXF1aXJlKFwiYmF0Y2gtcHJvY2Vzc29yXCIpO1xudmFyIHN0YXRlSGFuZGxlciAgICAgICAgICAgID0gcmVxdWlyZShcIi4vc3RhdGUtaGFuZGxlclwiKTtcblxuLy9EZXRlY3Rpb24gc3RyYXRlZ2llcy5cbnZhciBvYmplY3RTdHJhdGVneU1ha2VyICAgICA9IHJlcXVpcmUoXCIuL2RldGVjdGlvbi1zdHJhdGVneS9vYmplY3QuanNcIik7XG52YXIgc2Nyb2xsU3RyYXRlZ3lNYWtlciAgICAgPSByZXF1aXJlKFwiLi9kZXRlY3Rpb24tc3RyYXRlZ3kvc2Nyb2xsLmpzXCIpO1xuXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fCBvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgaWRIYW5kbGVyXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZ2V0IEdldHMgdGhlIHJlc2l6ZSBkZXRlY3RvciBpZCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHNldCBHZW5lcmF0ZSBhbmQgc2V0cyB0aGUgcmVzaXplIGRldGVjdG9yIGlkIG9mIHRoZSBlbGVtZW50LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FsbE9uQWRkICAgIERldGVybWluZXMgaWYgbGlzdGVuZXJzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGV5IGFyZSBnZXR0aW5nIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyB0cnVlLiBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgaXMgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgd2hlbiBpdCBoYXMgYmVlbiBhZGRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGZhbHNlLCB0aGUgbGlzdGVuZXIgd2lsbCBub3QgYmUgZ3VhcmVudGVlZCB0byBiZSBjYWxsZWQgd2hlbiBpdCBoYXMgYmVlbiBhZGRlZCAoZG9lcyBub3QgcHJldmVudCBpdCBmcm9tIGJlaW5nIGNhbGxlZCkuXG4gKiBAcHJvcGVydHkge2lkSGFuZGxlcn0gaWRIYW5kbGVyICBBIGN1c3RvbSBpZCBoYW5kbGVyIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcsIHNldHRpbmcgYW5kIHJldHJpZXZpbmcgaWQncyBmb3IgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBpZCBoYW5kbGVyIHdpbGwgYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7cmVwb3J0ZXJ9IHJlcG9ydGVyICAgIEEgY3VzdG9tIHJlcG9ydGVyIHRoYXQgaGFuZGxlcyByZXBvcnRpbmcgbG9ncywgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGlkIGhhbmRsZXIgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgc2V0IHRvIGZhbHNlLCB0aGVuIG5vdGhpbmcgd2lsbCBiZSByZXBvcnRlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGVidWcgICAgICAgIElmIHNldCB0byB0cnVlLCB0aGUgdGhlIHN5c3RlbSB3aWxsIHJlcG9ydCBkZWJ1ZyBtZXNzYWdlcyBhcyBkZWZhdWx0IGZvciB0aGUgbGlzdGVuVG8gbWV0aG9kLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IHJlc2l6ZSBkZXRlY3RvciBpbnN0YW5jZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T3B0aW9ucz99IG9wdGlvbnMgT3B0aW9uYWwgZ2xvYmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgd2lsbCBkZWNpZGUgaG93IHRoaXMgaW5zdGFuY2Ugd2lsbCB3b3JrLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vaWRIYW5kbGVyIGlzIGN1cnJlbnRseSBub3QgYW4gb3B0aW9uIHRvIHRoZSBsaXN0ZW5UbyBmdW5jdGlvbiwgc28gaXQgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBnbG9iYWxPcHRpb25zLlxuICAgIHZhciBpZEhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5pZEhhbmRsZXIpIHtcbiAgICAgICAgLy8gVG8gbWFpbnRhaW4gY29tcGF0YWJpbGl0eSB3aXRoIGlkSGFuZGxlci5nZXQoZWxlbWVudCwgcmVhZG9ubHkpLCBtYWtlIHN1cmUgdG8gd3JhcCB0aGUgZ2l2ZW4gaWRIYW5kbGVyXG4gICAgICAgIC8vIHNvIHRoYXQgcmVhZG9ubHkgZmxhZyBhbHdheXMgaXMgdHJ1ZSB3aGVuIGl0J3MgdXNlZCBoZXJlLiBUaGlzIG1heSBiZSByZW1vdmVkIG5leHQgbWFqb3IgdmVyc2lvbiBidW1wLlxuICAgICAgICBpZEhhbmRsZXIgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBvcHRpb25zLmlkSGFuZGxlci5nZXQoZWxlbWVudCwgdHJ1ZSk7IH0sXG4gICAgICAgICAgICBzZXQ6IG9wdGlvbnMuaWRIYW5kbGVyLnNldFxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZEdlbmVyYXRvciA9IGlkR2VuZXJhdG9yTWFrZXIoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRJZEhhbmRsZXIgPSBpZEhhbmRsZXJNYWtlcih7XG4gICAgICAgICAgICBpZEdlbmVyYXRvcjogaWRHZW5lcmF0b3IsXG4gICAgICAgICAgICBzdGF0ZUhhbmRsZXI6IHN0YXRlSGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgICAgaWRIYW5kbGVyID0gZGVmYXVsdElkSGFuZGxlcjtcbiAgICB9XG5cbiAgICAvL3JlcG9ydGVyIGlzIGN1cnJlbnRseSBub3QgYW4gb3B0aW9uIHRvIHRoZSBsaXN0ZW5UbyBmdW5jdGlvbiwgc28gaXQgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBnbG9iYWxPcHRpb25zLlxuICAgIHZhciByZXBvcnRlciA9IG9wdGlvbnMucmVwb3J0ZXI7XG5cbiAgICBpZighcmVwb3J0ZXIpIHtcbiAgICAgICAgLy9JZiBvcHRpb25zLnJlcG9ydGVyIGlzIGZhbHNlLCB0aGVuIHRoZSByZXBvcnRlciBzaG91bGQgYmUgcXVpZXQuXG4gICAgICAgIHZhciBxdWlldCA9IHJlcG9ydGVyID09PSBmYWxzZTtcbiAgICAgICAgcmVwb3J0ZXIgPSByZXBvcnRlck1ha2VyKHF1aWV0KTtcbiAgICB9XG5cbiAgICAvL2JhdGNoUHJvY2Vzc29yIGlzIGN1cnJlbnRseSBub3QgYW4gb3B0aW9uIHRvIHRoZSBsaXN0ZW5UbyBmdW5jdGlvbiwgc28gaXQgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBnbG9iYWxPcHRpb25zLlxuICAgIHZhciBiYXRjaFByb2Nlc3NvciA9IGdldE9wdGlvbihvcHRpb25zLCBcImJhdGNoUHJvY2Vzc29yXCIsIGJhdGNoUHJvY2Vzc29yTWFrZXIoeyByZXBvcnRlcjogcmVwb3J0ZXIgfSkpO1xuXG4gICAgLy9PcHRpb25zIHRvIGJlIHVzZWQgYXMgZGVmYXVsdCBmb3IgdGhlIGxpc3RlblRvIGZ1bmN0aW9uLlxuICAgIHZhciBnbG9iYWxPcHRpb25zID0ge307XG4gICAgZ2xvYmFsT3B0aW9ucy5jYWxsT25BZGQgICAgID0gISFnZXRPcHRpb24ob3B0aW9ucywgXCJjYWxsT25BZGRcIiwgdHJ1ZSk7XG4gICAgZ2xvYmFsT3B0aW9ucy5kZWJ1ZyAgICAgICAgID0gISFnZXRPcHRpb24ob3B0aW9ucywgXCJkZWJ1Z1wiLCBmYWxzZSk7XG5cbiAgICB2YXIgZXZlbnRMaXN0ZW5lckhhbmRsZXIgICAgPSBsaXN0ZW5lckhhbmRsZXJNYWtlcihpZEhhbmRsZXIpO1xuICAgIHZhciBlbGVtZW50VXRpbHMgICAgICAgICAgICA9IGVsZW1lbnRVdGlsc01ha2VyKHtcbiAgICAgICAgc3RhdGVIYW5kbGVyOiBzdGF0ZUhhbmRsZXJcbiAgICB9KTtcblxuICAgIC8vVGhlIGRldGVjdGlvbiBzdHJhdGVneSB0byBiZSB1c2VkLlxuICAgIHZhciBkZXRlY3Rpb25TdHJhdGVneTtcbiAgICB2YXIgZGVzaXJlZFN0cmF0ZWd5ID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwic3RyYXRlZ3lcIiwgXCJvYmplY3RcIik7XG4gICAgdmFyIHN0cmF0ZWd5T3B0aW9ucyA9IHtcbiAgICAgICAgcmVwb3J0ZXI6IHJlcG9ydGVyLFxuICAgICAgICBiYXRjaFByb2Nlc3NvcjogYmF0Y2hQcm9jZXNzb3IsXG4gICAgICAgIHN0YXRlSGFuZGxlcjogc3RhdGVIYW5kbGVyLFxuICAgICAgICBpZEhhbmRsZXI6IGlkSGFuZGxlclxuICAgIH07XG5cbiAgICBpZihkZXNpcmVkU3RyYXRlZ3kgPT09IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRlY3Rvci5pc0xlZ2FjeU9wZXJhKCkpIHtcbiAgICAgICAgICAgIHJlcG9ydGVyLndhcm4oXCJTY3JvbGwgc3RyYXRlZ3kgaXMgbm90IHN1cHBvcnRlZCBvbiBsZWdhY3kgT3BlcmEuIENoYW5naW5nIHRvIG9iamVjdCBzdHJhdGVneS5cIik7XG4gICAgICAgICAgICBkZXNpcmVkU3RyYXRlZ3kgPSBcIm9iamVjdFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRlY3Rvci5pc0lFKDkpKSB7XG4gICAgICAgICAgICByZXBvcnRlci53YXJuKFwiU2Nyb2xsIHN0cmF0ZWd5IGlzIG5vdCBzdXBwb3J0ZWQgb24gSUU5LiBDaGFuZ2luZyB0byBvYmplY3Qgc3RyYXRlZ3kuXCIpO1xuICAgICAgICAgICAgZGVzaXJlZFN0cmF0ZWd5ID0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlc2lyZWRTdHJhdGVneSA9PT0gXCJzY3JvbGxcIikge1xuICAgICAgICBkZXRlY3Rpb25TdHJhdGVneSA9IHNjcm9sbFN0cmF0ZWd5TWFrZXIoc3RyYXRlZ3lPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYoZGVzaXJlZFN0cmF0ZWd5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRldGVjdGlvblN0cmF0ZWd5ID0gb2JqZWN0U3RyYXRlZ3lNYWtlcihzdHJhdGVneU9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyYXRlZ3kgbmFtZTogXCIgKyBkZXNpcmVkU3RyYXRlZ3kpO1xuICAgIH1cblxuICAgIC8vQ2FsbHMgY2FuIGJlIG1hZGUgdG8gbGlzdGVuVG8gd2l0aCBlbGVtZW50cyB0aGF0IGFyZSBzdGlsbCBiZWluZyBpbnN0YWxsZWQuXG4gICAgLy9BbHNvLCBzYW1lIGVsZW1lbnRzIGNhbiBvY2N1ciBpbiB0aGUgZWxlbWVudHMgbGlzdCBpbiB0aGUgbGlzdGVuVG8gZnVuY3Rpb24uXG4gICAgLy9XaXRoIHRoaXMgbWFwLCB0aGUgcmVhZHkgY2FsbGJhY2tzIGNhbiBiZSBzeW5jaHJvbml6ZWQgYmV0d2VlbiB0aGUgY2FsbHNcbiAgICAvL3NvIHRoYXQgdGhlIHJlYWR5IGNhbGxiYWNrIGNhbiBhbHdheXMgYmUgY2FsbGVkIHdoZW4gYW4gZWxlbWVudCBpcyByZWFkeSAtIGV2ZW4gaWZcbiAgICAvL2l0IHdhc24ndCBpbnN0YWxsZWQgZnJvbSB0aGUgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHZhciBvblJlYWR5Q2FsbGJhY2tzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgZ2l2ZW4gZWxlbWVudHMgcmVzaXplLWRldGVjdGFibGUgYW5kIHN0YXJ0cyBsaXN0ZW5pbmcgdG8gcmVzaXplIGV2ZW50cyBvbiB0aGUgZWxlbWVudHMuIENhbGxzIHRoZSBldmVudCBjYWxsYmFjayBmb3IgZWFjaCBldmVudCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09wdGlvbnM/fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBvcHRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIGdsb2JhbCBvcHRpb25zLiBTb21lIG9wdGlvbnMgbWF5IG5vdCBiZSBvdmVycmlkZW4sIHN1Y2ggYXMgaWRIYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7ZWxlbWVudFtdfGVsZW1lbnR9IGVsZW1lbnRzIFRoZSBnaXZlbiBhcnJheSBvZiBlbGVtZW50cyB0byBkZXRlY3QgcmVzaXplIGV2ZW50cyBvZi4gU2luZ2xlIGVsZW1lbnQgaXMgYWxzbyB2YWxpZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcmVzaXplIGV2ZW50IGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdGVuVG8ob3B0aW9ucywgZWxlbWVudHMsIGxpc3RlbmVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplQ2FsbGJhY2soZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJIYW5kbGVyLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGZvckVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbiBjYWxsTGlzdGVuZXJQcm94eShsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihjYWxsT25BZGQsIGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVySGFuZGxlci5hZGQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICBpZihjYWxsT25BZGQpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vT3B0aW9ucyBvYmplY3QgbWF5IGJlIG9taXR0ZWQuXG4gICAgICAgIGlmKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBlbGVtZW50cztcbiAgICAgICAgICAgIGVsZW1lbnRzID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFlbGVtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGVsZW1lbnQgcmVxdWlyZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXN0ZW5lciByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQSBzaW5nbGUgZWxlbWVudCBoYXMgYmVlbiBwYXNzZWQgaW4uXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBjb2xsZWN0aW9uIHRvIGFycmF5IGZvciBwbHVnaW5zLlxuICAgICAgICAgICAgLy8gVE9ETzogTWF5IHdhbnQgdG8gY2hlY2sgc28gdGhhdCBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGFyZSB2YWxpZCBlbGVtZW50cy5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdG9BcnJheShlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy4gTXVzdCBiZSBhIERPTSBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiBET00gZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzUmVhZHkgPSAwO1xuXG4gICAgICAgIHZhciBjYWxsT25BZGQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJjYWxsT25BZGRcIiwgZ2xvYmFsT3B0aW9ucy5jYWxsT25BZGQpO1xuICAgICAgICB2YXIgb25SZWFkeUNhbGxiYWNrID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwib25SZWFkeVwiLCBmdW5jdGlvbiBub29wKCkge30pO1xuICAgICAgICB2YXIgZGVidWcgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJkZWJ1Z1wiLCBnbG9iYWxPcHRpb25zLmRlYnVnKTtcblxuICAgICAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiBhdHRhY2hMaXN0ZW5lclRvRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlSGFuZGxlci5nZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5pbml0U3RhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWRIYW5kbGVyLnNldChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkID0gaWRIYW5kbGVyLmdldChlbGVtZW50KTtcblxuICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKFwiQXR0YWNoaW5nIGxpc3RlbmVyIHRvIGVsZW1lbnRcIiwgaWQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZighZWxlbWVudFV0aWxzLmlzRGV0ZWN0YWJsZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJOb3QgZGV0ZWN0YWJsZS5cIik7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudFV0aWxzLmlzQnVzeShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyAmJiByZXBvcnRlci5sb2coaWQsIFwiU3lzdGVtIGJ1c3kgbWFraW5nIGl0IGRldGVjdGFibGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGUgZWxlbWVudCBpcyBiZWluZyBwcmVwYXJlZCB0byBiZSBkZXRlY3RhYmxlLiBEbyBub3QgbWFrZSBpdCBkZXRlY3RhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvL0p1c3QgYWRkIHRoZSBsaXN0ZW5lciwgYmVjYXVzZSB0aGUgZWxlbWVudCB3aWxsIHNvb24gYmUgZGV0ZWN0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHlDYWxsYmFja3NbaWRdID0gb25SZWFkeUNhbGxiYWNrc1tpZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHlDYWxsYmFja3NbaWRdLnB1c2goZnVuY3Rpb24gb25SZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUmVhZHkrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudHNSZWFkeSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKGlkLCBcIk1ha2luZyBkZXRlY3RhYmxlLi4uXCIpO1xuICAgICAgICAgICAgICAgIC8vVGhlIGVsZW1lbnQgaXMgbm90IHByZXBhcmVkIHRvIGJlIGRldGVjdGFibGUsIHNvIGRvIHByZXBhcmUgaXQgYW5kIGFkZCBhIGxpc3RlbmVyIHRvIGl0LlxuICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlscy5tYXJrQnVzeShlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0ZWN0aW9uU3RyYXRlZ3kubWFrZURldGVjdGFibGUoeyBkZWJ1ZzogZGVidWcgfSwgZWxlbWVudCwgZnVuY3Rpb24gb25FbGVtZW50RGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJvbkVsZW1lbnREZXRlY3RhYmxlXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlscy5tYXJrQXNEZXRlY3RhYmxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFV0aWxzLm1hcmtCdXN5KGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblN0cmF0ZWd5LmFkZExpc3RlbmVyKGVsZW1lbnQsIG9uUmVzaXplQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBlbGVtZW50IHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBjYWxsIHRvIFwibGlzdGVuVG9cIiwgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGEgcmVzaXplIGV2ZW50IG1heSBiZSBlbWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIHRoZSBzdGFydFNpemUgb2JqZWN0IGlzIG9wdGlvbmFsIChzaW5jZSBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIGluIHNvbWUgY2FzZXMgc3VjaCBhcyB1bnJlbmRlcmVkIGVsZW1lbnRzKSwgc28gY2hlY2sgZm9yIGl0cyBleGlzdGFuY2UgYmVmb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgY2hlY2sgdGhlIHN0YXRlIGV4aXN0YW5jZSBiZWZvcmUgc2luY2UgdGhlIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiB1bmluc3RhbGxlZCBpbiB0aGUgaW5zdGFsbGF0aW9uIHByb2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZUhhbmRsZXIuZ2V0U3RhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuc3RhcnRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXJ0U2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgc3RhdGUuc3RhcnRTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihvblJlYWR5Q2FsbGJhY2tzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gob25SZWFkeUNhbGxiYWNrc1tpZF0sIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBoYXMgYmVlbiB1bmlzbnRhbGxlZCBiZWZvcmUgYmVpbmcgZGV0ZWN0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJFbGVtZW50IHVuaW5zdGFsbGVkIGJlZm9yZSBiZWluZyBkZXRlY3RhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvblJlYWR5Q2FsbGJhY2tzW2lkXTtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1JlYWR5Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnRzUmVhZHkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKGlkLCBcIkFscmVhZHkgZGV0ZWNhYmxlLCBhZGRpbmcgbGlzdGVuZXIuXCIpO1xuXG4gICAgICAgICAgICAvL1RoZSBlbGVtZW50IGhhcyBiZWVuIHByZXBhcmVkIHRvIGJlIGRldGVjdGFibGUgYW5kIGlzIHJlYWR5IHRvIGJlIGxpc3RlbmVkIHRvLlxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBlbGVtZW50c1JlYWR5Kys7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGVsZW1lbnRzUmVhZHkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmluc3RhbGwoZWxlbWVudHMpIHtcbiAgICAgICAgaWYoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJBdCBsZWFzdCBvbmUgZWxlbWVudCBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQSBzaW5nbGUgZWxlbWVudCBoYXMgYmVlbiBwYXNzZWQgaW4uXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBjb2xsZWN0aW9uIHRvIGFycmF5IGZvciBwbHVnaW5zLlxuICAgICAgICAgICAgLy8gVE9ETzogTWF5IHdhbnQgdG8gY2hlY2sgc28gdGhhdCBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGFyZSB2YWxpZCBlbGVtZW50cy5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdG9BcnJheShlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy4gTXVzdCBiZSBhIERPTSBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiBET00gZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJIYW5kbGVyLnJlbW92ZUFsbExpc3RlbmVycyhlbGVtZW50KTtcbiAgICAgICAgICAgIGRldGVjdGlvblN0cmF0ZWd5LnVuaW5zdGFsbChlbGVtZW50KTtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5jbGVhblN0YXRlKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaXN0ZW5UbzogbGlzdGVuVG8sXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyOiBldmVudExpc3RlbmVySGFuZGxlci5yZW1vdmVMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBldmVudExpc3RlbmVySGFuZGxlci5yZW1vdmVBbGxMaXN0ZW5lcnMsXG4gICAgICAgIHVuaW5zdGFsbDogdW5pbnN0YWxsXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldE9wdGlvbihvcHRpb25zLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zW25hbWVdO1xuXG4gICAgaWYoKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(options) {\n    var getState = options.stateHandler.getState;\n\n    /**\n     * Tells if the element has been made detectable and ready to be listened for resize events.\n     * @public\n     * @param {element} The element to check.\n     * @returns {boolean} True or false depending on if the element is detectable or not.\n     */\n    function isDetectable(element) {\n        var state = getState(element);\n        return state && !!state.isDetectable;\n    }\n\n    /**\n     * Marks the element that it has been made detectable and ready to be listened for resize events.\n     * @public\n     * @param {element} The element to mark.\n     */\n    function markAsDetectable(element) {\n        getState(element).isDetectable = true;\n    }\n\n    /**\n     * Tells if the element is busy or not.\n     * @public\n     * @param {element} The element to check.\n     * @returns {boolean} True or false depending on if the element is busy or not.\n     */\n    function isBusy(element) {\n        return !!getState(element).busy;\n    }\n\n    /**\n     * Marks the object is busy and should not be made detectable.\n     * @public\n     * @param {element} element The element to mark.\n     * @param {boolean} busy If the element is busy or not.\n     */\n    function markBusy(element, busy) {\n        getState(element).busy = !!busy;\n    }\n\n    return {\n        isDetectable: isDetectable,\n        markAsDetectable: markAsDetectable,\n        isBusy: isBusy,\n        markBusy: markBusy\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2VsZW1lbnQtdXRpbHMuanM/YTc1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2V0U3RhdGUgPSBvcHRpb25zLnN0YXRlSGFuZGxlci5nZXRTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBlbGVtZW50IGhhcyBiZWVuIG1hZGUgZGV0ZWN0YWJsZSBhbmQgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBldmVudHMuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIGlmIHRoZSBlbGVtZW50IGlzIGRldGVjdGFibGUgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgISFzdGF0ZS5pc0RldGVjdGFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGVsZW1lbnQgdGhhdCBpdCBoYXMgYmVlbiBtYWRlIGRldGVjdGFibGUgYW5kIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgZXZlbnRzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IFRoZSBlbGVtZW50IHRvIG1hcmsuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFya0FzRGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLmlzRGV0ZWN0YWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGVsZW1lbnQgaXMgYnVzeSBvciBub3QuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIGlmIHRoZSBlbGVtZW50IGlzIGJ1c3kgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnVzeShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAhIWdldFN0YXRlKGVsZW1lbnQpLmJ1c3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIG9iamVjdCBpcyBidXN5IGFuZCBzaG91bGQgbm90IGJlIG1hZGUgZGV0ZWN0YWJsZS5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIG1hcmsuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBidXN5IElmIHRoZSBlbGVtZW50IGlzIGJ1c3kgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcmtCdXN5KGVsZW1lbnQsIGJ1c3kpIHtcbiAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkuYnVzeSA9ICEhYnVzeTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0RldGVjdGFibGU6IGlzRGV0ZWN0YWJsZSxcbiAgICAgICAgbWFya0FzRGV0ZWN0YWJsZTogbWFya0FzRGV0ZWN0YWJsZSxcbiAgICAgICAgaXNCdXN5OiBpc0J1c3ksXG4gICAgICAgIG1hcmtCdXN5OiBtYXJrQnVzeVxuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2VsZW1lbnQtdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(idHandler) {\n    var eventListeners = {};\n\n    /**\n     * Gets all listeners for the given element.\n     * @public\n     * @param {element} element The element to get all listeners for.\n     * @returns All listeners for the given element.\n     */\n    function getListeners(element) {\n        var id = idHandler.get(element);\n\n        if (id === undefined) {\n            return [];\n        }\n\n        return eventListeners[id] || [];\n    }\n\n    /**\n     * Stores the given listener for the given element. Will not actually add the listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The callback that the element has added.\n     */\n    function addListener(element, listener) {\n        var id = idHandler.get(element);\n\n        if(!eventListeners[id]) {\n            eventListeners[id] = [];\n        }\n\n        eventListeners[id].push(listener);\n    }\n\n    function removeListener(element, listener) {\n        var listeners = getListeners(element);\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n            if (listeners[i] === listener) {\n              listeners.splice(i, 1);\n              break;\n            }\n        }\n    }\n\n    function removeAllListeners(element) {\n      var listeners = getListeners(element);\n      if (!listeners) { return; }\n      listeners.length = 0;\n    }\n\n    return {\n        get: getListeners,\n        add: addListener,\n        removeListener: removeListener,\n        removeAllListeners: removeAllListeners\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2xpc3RlbmVyLWhhbmRsZXIuanM/NzU0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaWRIYW5kbGVyKSB7XG4gICAgdmFyIGV2ZW50TGlzdGVuZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZ2V0IGFsbCBsaXN0ZW5lcnMgZm9yLlxuICAgICAqIEByZXR1cm5zIEFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldExpc3RlbmVycyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBpZCA9IGlkSGFuZGxlci5nZXQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyc1tpZF0gfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuIFdpbGwgbm90IGFjdHVhbGx5IGFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBoYXZlIHRoZSBsaXN0ZW5lciBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdGhhdCB0aGUgZWxlbWVudCBoYXMgYWRkZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGlkID0gaWRIYW5kbGVyLmdldChlbGVtZW50KTtcblxuICAgICAgICBpZighZXZlbnRMaXN0ZW5lcnNbaWRdKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyc1tpZF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50TGlzdGVuZXJzW2lkXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhlbGVtZW50KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKGVsZW1lbnQpO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XG4gICAgICBsaXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGdldExpc3RlbmVycyxcbiAgICAgICAgYWRkOiBhZGRMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICAgICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IHJlbW92ZUFsbExpc3RlbmVyc1xuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2xpc3RlbmVyLWhhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function() {\n    var idCount = 1;\n\n    /**\n     * Generates a new unique id in the context.\n     * @public\n     * @returns {number} A unique id in the context.\n     */\n    function generate() {\n        return idCount++;\n    }\n\n    return {\n        generate: generate\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2lkLWdlbmVyYXRvci5qcz8wODYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWRDb3VudCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgdW5pcXVlIGlkIGluIHRoZSBjb250ZXh0LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBIHVuaXF1ZSBpZCBpbiB0aGUgY29udGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGlkQ291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZTogZ2VuZXJhdGVcbiAgICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL3NyYy9pZC1nZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(options) {\n    var idGenerator     = options.idGenerator;\n    var getState        = options.stateHandler.getState;\n\n    /**\n     * Gets the resize detector id of the element.\n     * @public\n     * @param {element} element The target element to get the id of.\n     * @returns {string|number|null} The id of the element. Null if it has no id.\n     */\n    function getId(element) {\n        var state = getState(element);\n\n        if (state && state.id !== undefined) {\n            return state.id;\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the resize detector id of the element. Requires the element to have a resize detector state initialized.\n     * @public\n     * @param {element} element The target element to set the id of.\n     * @returns {string|number|null} The id of the element.\n     */\n    function setId(element) {\n        var state = getState(element);\n\n        if (!state) {\n            throw new Error(\"setId required the element to have a resize detection state.\");\n        }\n\n        var id = idGenerator.generate();\n\n        state.id = id;\n\n        return id;\n    }\n\n    return {\n        get: getId,\n        set: setId\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2lkLWhhbmRsZXIuanM/ZWI0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpZEdlbmVyYXRvciAgICAgPSBvcHRpb25zLmlkR2VuZXJhdG9yO1xuICAgIHZhciBnZXRTdGF0ZSAgICAgICAgPSBvcHRpb25zLnN0YXRlSGFuZGxlci5nZXRTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlc2l6ZSBkZXRlY3RvciBpZCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudCB0byBnZXQgdGhlIGlkIG9mLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfG51bGx9IFRoZSBpZCBvZiB0aGUgZWxlbWVudC4gTnVsbCBpZiBpdCBoYXMgbm8gaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SWQoZWxlbWVudCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShlbGVtZW50KTtcblxuICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVzaXplIGRldGVjdG9yIGlkIG9mIHRoZSBlbGVtZW50LiBSZXF1aXJlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgcmVzaXplIGRldGVjdG9yIHN0YXRlIGluaXRpYWxpemVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHNldCB0aGUgaWQgb2YuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ8bnVsbH0gVGhlIGlkIG9mIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldElkKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0SWQgcmVxdWlyZWQgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhIHJlc2l6ZSBkZXRlY3Rpb24gc3RhdGUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gaWRHZW5lcmF0b3IuZ2VuZXJhdGUoKTtcblxuICAgICAgICBzdGF0ZS5pZCA9IGlkO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGdldElkLFxuICAgICAgICBzZXQ6IHNldElkXG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvaWQtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global console: false */\n\n/**\n * Reporter that handles the reporting of logs, warnings and errors.\n * @public\n * @param {boolean} quiet Tells if the reporter should be quiet or not.\n */\nmodule.exports = function(quiet) {\n    function noop() {\n        //Does nothing.\n    }\n\n    var reporter = {\n        log: noop,\n        warn: noop,\n        error: noop\n    };\n\n    if(!quiet && window.console) {\n        var attachFunction = function(reporter, name) {\n            //The proxy is needed to be able to call the method with the console context,\n            //since we cannot use bind.\n            reporter[name] = function reporterProxy() {\n                var f = console[name];\n                if (f.apply) { //IE9 does not support console.log.apply :)\n                    f.apply(console, arguments);\n                } else {\n                    for (var i = 0; i < arguments.length; i++) {\n                        f(arguments[i]);\n                    }\n                }\n            };\n        };\n\n        attachFunction(reporter, \"log\");\n        attachFunction(reporter, \"warn\");\n        attachFunction(reporter, \"error\");\n    }\n\n    return reporter;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL3JlcG9ydGVyLmpzPzNhMGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogZ2xvYmFsIGNvbnNvbGU6IGZhbHNlICovXG5cbi8qKlxuICogUmVwb3J0ZXIgdGhhdCBoYW5kbGVzIHRoZSByZXBvcnRpbmcgb2YgbG9ncywgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVpZXQgVGVsbHMgaWYgdGhlIHJlcG9ydGVyIHNob3VsZCBiZSBxdWlldCBvciBub3QuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXVpZXQpIHtcbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICAvL0RvZXMgbm90aGluZy5cbiAgICB9XG5cbiAgICB2YXIgcmVwb3J0ZXIgPSB7XG4gICAgICAgIGxvZzogbm9vcCxcbiAgICAgICAgd2Fybjogbm9vcCxcbiAgICAgICAgZXJyb3I6IG5vb3BcbiAgICB9O1xuXG4gICAgaWYoIXF1aWV0ICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgIHZhciBhdHRhY2hGdW5jdGlvbiA9IGZ1bmN0aW9uKHJlcG9ydGVyLCBuYW1lKSB7XG4gICAgICAgICAgICAvL1RoZSBwcm94eSBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoZSBtZXRob2Qgd2l0aCB0aGUgY29uc29sZSBjb250ZXh0LFxuICAgICAgICAgICAgLy9zaW5jZSB3ZSBjYW5ub3QgdXNlIGJpbmQuXG4gICAgICAgICAgICByZXBvcnRlcltuYW1lXSA9IGZ1bmN0aW9uIHJlcG9ydGVyUHJveHkoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBjb25zb2xlW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChmLmFwcGx5KSB7IC8vSUU5IGRvZXMgbm90IHN1cHBvcnQgY29uc29sZS5sb2cuYXBwbHkgOilcbiAgICAgICAgICAgICAgICAgICAgZi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGF0dGFjaEZ1bmN0aW9uKHJlcG9ydGVyLCBcImxvZ1wiKTtcbiAgICAgICAgYXR0YWNoRnVuY3Rpb24ocmVwb3J0ZXIsIFwid2FyblwiKTtcbiAgICAgICAgYXR0YWNoRnVuY3Rpb24ocmVwb3J0ZXIsIFwiZXJyb3JcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydGVyO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvcmVwb3J0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(35);\n\nmodule.exports = function batchProcessorMaker(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var asyncProcess    = utils.getOption(options, \"async\", true);\n    var autoProcess     = utils.getOption(options, \"auto\", true);\n\n    if(autoProcess && !asyncProcess) {\n        reporter && reporter.warn(\"Invalid options combination. auto=true and async=false is invalid. Setting async=true.\");\n        asyncProcess = true;\n    }\n\n    var batch = Batch();\n    var asyncFrameHandler;\n    var isProcessing = false;\n\n    function addFunction(level, fn) {\n        if(!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {\n            // Since this is async, it is guaranteed to be executed after that the fn is added to the batch.\n            // This needs to be done before, since we're checking the size of the batch to be 0.\n            processBatchAsync();\n        }\n\n        batch.add(level, fn);\n    }\n\n    function processBatch() {\n        // Save the current batch, and create a new batch so that incoming functions are not added into the currently processing batch.\n        // Continue processing until the top-level batch is empty (functions may be added to the new batch while processing, and so on).\n        isProcessing = true;\n        while (batch.size()) {\n            var processingBatch = batch;\n            batch = Batch();\n            processingBatch.process();\n        }\n        isProcessing = false;\n    }\n\n    function forceProcessBatch(localAsyncProcess) {\n        if (isProcessing) {\n            return;\n        }\n\n        if(localAsyncProcess === undefined) {\n            localAsyncProcess = asyncProcess;\n        }\n\n        if(asyncFrameHandler) {\n            cancelFrame(asyncFrameHandler);\n            asyncFrameHandler = null;\n        }\n\n        if(localAsyncProcess) {\n            processBatchAsync();\n        } else {\n            processBatch();\n        }\n    }\n\n    function processBatchAsync() {\n        asyncFrameHandler = requestFrame(processBatch);\n    }\n\n    function clearBatch() {\n        batch           = {};\n        batchSize       = 0;\n        topLevel        = 0;\n        bottomLevel     = 0;\n    }\n\n    function cancelFrame(listener) {\n        // var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;\n        var cancel = clearTimeout;\n        return cancel(listener);\n    }\n\n    function requestFrame(callback) {\n        // var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) { return window.setTimeout(fn, 20); };\n        var raf = function(fn) { return setTimeout(fn, 0); };\n        return raf(callback);\n    }\n\n    return {\n        add: addFunction,\n        force: forceProcessBatch\n    };\n};\n\nfunction Batch() {\n    var batch       = {};\n    var size        = 0;\n    var topLevel    = 0;\n    var bottomLevel = 0;\n\n    function add(level, fn) {\n        if(!fn) {\n            fn = level;\n            level = 0;\n        }\n\n        if(level > topLevel) {\n            topLevel = level;\n        } else if(level < bottomLevel) {\n            bottomLevel = level;\n        }\n\n        if(!batch[level]) {\n            batch[level] = [];\n        }\n\n        batch[level].push(fn);\n        size++;\n    }\n\n    function process() {\n        for(var level = bottomLevel; level <= topLevel; level++) {\n            var fns = batch[level];\n\n            for(var i = 0; i < fns.length; i++) {\n                var fn = fns[i];\n                fn();\n            }\n        }\n    }\n\n    function getSize() {\n        return size;\n    }\n\n    return {\n        add: add,\n        process: process,\n        size: getSize\n    };\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmF0Y2gtcHJvY2Vzc29yL3NyYy9iYXRjaC1wcm9jZXNzb3IuanM/MWE5YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0SUFBNEksa0NBQWtDO0FBQzlLLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmF0Y2hQcm9jZXNzb3JNYWtlcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJlcG9ydGVyICAgICAgICA9IG9wdGlvbnMucmVwb3J0ZXI7XG4gICAgdmFyIGFzeW5jUHJvY2VzcyAgICA9IHV0aWxzLmdldE9wdGlvbihvcHRpb25zLCBcImFzeW5jXCIsIHRydWUpO1xuICAgIHZhciBhdXRvUHJvY2VzcyAgICAgPSB1dGlscy5nZXRPcHRpb24ob3B0aW9ucywgXCJhdXRvXCIsIHRydWUpO1xuXG4gICAgaWYoYXV0b1Byb2Nlc3MgJiYgIWFzeW5jUHJvY2Vzcykge1xuICAgICAgICByZXBvcnRlciAmJiByZXBvcnRlci53YXJuKFwiSW52YWxpZCBvcHRpb25zIGNvbWJpbmF0aW9uLiBhdXRvPXRydWUgYW5kIGFzeW5jPWZhbHNlIGlzIGludmFsaWQuIFNldHRpbmcgYXN5bmM9dHJ1ZS5cIik7XG4gICAgICAgIGFzeW5jUHJvY2VzcyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGJhdGNoID0gQmF0Y2goKTtcbiAgICB2YXIgYXN5bmNGcmFtZUhhbmRsZXI7XG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnVuY3Rpb24obGV2ZWwsIGZuKSB7XG4gICAgICAgIGlmKCFpc1Byb2Nlc3NpbmcgJiYgYXV0b1Byb2Nlc3MgJiYgYXN5bmNQcm9jZXNzICYmIGJhdGNoLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhc3luYywgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSBleGVjdXRlZCBhZnRlciB0aGF0IHRoZSBmbiBpcyBhZGRlZCB0byB0aGUgYmF0Y2guXG4gICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlLCBzaW5jZSB3ZSdyZSBjaGVja2luZyB0aGUgc2l6ZSBvZiB0aGUgYmF0Y2ggdG8gYmUgMC5cbiAgICAgICAgICAgIHByb2Nlc3NCYXRjaEFzeW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXRjaC5hZGQobGV2ZWwsIGZuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQmF0Y2goKSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgYmF0Y2gsIGFuZCBjcmVhdGUgYSBuZXcgYmF0Y2ggc28gdGhhdCBpbmNvbWluZyBmdW5jdGlvbnMgYXJlIG5vdCBhZGRlZCBpbnRvIHRoZSBjdXJyZW50bHkgcHJvY2Vzc2luZyBiYXRjaC5cbiAgICAgICAgLy8gQ29udGludWUgcHJvY2Vzc2luZyB1bnRpbCB0aGUgdG9wLWxldmVsIGJhdGNoIGlzIGVtcHR5IChmdW5jdGlvbnMgbWF5IGJlIGFkZGVkIHRvIHRoZSBuZXcgYmF0Y2ggd2hpbGUgcHJvY2Vzc2luZywgYW5kIHNvIG9uKS5cbiAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGJhdGNoLnNpemUoKSkge1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NpbmdCYXRjaCA9IGJhdGNoO1xuICAgICAgICAgICAgYmF0Y2ggPSBCYXRjaCgpO1xuICAgICAgICAgICAgcHJvY2Vzc2luZ0JhdGNoLnByb2Nlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JjZVByb2Nlc3NCYXRjaChsb2NhbEFzeW5jUHJvY2Vzcykge1xuICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihsb2NhbEFzeW5jUHJvY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2NhbEFzeW5jUHJvY2VzcyA9IGFzeW5jUHJvY2VzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFzeW5jRnJhbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICBjYW5jZWxGcmFtZShhc3luY0ZyYW1lSGFuZGxlcik7XG4gICAgICAgICAgICBhc3luY0ZyYW1lSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsb2NhbEFzeW5jUHJvY2Vzcykge1xuICAgICAgICAgICAgcHJvY2Vzc0JhdGNoQXN5bmMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NCYXRjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0JhdGNoQXN5bmMoKSB7XG4gICAgICAgIGFzeW5jRnJhbWVIYW5kbGVyID0gcmVxdWVzdEZyYW1lKHByb2Nlc3NCYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJCYXRjaCgpIHtcbiAgICAgICAgYmF0Y2ggICAgICAgICAgID0ge307XG4gICAgICAgIGJhdGNoU2l6ZSAgICAgICA9IDA7XG4gICAgICAgIHRvcExldmVsICAgICAgICA9IDA7XG4gICAgICAgIGJvdHRvbUxldmVsICAgICA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsRnJhbWUobGlzdGVuZXIpIHtcbiAgICAgICAgLy8gdmFyIGNhbmNlbCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5jbGVhclRpbWVvdXQ7XG4gICAgICAgIHZhciBjYW5jZWwgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjYW5jZWwobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcXVlc3RGcmFtZShjYWxsYmFjaykge1xuICAgICAgICAvLyB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oZm4pIHsgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAyMCk7IH07XG4gICAgICAgIHZhciByYWYgPSBmdW5jdGlvbihmbikgeyByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7IH07XG4gICAgICAgIHJldHVybiByYWYoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogYWRkRnVuY3Rpb24sXG4gICAgICAgIGZvcmNlOiBmb3JjZVByb2Nlc3NCYXRjaFxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBCYXRjaCgpIHtcbiAgICB2YXIgYmF0Y2ggICAgICAgPSB7fTtcbiAgICB2YXIgc2l6ZSAgICAgICAgPSAwO1xuICAgIHZhciB0b3BMZXZlbCAgICA9IDA7XG4gICAgdmFyIGJvdHRvbUxldmVsID0gMDtcblxuICAgIGZ1bmN0aW9uIGFkZChsZXZlbCwgZm4pIHtcbiAgICAgICAgaWYoIWZuKSB7XG4gICAgICAgICAgICBmbiA9IGxldmVsO1xuICAgICAgICAgICAgbGV2ZWwgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobGV2ZWwgPiB0b3BMZXZlbCkge1xuICAgICAgICAgICAgdG9wTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgfSBlbHNlIGlmKGxldmVsIDwgYm90dG9tTGV2ZWwpIHtcbiAgICAgICAgICAgIGJvdHRvbUxldmVsID0gbGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZighYmF0Y2hbbGV2ZWxdKSB7XG4gICAgICAgICAgICBiYXRjaFtsZXZlbF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhdGNoW2xldmVsXS5wdXNoKGZuKTtcbiAgICAgICAgc2l6ZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgIGZvcih2YXIgbGV2ZWwgPSBib3R0b21MZXZlbDsgbGV2ZWwgPD0gdG9wTGV2ZWw7IGxldmVsKyspIHtcbiAgICAgICAgICAgIHZhciBmbnMgPSBiYXRjaFtsZXZlbF07XG5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmbnNbaV07XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICBzaXplOiBnZXRTaXplXG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhdGNoLXByb2Nlc3Nvci9zcmMvYmF0Y2gtcHJvY2Vzc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = module.exports = {};\n\nutils.getOption = getOption;\n\nfunction getOption(options, name, defaultValue) {\n    var value = options[name];\n\n    if((value === undefined || value === null) && defaultValue !== undefined) {\n        return defaultValue;\n    }\n\n    return value;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmF0Y2gtcHJvY2Vzc29yL3NyYy91dGlscy5qcz8yYzFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudXRpbHMuZ2V0T3B0aW9uID0gZ2V0T3B0aW9uO1xuXG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uc1tuYW1lXTtcblxuICAgIGlmKCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhdGNoLXByb2Nlc3Nvci9zcmMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar prop = \"_erd\";\n\nfunction initState(element) {\n    element[prop] = {};\n    return getState(element);\n}\n\nfunction getState(element) {\n    return element[prop];\n}\n\nfunction cleanState(element) {\n    delete element[prop];\n}\n\nmodule.exports = {\n    initState: initState,\n    getState: getState,\n    cleanState: cleanState\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL3N0YXRlLWhhbmRsZXIuanM/ZmI1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHByb3AgPSBcIl9lcmRcIjtcblxuZnVuY3Rpb24gaW5pdFN0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50W3Byb3BdID0ge307XG4gICAgcmV0dXJuIGdldFN0YXRlKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhdGUoZWxlbWVudCkge1xuICAgIGRlbGV0ZSBlbGVtZW50W3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbml0U3RhdGU6IGluaXRTdGF0ZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgY2xlYW5TdGF0ZTogY2xlYW5TdGF0ZVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL3NyYy9zdGF0ZS1oYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Resize detection strategy that injects objects to elements in order to detect resize events.\n * Heavily inspired by: http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/\n */\n\n\n\nvar browserDetector = __webpack_require__(9);\n\nmodule.exports = function(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var batchProcessor  = options.batchProcessor;\n    var getState        = options.stateHandler.getState;\n\n    if(!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n    }\n\n    /**\n     * Adds a resize event listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.\n     */\n    function addListener(element, listener) {\n        if(!getObject(element)) {\n            throw new Error(\"Element is not detectable by this strategy.\");\n        }\n\n        function listenerProxy() {\n            listener(element);\n        }\n\n        if(browserDetector.isIE(8)) {\n            //IE 8 does not support object, but supports the resize event directly on elements.\n            getState(element).object = {\n                proxy: listenerProxy\n            };\n            element.attachEvent(\"onresize\", listenerProxy);\n        } else {\n            var object = getObject(element);\n            object.contentDocument.defaultView.addEventListener(\"resize\", listenerProxy);\n        }\n    }\n\n    /**\n     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.\n     * @private\n     * @param {object} options Optional options object.\n     * @param {element} element The element to make detectable\n     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.\n     */\n    function makeDetectable(options, element, callback) {\n        if (!callback) {\n            callback = element;\n            element = options;\n            options = null;\n        }\n\n        options = options || {};\n        var debug = options.debug;\n\n        function injectObject(element, callback) {\n            var OBJECT_STYLE = \"display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;\";\n\n            //The target element needs to be positioned (everything except static) so the absolute positioned object will be positioned relative to the target element.\n\n            // Position altering may be performed directly or on object load, depending on if style resolution is possible directly or not.\n            var positionCheckPerformed = false;\n\n            // The element may not yet be attached to the DOM, and therefore the style object may be empty in some browsers.\n            // Since the style object is a reference, it will be updated as soon as the element is attached to the DOM.\n            var style = window.getComputedStyle(element);\n            var width = element.offsetWidth;\n            var height = element.offsetHeight;\n\n            getState(element).startSize = {\n                width: width,\n                height: height\n            };\n\n            function mutateDom() {\n                function alterPositionStyles() {\n                    if(style.position === \"static\") {\n                        element.style.position = \"relative\";\n\n                        var removeRelativeStyles = function(reporter, element, style, property) {\n                            function getNumericalValue(value) {\n                                return value.replace(/[^-\\d\\.]/g, \"\");\n                            }\n\n                            var value = style[property];\n\n                            if(value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                                reporter.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element);\n                                element.style[property] = 0;\n                            }\n                        };\n\n                        //Check so that there are no accidental styles that will make the element styled differently now that is is relative.\n                        //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).\n                        removeRelativeStyles(reporter, element, style, \"top\");\n                        removeRelativeStyles(reporter, element, style, \"right\");\n                        removeRelativeStyles(reporter, element, style, \"bottom\");\n                        removeRelativeStyles(reporter, element, style, \"left\");\n                    }\n                }\n\n                function onObjectLoad() {\n                    // The object has been loaded, which means that the element now is guaranteed to be attached to the DOM.\n                    if (!positionCheckPerformed) {\n                        alterPositionStyles();\n                    }\n\n                    /*jshint validthis: true */\n\n                    function getDocument(element, callback) {\n                        //Opera 12 seem to call the object.onload before the actual document has been created.\n                        //So if it is not present, poll it with an timeout until it is present.\n                        //TODO: Could maybe be handled better with object.onreadystatechange or similar.\n                        if(!element.contentDocument) {\n                            setTimeout(function checkForObjectDocument() {\n                                getDocument(element, callback);\n                            }, 100);\n\n                            return;\n                        }\n\n                        callback(element.contentDocument);\n                    }\n\n                    //Mutating the object element here seems to fire another load event.\n                    //Mutating the inner document of the object element is fine though.\n                    var objectElement = this;\n\n                    //Create the style element to be added to the object.\n                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {\n                        //Notify that the element is ready to be listened to.\n                        callback(element);\n                    });\n                }\n\n                // The element may be detached from the DOM, and some browsers does not support style resolving of detached elements.\n                // The alterPositionStyles needs to be delayed until we know the element has been attached to the DOM (which we are sure of when the onObjectLoad has been fired), if style resolution is not possible.\n                if (style.position !== \"\") {\n                    alterPositionStyles(style);\n                    positionCheckPerformed = true;\n                }\n\n                //Add an object element as a child to the target element that will be listened to for resize events.\n                var object = document.createElement(\"object\");\n                object.style.cssText = OBJECT_STYLE;\n                object.tabIndex = -1;\n                object.type = \"text/html\";\n                object.onload = onObjectLoad;\n\n                //Safari: This must occur before adding the object to the DOM.\n                //IE: Does not like that this happens before, even if it is also added after.\n                if(!browserDetector.isIE()) {\n                    object.data = \"about:blank\";\n                }\n\n                element.appendChild(object);\n                getState(element).object = object;\n\n                //IE: This must occur after adding the object to the DOM.\n                if(browserDetector.isIE()) {\n                    object.data = \"about:blank\";\n                }\n            }\n\n            if(batchProcessor) {\n                batchProcessor.add(mutateDom);\n            } else {\n                mutateDom();\n            }\n        }\n\n        if(browserDetector.isIE(8)) {\n            //IE 8 does not support objects properly. Luckily they do support the resize event.\n            //So do not inject the object and notify that the element is already ready to be listened to.\n            //The event handler for the resize event is attached in the utils.addListener instead.\n            callback(element);\n        } else {\n            injectObject(element, callback);\n        }\n    }\n\n    /**\n     * Returns the child object of the target element.\n     * @private\n     * @param {element} element The target element.\n     * @returns The object element of the target.\n     */\n    function getObject(element) {\n        return getState(element).object;\n    }\n\n    function uninstall(element) {\n        if(browserDetector.isIE(8)) {\n            element.detachEvent(\"onresize\", getState(element).object.proxy);\n        } else {\n            element.removeChild(getObject(element));\n        }\n        delete getState(element).object;\n    }\n\n    return {\n        makeDetectable: makeDetectable,\n        addListener: addListener,\n        uninstall: uninstall\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2RldGVjdGlvbi1zdHJhdGVneS9vYmplY3QuanM/NDhhNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLG9CQUFvQixRQUFRLFNBQVMsYUFBYSxjQUFjLGNBQWMsWUFBWSxXQUFXLFlBQVksZ0JBQWdCLHNCQUFzQjs7QUFFdE07O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVzaXplIGRldGVjdGlvbiBzdHJhdGVneSB0aGF0IGluamVjdHMgb2JqZWN0cyB0byBlbGVtZW50cyBpbiBvcmRlciB0byBkZXRlY3QgcmVzaXplIGV2ZW50cy5cbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHA6Ly93d3cuYmFja2FsbGV5Y29kZXIuY29tLzIwMTMvMDMvMTgvY3Jvc3MtYnJvd3Nlci1ldmVudC1iYXNlZC1lbGVtZW50LXJlc2l6ZS1kZXRlY3Rpb24vXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBicm93c2VyRGV0ZWN0b3IgPSByZXF1aXJlKFwiLi4vYnJvd3Nlci1kZXRlY3RvclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJlcG9ydGVyICAgICAgICA9IG9wdGlvbnMucmVwb3J0ZXI7XG4gICAgdmFyIGJhdGNoUHJvY2Vzc29yICA9IG9wdGlvbnMuYmF0Y2hQcm9jZXNzb3I7XG4gICAgdmFyIGdldFN0YXRlICAgICAgICA9IG9wdGlvbnMuc3RhdGVIYW5kbGVyLmdldFN0YXRlO1xuXG4gICAgaWYoIXJlcG9ydGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgZGVwZW5kZW5jeTogcmVwb3J0ZXIuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZXNpemUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBoYXZlIHRoZSBsaXN0ZW5lciBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIHJlc2l6ZSBldmVudCBvZiB0aGUgZWxlbWVudC4gVGhlIGVsZW1lbnQgd2lsbCBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYoIWdldE9iamVjdChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgZGV0ZWN0YWJsZSBieSB0aGlzIHN0cmF0ZWd5LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyUHJveHkoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGJyb3dzZXJEZXRlY3Rvci5pc0lFKDgpKSB7XG4gICAgICAgICAgICAvL0lFIDggZG9lcyBub3Qgc3VwcG9ydCBvYmplY3QsIGJ1dCBzdXBwb3J0cyB0aGUgcmVzaXplIGV2ZW50IGRpcmVjdGx5IG9uIGVsZW1lbnRzLlxuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgIHByb3h5OiBsaXN0ZW5lclByb3h5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9ucmVzaXplXCIsIGxpc3RlbmVyUHJveHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IGdldE9iamVjdChlbGVtZW50KTtcbiAgICAgICAgICAgIG9iamVjdC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lclByb3h5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgZGV0ZWN0YWJsZSBhbmQgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBldmVudHMuIFdpbGwgY2FsbCB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgZWxlbWVudCBpcyByZWFkeSB0byBiZSBsaXN0ZW5lZCBmb3IgcmVzaXplIGNoYW5nZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gbWFrZSBkZXRlY3RhYmxlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgY2hhbmdlcy4gV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZWxlbWVudCBhcyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZURldGVjdGFibGUob3B0aW9ucywgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlbGVtZW50O1xuICAgICAgICAgICAgZWxlbWVudCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluamVjdE9iamVjdChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIE9CSkVDVF9TVFlMRSA9IFwiZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IG5vbmU7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgb3BhY2l0eTogMDsgei1pbmRleDogLTEwMDA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuXG4gICAgICAgICAgICAvL1RoZSB0YXJnZXQgZWxlbWVudCBuZWVkcyB0byBiZSBwb3NpdGlvbmVkIChldmVyeXRoaW5nIGV4Y2VwdCBzdGF0aWMpIHNvIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbmVkIG9iamVjdCB3aWxsIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBhbHRlcmluZyBtYXkgYmUgcGVyZm9ybWVkIGRpcmVjdGx5IG9yIG9uIG9iamVjdCBsb2FkLCBkZXBlbmRpbmcgb24gaWYgc3R5bGUgcmVzb2x1dGlvbiBpcyBwb3NzaWJsZSBkaXJlY3RseSBvciBub3QuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25DaGVja1BlcmZvcm1lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBtYXkgbm90IHlldCBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLCBhbmQgdGhlcmVmb3JlIHRoZSBzdHlsZSBvYmplY3QgbWF5IGJlIGVtcHR5IGluIHNvbWUgYnJvd3NlcnMuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgc3R5bGUgb2JqZWN0IGlzIGEgcmVmZXJlbmNlLCBpdCB3aWxsIGJlIHVwZGF0ZWQgYXMgc29vbiBhcyB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5zdGFydFNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtdXRhdGVEb20oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWx0ZXJQb3NpdGlvblN0eWxlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVSZWxhdGl2ZVN0eWxlcyA9IGZ1bmN0aW9uKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXROdW1lcmljYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW14tXFxkXFwuXS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wZXJ0eV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSAhPT0gXCJhdXRvXCIgJiYgZ2V0TnVtZXJpY2FsVmFsdWUodmFsdWUpICE9PSBcIjBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRlci53YXJuKFwiQW4gZWxlbWVudCB0aGF0IGlzIHBvc2l0aW9uZWQgc3RhdGljIGhhcyBzdHlsZS5cIiArIHByb3BlcnR5ICsgXCI9XCIgKyB2YWx1ZSArIFwiIHdoaWNoIGlzIGlnbm9yZWQgZHVlIHRvIHRoZSBzdGF0aWMgcG9zaXRpb25pbmcuIFRoZSBlbGVtZW50IHdpbGwgbmVlZCB0byBiZSBwb3NpdGlvbmVkIHJlbGF0aXZlLCBzbyB0aGUgc3R5bGUuXCIgKyBwcm9wZXJ0eSArIFwiIHdpbGwgYmUgc2V0IHRvIDAuIEVsZW1lbnQ6IFwiLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ2hlY2sgc28gdGhhdCB0aGVyZSBhcmUgbm8gYWNjaWRlbnRhbCBzdHlsZXMgdGhhdCB3aWxsIG1ha2UgdGhlIGVsZW1lbnQgc3R5bGVkIGRpZmZlcmVudGx5IG5vdyB0aGF0IGlzIGlzIHJlbGF0aXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgYW55LCBzZXQgdGhlbSB0byAwICh0aGlzIHNob3VsZCBiZSBva2F5IHdpdGggdGhlIHVzZXIgc2luY2UgdGhlIHN0eWxlIHByb3BlcnRpZXMgZGlkIG5vdGhpbmcgYmVmb3JlIFtzaW5jZSB0aGUgZWxlbWVudCB3YXMgcG9zaXRpb25lZCBzdGF0aWNdIGFueXdheSkuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWxhdGl2ZVN0eWxlcyhyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIFwidG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbGF0aXZlU3R5bGVzKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25PYmplY3RMb2FkKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb2JqZWN0IGhhcyBiZWVuIGxvYWRlZCwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgZWxlbWVudCBub3cgaXMgZ3VhcmFudGVlZCB0byBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uQ2hlY2tQZXJmb3JtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVyUG9zaXRpb25TdHlsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL09wZXJhIDEyIHNlZW0gdG8gY2FsbCB0aGUgb2JqZWN0Lm9ubG9hZCBiZWZvcmUgdGhlIGFjdHVhbCBkb2N1bWVudCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9TbyBpZiBpdCBpcyBub3QgcHJlc2VudCwgcG9sbCBpdCB3aXRoIGFuIHRpbWVvdXQgdW50aWwgaXQgaXMgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogQ291bGQgbWF5YmUgYmUgaGFuZGxlZCBiZXR0ZXIgd2l0aCBvYmplY3Qub25yZWFkeXN0YXRlY2hhbmdlIG9yIHNpbWlsYXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZWxlbWVudC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGNoZWNrRm9yT2JqZWN0RG9jdW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldERvY3VtZW50KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50LmNvbnRlbnREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL011dGF0aW5nIHRoZSBvYmplY3QgZWxlbWVudCBoZXJlIHNlZW1zIHRvIGZpcmUgYW5vdGhlciBsb2FkIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvL011dGF0aW5nIHRoZSBpbm5lciBkb2N1bWVudCBvZiB0aGUgb2JqZWN0IGVsZW1lbnQgaXMgZmluZSB0aG91Z2guXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RFbGVtZW50ID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZSB0aGUgc3R5bGUgZWxlbWVudCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBnZXREb2N1bWVudChvYmplY3RFbGVtZW50LCBmdW5jdGlvbiBvbk9iamVjdERvY3VtZW50UmVhZHkob2JqZWN0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTm90aWZ5IHRoYXQgdGhlIGVsZW1lbnQgaXMgcmVhZHkgdG8gYmUgbGlzdGVuZWQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgbWF5IGJlIGRldGFjaGVkIGZyb20gdGhlIERPTSwgYW5kIHNvbWUgYnJvd3NlcnMgZG9lcyBub3Qgc3VwcG9ydCBzdHlsZSByZXNvbHZpbmcgb2YgZGV0YWNoZWQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFsdGVyUG9zaXRpb25TdHlsZXMgbmVlZHMgdG8gYmUgZGVsYXllZCB1bnRpbCB3ZSBrbm93IHRoZSBlbGVtZW50IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBET00gKHdoaWNoIHdlIGFyZSBzdXJlIG9mIHdoZW4gdGhlIG9uT2JqZWN0TG9hZCBoYXMgYmVlbiBmaXJlZCksIGlmIHN0eWxlIHJlc29sdXRpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBhbHRlclBvc2l0aW9uU3R5bGVzKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DaGVja1BlcmZvcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9BZGQgYW4gb2JqZWN0IGVsZW1lbnQgYXMgYSBjaGlsZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQgdGhhdCB3aWxsIGJlIGxpc3RlbmVkIHRvIGZvciByZXNpemUgZXZlbnRzLlxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHlsZS5jc3NUZXh0ID0gT0JKRUNUX1NUWUxFO1xuICAgICAgICAgICAgICAgIG9iamVjdC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gXCJ0ZXh0L2h0bWxcIjtcbiAgICAgICAgICAgICAgICBvYmplY3Qub25sb2FkID0gb25PYmplY3RMb2FkO1xuXG4gICAgICAgICAgICAgICAgLy9TYWZhcmk6IFRoaXMgbXVzdCBvY2N1ciBiZWZvcmUgYWRkaW5nIHRoZSBvYmplY3QgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAvL0lFOiBEb2VzIG5vdCBsaWtlIHRoYXQgdGhpcyBoYXBwZW5zIGJlZm9yZSwgZXZlbiBpZiBpdCBpcyBhbHNvIGFkZGVkIGFmdGVyLlxuICAgICAgICAgICAgICAgIGlmKCFicm93c2VyRGV0ZWN0b3IuaXNJRSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhID0gXCJhYm91dDpibGFua1wiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICAgICAgICAgICAgICAvL0lFOiBUaGlzIG11c3Qgb2NjdXIgYWZ0ZXIgYWRkaW5nIHRoZSBvYmplY3QgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAgICBpZihicm93c2VyRGV0ZWN0b3IuaXNJRSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhID0gXCJhYm91dDpibGFua1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYmF0Y2hQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQobXV0YXRlRG9tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlRG9tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihicm93c2VyRGV0ZWN0b3IuaXNJRSg4KSkge1xuICAgICAgICAgICAgLy9JRSA4IGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBwcm9wZXJseS4gTHVja2lseSB0aGV5IGRvIHN1cHBvcnQgdGhlIHJlc2l6ZSBldmVudC5cbiAgICAgICAgICAgIC8vU28gZG8gbm90IGluamVjdCB0aGUgb2JqZWN0IGFuZCBub3RpZnkgdGhhdCB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHJlYWR5IHRvIGJlIGxpc3RlbmVkIHRvLlxuICAgICAgICAgICAgLy9UaGUgZXZlbnQgaGFuZGxlciBmb3IgdGhlIHJlc2l6ZSBldmVudCBpcyBhdHRhY2hlZCBpbiB0aGUgdXRpbHMuYWRkTGlzdGVuZXIgaW5zdGVhZC5cbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5qZWN0T2JqZWN0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoaWxkIG9iamVjdCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgZWxlbWVudCBvZiB0aGUgdGFyZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9iamVjdChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRTdGF0ZShlbGVtZW50KS5vYmplY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5pbnN0YWxsKGVsZW1lbnQpIHtcbiAgICAgICAgaWYoYnJvd3NlckRldGVjdG9yLmlzSUUoOCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBnZXRTdGF0ZShlbGVtZW50KS5vYmplY3QucHJveHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChnZXRPYmplY3QoZWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBnZXRTdGF0ZShlbGVtZW50KS5vYmplY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFrZURldGVjdGFibGU6IG1ha2VEZXRlY3RhYmxlLFxuICAgICAgICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gICAgICAgIHVuaW5zdGFsbDogdW5pbnN0YWxsXG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvZGV0ZWN0aW9uLXN0cmF0ZWd5L29iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Resize detection strategy that injects divs to elements in order to detect resize events on scroll events.\n * Heavily inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js\n */\n\n\n\nvar forEach = __webpack_require__(8).forEach;\n\nmodule.exports = function(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var batchProcessor  = options.batchProcessor;\n    var getState        = options.stateHandler.getState;\n    var hasState        = options.stateHandler.hasState;\n    var idHandler       = options.idHandler;\n\n    if (!batchProcessor) {\n        throw new Error(\"Missing required dependency: batchProcessor\");\n    }\n\n    if (!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n    }\n\n    //TODO: Could this perhaps be done at installation time?\n    var scrollbarSizes = getScrollbarSizes();\n\n    // Inject the scrollbar styling that prevents them from appearing sometimes in Chrome.\n    // The injected container needs to have a class, so that it may be styled with CSS (pseudo elements).\n    var styleId = \"erd_scroll_detection_scrollbar_style\";\n    var detectionContainerClass = \"erd_scroll_detection_container\";\n    injectScrollStyle(styleId, detectionContainerClass);\n\n    function getScrollbarSizes() {\n        var width = 500;\n        var height = 500;\n\n        var child = document.createElement(\"div\");\n        child.style.cssText = \"position: absolute; width: \" + width*2 + \"px; height: \" + height*2 + \"px; visibility: hidden; margin: 0; padding: 0;\";\n\n        var container = document.createElement(\"div\");\n        container.style.cssText = \"position: absolute; width: \" + width + \"px; height: \" + height + \"px; overflow: scroll; visibility: none; top: \" + -width*3 + \"px; left: \" + -height*3 + \"px; visibility: hidden; margin: 0; padding: 0;\";\n\n        container.appendChild(child);\n\n        document.body.insertBefore(container, document.body.firstChild);\n\n        var widthSize = width - container.clientWidth;\n        var heightSize = height - container.clientHeight;\n\n        document.body.removeChild(container);\n\n        return {\n            width: widthSize,\n            height: heightSize\n        };\n    }\n\n    function injectScrollStyle(styleId, containerClass) {\n        function injectStyle(style, method) {\n            method = method || function (element) {\n                document.head.appendChild(element);\n            };\n\n            var styleElement = document.createElement(\"style\");\n            styleElement.innerHTML = style;\n            styleElement.id = styleId;\n            method(styleElement);\n            return styleElement;\n        }\n\n        if (!document.getElementById(styleId)) {\n            var containerAnimationClass = containerClass + \"_animation\";\n            var containerAnimationActiveClass = containerClass + \"_animation_active\";\n            var style = \"/* Created by the element-resize-detector library. */\\n\";\n            style += \".\" + containerClass + \" > div::-webkit-scrollbar { display: none; }\\n\\n\";\n            style += \".\" + containerAnimationActiveClass + \" { -webkit-animation-duration: 0.1s; animation-duration: 0.1s; -webkit-animation-name: \" + containerAnimationClass + \"; animation-name: \" + containerAnimationClass + \"; }\\n\";\n            style += \"@-webkit-keyframes \" + containerAnimationClass +  \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\\n\";\n            style += \"@keyframes \" + containerAnimationClass +          \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\";\n            injectStyle(style);\n        }\n    }\n\n    function addAnimationClass(element) {\n        element.className += \" \" + detectionContainerClass + \"_animation_active\";\n    }\n\n    function addEvent(el, name, cb) {\n        if (el.addEventListener) {\n            el.addEventListener(name, cb);\n        } else if(el.attachEvent) {\n            el.attachEvent(\"on\" + name, cb);\n        } else {\n            return reporter.error(\"[scroll] Don't know how to add event listeners.\");\n        }\n    }\n\n    function removeEvent(el, name, cb) {\n        if (el.removeEventListener) {\n            el.removeEventListener(name, cb);\n        } else if(el.detachEvent) {\n            el.detachEvent(\"on\" + name, cb);\n        } else {\n            return reporter.error(\"[scroll] Don't know how to remove event listeners.\");\n        }\n    }\n\n    function getExpandElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];\n    }\n\n    function getShrinkElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];\n    }\n\n    /**\n     * Adds a resize event listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.\n     */\n    function addListener(element, listener) {\n        var listeners = getState(element).listeners;\n\n        if (!listeners.push) {\n            throw new Error(\"Cannot add listener to an element that is not detectable.\");\n        }\n\n        getState(element).listeners.push(listener);\n    }\n\n    /**\n     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.\n     * @private\n     * @param {object} options Optional options object.\n     * @param {element} element The element to make detectable\n     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.\n     */\n    function makeDetectable(options, element, callback) {\n        if (!callback) {\n            callback = element;\n            element = options;\n            options = null;\n        }\n\n        options = options || {};\n\n        function debug() {\n            if (options.debug) {\n                var args = Array.prototype.slice.call(arguments);\n                args.unshift(idHandler.get(element), \"Scroll: \");\n                if (reporter.log.apply) {\n                    reporter.log.apply(null, args);\n                } else {\n                    for (var i = 0; i < args.length; i++) {\n                        reporter.log(args[i]);\n                    }\n                }\n            }\n        }\n\n        function isDetached(element) {\n            function isInDocument(element) {\n                return element === element.ownerDocument.body || element.ownerDocument.body.contains(element);\n            }\n\n            if (!isInDocument(element)) {\n                return true;\n            }\n\n            // FireFox returns null style in hidden iframes. See https://github.com/wnr/element-resize-detector/issues/68 and https://bugzilla.mozilla.org/show_bug.cgi?id=795520\n            if (getComputedStyle(element) === null) {\n                return true;\n            }\n\n            return false;\n        }\n\n        function isUnrendered(element) {\n            // Check the absolute positioned container since the top level container is display: inline.\n            var container = getState(element).container.childNodes[0];\n            var style = getComputedStyle(container);\n            return !style.width || style.width.indexOf(\"px\") === -1; //Can only compute pixel value when rendered.\n        }\n\n        function getStyle() {\n            // Some browsers only force layouts when actually reading the style properties of the style object, so make sure that they are all read here,\n            // so that the user of the function can be sure that it will perform the layout here, instead of later (important for batching).\n            var elementStyle            = getComputedStyle(element);\n            var style                   = {};\n            style.position              = elementStyle.position;\n            style.width                 = element.offsetWidth;\n            style.height                = element.offsetHeight;\n            style.top                   = elementStyle.top;\n            style.right                 = elementStyle.right;\n            style.bottom                = elementStyle.bottom;\n            style.left                  = elementStyle.left;\n            style.widthCSS              = elementStyle.width;\n            style.heightCSS             = elementStyle.height;\n            return style;\n        }\n\n        function storeStartSize() {\n            var style = getStyle();\n            getState(element).startSize = {\n                width: style.width,\n                height: style.height\n            };\n            debug(\"Element start size\", getState(element).startSize);\n        }\n\n        function initListeners() {\n            getState(element).listeners = [];\n        }\n\n        function storeStyle() {\n            debug(\"storeStyle invoked.\");\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            var style = getStyle();\n            getState(element).style = style;\n        }\n\n        function storeCurrentSize(element, width, height) {\n            getState(element).lastWidth = width;\n            getState(element).lastHeight  = height;\n        }\n\n        function getExpandChildElement(element) {\n            return getExpandElement(element).childNodes[0];\n        }\n\n        function getWidthOffset() {\n            return 2 * scrollbarSizes.width + 1;\n        }\n\n        function getHeightOffset() {\n            return 2 * scrollbarSizes.height + 1;\n        }\n\n        function getExpandWidth(width) {\n            return width + 10 + getWidthOffset();\n        }\n\n        function getExpandHeight(height) {\n            return height + 10 + getHeightOffset();\n        }\n\n        function getShrinkWidth(width) {\n            return width * 2 + getWidthOffset();\n        }\n\n        function getShrinkHeight(height) {\n            return height * 2 + getHeightOffset();\n        }\n\n        function positionScrollbars(element, width, height) {\n            var expand          = getExpandElement(element);\n            var shrink          = getShrinkElement(element);\n            var expandWidth     = getExpandWidth(width);\n            var expandHeight    = getExpandHeight(height);\n            var shrinkWidth     = getShrinkWidth(width);\n            var shrinkHeight    = getShrinkHeight(height);\n            expand.scrollLeft   = expandWidth;\n            expand.scrollTop    = expandHeight;\n            shrink.scrollLeft   = shrinkWidth;\n            shrink.scrollTop    = shrinkHeight;\n        }\n\n        function injectContainerElement() {\n            var container = getState(element).container;\n\n            if (!container) {\n                container                   = document.createElement(\"div\");\n                container.className         = detectionContainerClass;\n                container.style.cssText     = \"visibility: hidden; display: inline; width: 0px; height: 0px; z-index: -1; overflow: hidden; margin: 0; padding: 0;\";\n                getState(element).container = container;\n                addAnimationClass(container);\n                element.appendChild(container);\n\n                var onAnimationStart = function () {\n                    getState(element).onRendered && getState(element).onRendered();\n                };\n\n                addEvent(container, \"animationstart\", onAnimationStart);\n\n                // Store the event handler here so that they may be removed when uninstall is called.\n                // See uninstall function for an explanation why it is needed.\n                getState(element).onAnimationStart = onAnimationStart;\n            }\n\n            return container;\n        }\n\n        function injectScrollElements() {\n            function alterPositionStyles() {\n                var style = getState(element).style;\n\n                if(style.position === \"static\") {\n                    element.style.position = \"relative\";\n\n                    var removeRelativeStyles = function(reporter, element, style, property) {\n                        function getNumericalValue(value) {\n                            return value.replace(/[^-\\d\\.]/g, \"\");\n                        }\n\n                        var value = style[property];\n\n                        if(value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                            reporter.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element);\n                            element.style[property] = 0;\n                        }\n                    };\n\n                    //Check so that there are no accidental styles that will make the element styled differently now that is is relative.\n                    //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).\n                    removeRelativeStyles(reporter, element, style, \"top\");\n                    removeRelativeStyles(reporter, element, style, \"right\");\n                    removeRelativeStyles(reporter, element, style, \"bottom\");\n                    removeRelativeStyles(reporter, element, style, \"left\");\n                }\n            }\n\n            function getLeftTopBottomRightCssText(left, top, bottom, right) {\n                left = (!left ? \"0\" : (left + \"px\"));\n                top = (!top ? \"0\" : (top + \"px\"));\n                bottom = (!bottom ? \"0\" : (bottom + \"px\"));\n                right = (!right ? \"0\" : (right + \"px\"));\n\n                return \"left: \" + left + \"; top: \" + top + \"; right: \" + right + \"; bottom: \" + bottom + \";\";\n            }\n\n            debug(\"Injecting elements\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            alterPositionStyles();\n\n            var rootContainer = getState(element).container;\n\n            if (!rootContainer) {\n                rootContainer = injectContainerElement();\n            }\n\n            // Due to this WebKit bug https://bugs.webkit.org/show_bug.cgi?id=80808 (currently fixed in Blink, but still present in WebKit browsers such as Safari),\n            // we need to inject two containers, one that is width/height 100% and another that is left/top -1px so that the final container always is 1x1 pixels bigger than\n            // the targeted element.\n            // When the bug is resolved, \"containerContainer\" may be removed.\n\n            // The outer container can occasionally be less wide than the targeted when inside inline elements element in WebKit (see https://bugs.webkit.org/show_bug.cgi?id=152980).\n            // This should be no problem since the inner container either way makes sure the injected scroll elements are at least 1x1 px.\n\n            var scrollbarWidth          = scrollbarSizes.width;\n            var scrollbarHeight         = scrollbarSizes.height;\n            var containerContainerStyle = \"position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; width: 100%; height: 100%; left: 0px; top: 0px;\";\n            var containerStyle          = \"position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; \" + getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth);\n            var expandStyle             = \"position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;\";\n            var shrinkStyle             = \"position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;\";\n            var expandChildStyle        = \"position: absolute; left: 0; top: 0;\";\n            var shrinkChildStyle        = \"position: absolute; width: 200%; height: 200%;\";\n\n            var containerContainer      = document.createElement(\"div\");\n            var container               = document.createElement(\"div\");\n            var expand                  = document.createElement(\"div\");\n            var expandChild             = document.createElement(\"div\");\n            var shrink                  = document.createElement(\"div\");\n            var shrinkChild             = document.createElement(\"div\");\n\n            // Some browsers choke on the resize system being rtl, so force it to ltr. https://github.com/wnr/element-resize-detector/issues/56\n            // However, dir should not be set on the top level container as it alters the dimensions of the target element in some browsers.\n            containerContainer.dir              = \"ltr\";\n\n            containerContainer.style.cssText    = containerContainerStyle;\n            containerContainer.className        = detectionContainerClass;\n            container.className                 = detectionContainerClass;\n            container.style.cssText             = containerStyle;\n            expand.style.cssText                = expandStyle;\n            expandChild.style.cssText           = expandChildStyle;\n            shrink.style.cssText                = shrinkStyle;\n            shrinkChild.style.cssText           = shrinkChildStyle;\n\n            expand.appendChild(expandChild);\n            shrink.appendChild(shrinkChild);\n            container.appendChild(expand);\n            container.appendChild(shrink);\n            containerContainer.appendChild(container);\n            rootContainer.appendChild(containerContainer);\n\n            function onExpandScroll() {\n                getState(element).onExpand && getState(element).onExpand();\n            }\n\n            function onShrinkScroll() {\n                getState(element).onShrink && getState(element).onShrink();\n            }\n\n            addEvent(expand, \"scroll\", onExpandScroll);\n            addEvent(shrink, \"scroll\", onShrinkScroll);\n\n            // Store the event handlers here so that they may be removed when uninstall is called.\n            // See uninstall function for an explanation why it is needed.\n            getState(element).onExpandScroll = onExpandScroll;\n            getState(element).onShrinkScroll = onShrinkScroll;\n        }\n\n        function registerListenersAndPositionElements() {\n            function updateChildSizes(element, width, height) {\n                var expandChild             = getExpandChildElement(element);\n                var expandWidth             = getExpandWidth(width);\n                var expandHeight            = getExpandHeight(height);\n                expandChild.style.width     = expandWidth + \"px\";\n                expandChild.style.height    = expandHeight + \"px\";\n            }\n\n            function updateDetectorElements(done) {\n                var width           = element.offsetWidth;\n                var height          = element.offsetHeight;\n\n                debug(\"Storing current size\", width, height);\n\n                // Store the size of the element sync here, so that multiple scroll events may be ignored in the event listeners.\n                // Otherwise the if-check in handleScroll is useless.\n                storeCurrentSize(element, width, height);\n\n                // Since we delay the processing of the batch, there is a risk that uninstall has been called before the batch gets to execute.\n                // Since there is no way to cancel the fn executions, we need to add an uninstall guard to all fns of the batch.\n\n                batchProcessor.add(0, function performUpdateChildSizes() {\n                    if (!getState(element)) {\n                        debug(\"Aborting because element has been uninstalled\");\n                        return;\n                    }\n\n                    if (!areElementsInjected()) {\n                        debug(\"Aborting because element container has not been initialized\");\n                        return;\n                    }\n\n                    if (options.debug) {\n                        var w = element.offsetWidth;\n                        var h = element.offsetHeight;\n\n                        if (w !== width || h !== height) {\n                            reporter.warn(idHandler.get(element), \"Scroll: Size changed before updating detector elements.\");\n                        }\n                    }\n\n                    updateChildSizes(element, width, height);\n                });\n\n                batchProcessor.add(1, function updateScrollbars() {\n                    if (!getState(element)) {\n                        debug(\"Aborting because element has been uninstalled\");\n                        return;\n                    }\n\n                    if (!areElementsInjected()) {\n                        debug(\"Aborting because element container has not been initialized\");\n                        return;\n                    }\n\n                    positionScrollbars(element, width, height);\n                });\n\n                if (done) {\n                    batchProcessor.add(2, function () {\n                        if (!getState(element)) {\n                            debug(\"Aborting because element has been uninstalled\");\n                            return;\n                        }\n\n                        if (!areElementsInjected()) {\n                          debug(\"Aborting because element container has not been initialized\");\n                          return;\n                        }\n\n                        done();\n                    });\n                }\n            }\n\n            function areElementsInjected() {\n                return !!getState(element).container;\n            }\n\n            function notifyListenersIfNeeded() {\n                function isFirstNotify() {\n                    return getState(element).lastNotifiedWidth === undefined;\n                }\n\n                debug(\"notifyListenersIfNeeded invoked\");\n\n                var state = getState(element);\n\n                // Don't notify the if the current size is the start size, and this is the first notification.\n                if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {\n                    return debug(\"Not notifying: Size is the same as the start size, and there has been no notification yet.\");\n                }\n\n                // Don't notify if the size already has been notified.\n                if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {\n                    return debug(\"Not notifying: Size already notified\");\n                }\n\n\n                debug(\"Current size not notified, notifying...\");\n                state.lastNotifiedWidth = state.lastWidth;\n                state.lastNotifiedHeight = state.lastHeight;\n                forEach(getState(element).listeners, function (listener) {\n                    listener(element);\n                });\n            }\n\n            function handleRender() {\n                debug(\"startanimation triggered.\");\n\n                if (isUnrendered(element)) {\n                    debug(\"Ignoring since element is still unrendered...\");\n                    return;\n                }\n\n                debug(\"Element rendered.\");\n                var expand = getExpandElement(element);\n                var shrink = getShrinkElement(element);\n                if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {\n                    debug(\"Scrollbars out of sync. Updating detector elements...\");\n                    updateDetectorElements(notifyListenersIfNeeded);\n                }\n            }\n\n            function handleScroll() {\n                debug(\"Scroll detected.\");\n\n                if (isUnrendered(element)) {\n                    // Element is still unrendered. Skip this scroll event.\n                    debug(\"Scroll event fired while unrendered. Ignoring...\");\n                    return;\n                }\n\n                var width = element.offsetWidth;\n                var height = element.offsetHeight;\n\n                if (width !== getState(element).lastWidth || height !== getState(element).lastHeight) {\n                    debug(\"Element size changed.\");\n                    updateDetectorElements(notifyListenersIfNeeded);\n                } else {\n                    debug(\"Element size has not changed (\" + width + \"x\" + height + \").\");\n                }\n            }\n\n            debug(\"registerListenersAndPositionElements invoked.\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            getState(element).onRendered = handleRender;\n            getState(element).onExpand = handleScroll;\n            getState(element).onShrink = handleScroll;\n\n            var style = getState(element).style;\n            updateChildSizes(element, style.width, style.height);\n        }\n\n        function finalizeDomMutation() {\n            debug(\"finalizeDomMutation invoked.\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            var style = getState(element).style;\n            storeCurrentSize(element, style.width, style.height);\n            positionScrollbars(element, style.width, style.height);\n        }\n\n        function ready() {\n            callback(element);\n        }\n\n        function install() {\n            debug(\"Installing...\");\n            initListeners();\n            storeStartSize();\n\n            batchProcessor.add(0, storeStyle);\n            batchProcessor.add(1, injectScrollElements);\n            batchProcessor.add(2, registerListenersAndPositionElements);\n            batchProcessor.add(3, finalizeDomMutation);\n            batchProcessor.add(4, ready);\n        }\n\n        debug(\"Making detectable...\");\n\n        if (isDetached(element)) {\n            debug(\"Element is detached\");\n\n            injectContainerElement();\n\n            debug(\"Waiting until element is attached...\");\n\n            getState(element).onRendered = function () {\n                debug(\"Element is now attached\");\n                install();\n            };\n        } else {\n            install();\n        }\n    }\n\n    function uninstall(element) {\n        var state = getState(element);\n\n        if (!state) {\n            // Uninstall has been called on a non-erd element.\n            return;\n        }\n\n        // Uninstall may have been called in the following scenarios:\n        // (1) Right between the sync code and async batch (here state.busy = true, but nothing have been registered or injected).\n        // (2) In the ready callback of the last level of the batch by another element (here, state.busy = true, but all the stuff has been injected).\n        // (3) After the installation process (here, state.busy = false and all the stuff has been injected).\n        // So to be on the safe side, let's check for each thing before removing.\n\n        // We need to remove the event listeners, because otherwise the event might fire on an uninstall element which results in an error when trying to get the state of the element.\n        state.onExpandScroll && removeEvent(getExpandElement(element), \"scroll\", state.onExpandScroll);\n        state.onShrinkScroll && removeEvent(getShrinkElement(element), \"scroll\", state.onShrinkScroll);\n        state.onAnimationStart && removeEvent(state.container, \"animationstart\", state.onAnimationStart);\n\n        state.container && element.removeChild(state.container);\n    }\n\n    return {\n        makeDetectable: makeDetectable,\n        addListener: addListener,\n        uninstall: uninstall\n    };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Ivc3JjL2RldGVjdGlvbi1zdHJhdGVneS9zY3JvbGwuanM/NGI1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsMEJBQTBCLDRCQUE0QixvQkFBb0IsV0FBVyxZQUFZOztBQUVuSjtBQUNBLHNEQUFzRCx3QkFBd0IsMEJBQTBCLGtCQUFrQixrQkFBa0IseUJBQXlCLDJCQUEyQixvQkFBb0IsV0FBVyxZQUFZOztBQUUzTzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZSxFQUFFO0FBQ3pGLDhEQUE4RCxrQ0FBa0MsMEJBQTBCLHlEQUF5RCxpREFBaUQsRUFBRTtBQUN0TywyRUFBMkUsS0FBSyxZQUFZLEVBQUUsTUFBTSxZQUFZLEVBQUUsT0FBTyxZQUFZLEVBQUUsRUFBRTtBQUN6SSwyRUFBMkUsS0FBSyxZQUFZLEVBQUUsTUFBTSxZQUFZLEVBQUUsT0FBTyxZQUFZLEVBQUUsRUFBRTtBQUN6STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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LyoqXG4gKiBSZXNpemUgZGV0ZWN0aW9uIHN0cmF0ZWd5IHRoYXQgaW5qZWN0cyBkaXZzIHRvIGVsZW1lbnRzIGluIG9yZGVyIHRvIGRldGVjdCByZXNpemUgZXZlbnRzIG9uIHNjcm9sbCBldmVudHMuXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9zcmMvUmVzaXplU2Vuc29yLmpzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZShcIi4uL2NvbGxlY3Rpb24tdXRpbHNcIikuZm9yRWFjaDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJlcG9ydGVyICAgICAgICA9IG9wdGlvbnMucmVwb3J0ZXI7XG4gICAgdmFyIGJhdGNoUHJvY2Vzc29yICA9IG9wdGlvbnMuYmF0Y2hQcm9jZXNzb3I7XG4gICAgdmFyIGdldFN0YXRlICAgICAgICA9IG9wdGlvbnMuc3RhdGVIYW5kbGVyLmdldFN0YXRlO1xuICAgIHZhciBoYXNTdGF0ZSAgICAgICAgPSBvcHRpb25zLnN0YXRlSGFuZGxlci5oYXNTdGF0ZTtcbiAgICB2YXIgaWRIYW5kbGVyICAgICAgID0gb3B0aW9ucy5pZEhhbmRsZXI7XG5cbiAgICBpZiAoIWJhdGNoUHJvY2Vzc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgZGVwZW5kZW5jeTogYmF0Y2hQcm9jZXNzb3JcIik7XG4gICAgfVxuXG4gICAgaWYgKCFyZXBvcnRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGRlcGVuZGVuY3k6IHJlcG9ydGVyLlwiKTtcbiAgICB9XG5cbiAgICAvL1RPRE86IENvdWxkIHRoaXMgcGVyaGFwcyBiZSBkb25lIGF0IGluc3RhbGxhdGlvbiB0aW1lP1xuICAgIHZhciBzY3JvbGxiYXJTaXplcyA9IGdldFNjcm9sbGJhclNpemVzKCk7XG5cbiAgICAvLyBJbmplY3QgdGhlIHNjcm9sbGJhciBzdHlsaW5nIHRoYXQgcHJldmVudHMgdGhlbSBmcm9tIGFwcGVhcmluZyBzb21ldGltZXMgaW4gQ2hyb21lLlxuICAgIC8vIFRoZSBpbmplY3RlZCBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIGNsYXNzLCBzbyB0aGF0IGl0IG1heSBiZSBzdHlsZWQgd2l0aCBDU1MgKHBzZXVkbyBlbGVtZW50cykuXG4gICAgdmFyIHN0eWxlSWQgPSBcImVyZF9zY3JvbGxfZGV0ZWN0aW9uX3Njcm9sbGJhcl9zdHlsZVwiO1xuICAgIHZhciBkZXRlY3Rpb25Db250YWluZXJDbGFzcyA9IFwiZXJkX3Njcm9sbF9kZXRlY3Rpb25fY29udGFpbmVyXCI7XG4gICAgaW5qZWN0U2Nyb2xsU3R5bGUoc3R5bGVJZCwgZGV0ZWN0aW9uQ29udGFpbmVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyU2l6ZXMoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDUwMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDUwMDtcblxuICAgICAgICB2YXIgY2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjaGlsZC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiBcIiArIHdpZHRoKjIgKyBcInB4OyBoZWlnaHQ6IFwiICsgaGVpZ2h0KjIgKyBcInB4OyB2aXNpYmlsaXR5OiBoaWRkZW47IG1hcmdpbjogMDsgcGFkZGluZzogMDtcIjtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IFwiICsgd2lkdGggKyBcInB4OyBoZWlnaHQ6IFwiICsgaGVpZ2h0ICsgXCJweDsgb3ZlcmZsb3c6IHNjcm9sbDsgdmlzaWJpbGl0eTogbm9uZTsgdG9wOiBcIiArIC13aWR0aCozICsgXCJweDsgbGVmdDogXCIgKyAtaGVpZ2h0KjMgKyBcInB4OyB2aXNpYmlsaXR5OiBoaWRkZW47IG1hcmdpbjogMDsgcGFkZGluZzogMDtcIjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcblxuICAgICAgICB2YXIgd2lkdGhTaXplID0gd2lkdGggLSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRTaXplID0gaGVpZ2h0IC0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aFNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFNpemVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmplY3RTY3JvbGxTdHlsZShzdHlsZUlkLCBjb250YWluZXJDbGFzcykge1xuICAgICAgICBmdW5jdGlvbiBpbmplY3RTdHlsZShzdHlsZSwgbWV0aG9kKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2QgfHwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgIHN0eWxlRWxlbWVudC5pZCA9IHN0eWxlSWQ7XG4gICAgICAgICAgICBtZXRob2Qoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZUVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlSWQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyQW5pbWF0aW9uQ2xhc3MgPSBjb250YWluZXJDbGFzcyArIFwiX2FuaW1hdGlvblwiO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckFuaW1hdGlvbkFjdGl2ZUNsYXNzID0gY29udGFpbmVyQ2xhc3MgKyBcIl9hbmltYXRpb25fYWN0aXZlXCI7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBcIi8qIENyZWF0ZWQgYnkgdGhlIGVsZW1lbnQtcmVzaXplLWRldGVjdG9yIGxpYnJhcnkuICovXFxuXCI7XG4gICAgICAgICAgICBzdHlsZSArPSBcIi5cIiArIGNvbnRhaW5lckNsYXNzICsgXCIgPiBkaXY6Oi13ZWJraXQtc2Nyb2xsYmFyIHsgZGlzcGxheTogbm9uZTsgfVxcblxcblwiO1xuICAgICAgICAgICAgc3R5bGUgKz0gXCIuXCIgKyBjb250YWluZXJBbmltYXRpb25BY3RpdmVDbGFzcyArIFwiIHsgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMXM7IGFuaW1hdGlvbi1kdXJhdGlvbjogMC4xczsgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogXCIgKyBjb250YWluZXJBbmltYXRpb25DbGFzcyArIFwiOyBhbmltYXRpb24tbmFtZTogXCIgKyBjb250YWluZXJBbmltYXRpb25DbGFzcyArIFwiOyB9XFxuXCI7XG4gICAgICAgICAgICBzdHlsZSArPSBcIkAtd2Via2l0LWtleWZyYW1lcyBcIiArIGNvbnRhaW5lckFuaW1hdGlvbkNsYXNzICsgIFwiIHsgMCUgeyBvcGFjaXR5OiAxOyB9IDUwJSB7IG9wYWNpdHk6IDA7IH0gMTAwJSB7IG9wYWNpdHk6IDE7IH0gfVxcblwiO1xuICAgICAgICAgICAgc3R5bGUgKz0gXCJAa2V5ZnJhbWVzIFwiICsgY29udGFpbmVyQW5pbWF0aW9uQ2xhc3MgKyAgICAgICAgICBcIiB7IDAlIHsgb3BhY2l0eTogMTsgfSA1MCUgeyBvcGFjaXR5OiAwOyB9IDEwMCUgeyBvcGFjaXR5OiAxOyB9IH1cIjtcbiAgICAgICAgICAgIGluamVjdFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEFuaW1hdGlvbkNsYXNzKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBkZXRlY3Rpb25Db250YWluZXJDbGFzcyArIFwiX2FuaW1hdGlvbl9hY3RpdmVcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudChlbCwgbmFtZSwgY2IpIHtcbiAgICAgICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2IpO1xuICAgICAgICB9IGVsc2UgaWYoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcihcIltzY3JvbGxdIERvbid0IGtub3cgaG93IHRvIGFkZCBldmVudCBsaXN0ZW5lcnMuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwsIG5hbWUsIGNiKSB7XG4gICAgICAgIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIGlmKGVsLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBlbC5kZXRhY2hFdmVudChcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJbc2Nyb2xsXSBEb24ndCBrbm93IGhvdyB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEV4cGFuZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNocmlua0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZXNpemUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBoYXZlIHRoZSBsaXN0ZW5lciBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIHJlc2l6ZSBldmVudCBvZiB0aGUgZWxlbWVudC4gVGhlIGVsZW1lbnQgd2lsbCBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGdldFN0YXRlKGVsZW1lbnQpLmxpc3RlbmVycztcblxuICAgICAgICBpZiAoIWxpc3RlbmVycy5wdXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgdGhhdCBpcyBub3QgZGV0ZWN0YWJsZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYW4gZWxlbWVudCBkZXRlY3RhYmxlIGFuZCByZWFkeSB0byBiZSBsaXN0ZW5lZCBmb3IgcmVzaXplIGV2ZW50cy4gV2lsbCBjYWxsIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBlbGVtZW50IGlzIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgY2hhbmdlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBtYWtlIGRldGVjdGFibGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBjaGFuZ2VzLiBXaWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBlbGVtZW50IGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRGV0ZWN0YWJsZShvcHRpb25zLCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtZW50ID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoaWRIYW5kbGVyLmdldChlbGVtZW50KSwgXCJTY3JvbGw6IFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0ZXIubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydGVyLmxvZy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydGVyLmxvZyhhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzRGV0YWNoZWQoZWxlbWVudCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNJbkRvY3VtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHkgfHwgZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHkuY29udGFpbnMoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNJbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmVGb3ggcmV0dXJucyBudWxsIHN0eWxlIGluIGhpZGRlbiBpZnJhbWVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9pc3N1ZXMvNjggYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc5NTUyMFxuICAgICAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNVbnJlbmRlcmVkKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbmVkIGNvbnRhaW5lciBzaW5jZSB0aGUgdG9wIGxldmVsIGNvbnRhaW5lciBpcyBkaXNwbGF5OiBpbmxpbmUuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm4gIXN0eWxlLndpZHRoIHx8IHN0eWxlLndpZHRoLmluZGV4T2YoXCJweFwiKSA9PT0gLTE7IC8vQ2FuIG9ubHkgY29tcHV0ZSBwaXhlbCB2YWx1ZSB3aGVuIHJlbmRlcmVkLlxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIG9ubHkgZm9yY2UgbGF5b3V0cyB3aGVuIGFjdHVhbGx5IHJlYWRpbmcgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgdGhlIHN0eWxlIG9iamVjdCwgc28gbWFrZSBzdXJlIHRoYXQgdGhleSBhcmUgYWxsIHJlYWQgaGVyZSxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHVzZXIgb2YgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzdXJlIHRoYXQgaXQgd2lsbCBwZXJmb3JtIHRoZSBsYXlvdXQgaGVyZSwgaW5zdGVhZCBvZiBsYXRlciAoaW1wb3J0YW50IGZvciBiYXRjaGluZykuXG4gICAgICAgICAgICB2YXIgZWxlbWVudFN0eWxlICAgICAgICAgICAgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIHN0eWxlICAgICAgICAgICAgICAgICAgID0ge307XG4gICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiAgICAgICAgICAgICAgPSBlbGVtZW50U3R5bGUucG9zaXRpb247XG4gICAgICAgICAgICBzdHlsZS53aWR0aCAgICAgICAgICAgICAgICAgPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ICAgICAgICAgICAgICAgID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBzdHlsZS50b3AgICAgICAgICAgICAgICAgICAgPSBlbGVtZW50U3R5bGUudG9wO1xuICAgICAgICAgICAgc3R5bGUucmlnaHQgICAgICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLnJpZ2h0O1xuICAgICAgICAgICAgc3R5bGUuYm90dG9tICAgICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLmJvdHRvbTtcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgICAgICAgICAgICAgICAgICA9IGVsZW1lbnRTdHlsZS5sZWZ0O1xuICAgICAgICAgICAgc3R5bGUud2lkdGhDU1MgICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLndpZHRoO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0Q1NTICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3JlU3RhcnRTaXplKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoKTtcbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLnN0YXJ0U2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogc3R5bGUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZyhcIkVsZW1lbnQgc3RhcnQgc2l6ZVwiLCBnZXRTdGF0ZShlbGVtZW50KS5zdGFydFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdExpc3RlbmVycygpIHtcbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcmVTdHlsZSgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic3RvcmVTdHlsZSBpbnZva2VkLlwiKTtcbiAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkFib3J0aW5nIGJlY2F1c2UgZWxlbWVudCBoYXMgYmVlbiB1bmluc3RhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKCk7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcmVDdXJyZW50U2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5sYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLmxhc3RIZWlnaHQgID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXhwYW5kQ2hpbGRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFeHBhbmRFbGVtZW50KGVsZW1lbnQpLmNoaWxkTm9kZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRXaWR0aE9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogc2Nyb2xsYmFyU2l6ZXMud2lkdGggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0SGVpZ2h0T2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiBzY3JvbGxiYXJTaXplcy5oZWlnaHQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXhwYW5kV2lkdGgod2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCArIDEwICsgZ2V0V2lkdGhPZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4cGFuZEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgKyAxMCArIGdldEhlaWdodE9mZnNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U2hyaW5rV2lkdGgod2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCAqIDIgKyBnZXRXaWR0aE9mZnNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U2hyaW5rSGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGhlaWdodCAqIDIgKyBnZXRIZWlnaHRPZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uU2Nyb2xsYmFycyhlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZXhwYW5kICAgICAgICAgID0gZ2V0RXhwYW5kRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBzaHJpbmsgICAgICAgICAgPSBnZXRTaHJpbmtFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIGV4cGFuZFdpZHRoICAgICA9IGdldEV4cGFuZFdpZHRoKHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBleHBhbmRIZWlnaHQgICAgPSBnZXRFeHBhbmRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBzaHJpbmtXaWR0aCAgICAgPSBnZXRTaHJpbmtXaWR0aCh3aWR0aCk7XG4gICAgICAgICAgICB2YXIgc2hyaW5rSGVpZ2h0ICAgID0gZ2V0U2hyaW5rSGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICBleHBhbmQuc2Nyb2xsTGVmdCAgID0gZXhwYW5kV2lkdGg7XG4gICAgICAgICAgICBleHBhbmQuc2Nyb2xsVG9wICAgID0gZXhwYW5kSGVpZ2h0O1xuICAgICAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgICA9IHNocmlua1dpZHRoO1xuICAgICAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCAgICA9IHNocmlua0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluamVjdENvbnRhaW5lckVsZW1lbnQoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyO1xuXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciAgICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSAgICAgICAgID0gZGV0ZWN0aW9uQ29udGFpbmVyQ2xhc3M7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgICAgID0gXCJ2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGlubGluZTsgd2lkdGg6IDBweDsgaGVpZ2h0OiAwcHg7IHotaW5kZXg6IC0xOyBvdmVyZmxvdzogaGlkZGVuOyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7XCI7XG4gICAgICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGFkZEFuaW1hdGlvbkNsYXNzKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uUmVuZGVyZWQgJiYgZ2V0U3RhdGUoZWxlbWVudCkub25SZW5kZXJlZCgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhZGRFdmVudChjb250YWluZXIsIFwiYW5pbWF0aW9uc3RhcnRcIiwgb25BbmltYXRpb25TdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXZlbnQgaGFuZGxlciBoZXJlIHNvIHRoYXQgdGhleSBtYXkgYmUgcmVtb3ZlZCB3aGVuIHVuaW5zdGFsbCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgLy8gU2VlIHVuaW5zdGFsbCBmdW5jdGlvbiBmb3IgYW4gZXhwbGFuYXRpb24gd2h5IGl0IGlzIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vbkFuaW1hdGlvblN0YXJ0ID0gb25BbmltYXRpb25TdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluamVjdFNjcm9sbEVsZW1lbnRzKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gYWx0ZXJQb3NpdGlvblN0eWxlcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRTdGF0ZShlbGVtZW50KS5zdHlsZTtcblxuICAgICAgICAgICAgICAgIGlmKHN0eWxlLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZVJlbGF0aXZlU3R5bGVzID0gZnVuY3Rpb24ocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TnVtZXJpY2FsVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW14tXFxkXFwuXS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSAhPT0gXCJhdXRvXCIgJiYgZ2V0TnVtZXJpY2FsVmFsdWUodmFsdWUpICE9PSBcIjBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydGVyLndhcm4oXCJBbiBlbGVtZW50IHRoYXQgaXMgcG9zaXRpb25lZCBzdGF0aWMgaGFzIHN0eWxlLlwiICsgcHJvcGVydHkgKyBcIj1cIiArIHZhbHVlICsgXCIgd2hpY2ggaXMgaWdub3JlZCBkdWUgdG8gdGhlIHN0YXRpYyBwb3NpdGlvbmluZy4gVGhlIGVsZW1lbnQgd2lsbCBuZWVkIHRvIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUsIHNvIHRoZSBzdHlsZS5cIiArIHByb3BlcnR5ICsgXCIgd2lsbCBiZSBzZXQgdG8gMC4gRWxlbWVudDogXCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIHNvIHRoYXQgdGhlcmUgYXJlIG5vIGFjY2lkZW50YWwgc3R5bGVzIHRoYXQgd2lsbCBtYWtlIHRoZSBlbGVtZW50IHN0eWxlZCBkaWZmZXJlbnRseSBub3cgdGhhdCBpcyBpcyByZWxhdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgYW55LCBzZXQgdGhlbSB0byAwICh0aGlzIHNob3VsZCBiZSBva2F5IHdpdGggdGhlIHVzZXIgc2luY2UgdGhlIHN0eWxlIHByb3BlcnRpZXMgZGlkIG5vdGhpbmcgYmVmb3JlIFtzaW5jZSB0aGUgZWxlbWVudCB3YXMgcG9zaXRpb25lZCBzdGF0aWNdIGFueXdheSkuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbGF0aXZlU3R5bGVzKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgXCJ0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbGF0aXZlU3R5bGVzKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcImxlZnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMZWZ0VG9wQm90dG9tUmlnaHRDc3NUZXh0KGxlZnQsIHRvcCwgYm90dG9tLCByaWdodCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAoIWxlZnQgPyBcIjBcIiA6IChsZWZ0ICsgXCJweFwiKSk7XG4gICAgICAgICAgICAgICAgdG9wID0gKCF0b3AgPyBcIjBcIiA6ICh0b3AgKyBcInB4XCIpKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSAoIWJvdHRvbSA/IFwiMFwiIDogKGJvdHRvbSArIFwicHhcIikpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKCFyaWdodCA/IFwiMFwiIDogKHJpZ2h0ICsgXCJweFwiKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJsZWZ0OiBcIiArIGxlZnQgKyBcIjsgdG9wOiBcIiArIHRvcCArIFwiOyByaWdodDogXCIgKyByaWdodCArIFwiOyBib3R0b206IFwiICsgYm90dG9tICsgXCI7XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlYnVnKFwiSW5qZWN0aW5nIGVsZW1lbnRzXCIpO1xuXG4gICAgICAgICAgICBpZiAoIWdldFN0YXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgaGFzIGJlZW4gdW5pbnN0YWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbHRlclBvc2l0aW9uU3R5bGVzKCk7XG5cbiAgICAgICAgICAgIHZhciByb290Q29udGFpbmVyID0gZ2V0U3RhdGUoZWxlbWVudCkuY29udGFpbmVyO1xuXG4gICAgICAgICAgICBpZiAoIXJvb3RDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByb290Q29udGFpbmVyID0gaW5qZWN0Q29udGFpbmVyRWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEdWUgdG8gdGhpcyBXZWJLaXQgYnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDgwOCAoY3VycmVudGx5IGZpeGVkIGluIEJsaW5rLCBidXQgc3RpbGwgcHJlc2VudCBpbiBXZWJLaXQgYnJvd3NlcnMgc3VjaCBhcyBTYWZhcmkpLFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgdHdvIGNvbnRhaW5lcnMsIG9uZSB0aGF0IGlzIHdpZHRoL2hlaWdodCAxMDAlIGFuZCBhbm90aGVyIHRoYXQgaXMgbGVmdC90b3AgLTFweCBzbyB0aGF0IHRoZSBmaW5hbCBjb250YWluZXIgYWx3YXlzIGlzIDF4MSBwaXhlbHMgYmlnZ2VyIHRoYW5cbiAgICAgICAgICAgIC8vIHRoZSB0YXJnZXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgYnVnIGlzIHJlc29sdmVkLCBcImNvbnRhaW5lckNvbnRhaW5lclwiIG1heSBiZSByZW1vdmVkLlxuXG4gICAgICAgICAgICAvLyBUaGUgb3V0ZXIgY29udGFpbmVyIGNhbiBvY2Nhc2lvbmFsbHkgYmUgbGVzcyB3aWRlIHRoYW4gdGhlIHRhcmdldGVkIHdoZW4gaW5zaWRlIGlubGluZSBlbGVtZW50cyBlbGVtZW50IGluIFdlYktpdCAoc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTI5ODApLlxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgbm8gcHJvYmxlbSBzaW5jZSB0aGUgaW5uZXIgY29udGFpbmVyIGVpdGhlciB3YXkgbWFrZXMgc3VyZSB0aGUgaW5qZWN0ZWQgc2Nyb2xsIGVsZW1lbnRzIGFyZSBhdCBsZWFzdCAxeDEgcHguXG5cbiAgICAgICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCAgICAgICAgICA9IHNjcm9sbGJhclNpemVzLndpZHRoO1xuICAgICAgICAgICAgdmFyIHNjcm9sbGJhckhlaWdodCAgICAgICAgID0gc2Nyb2xsYmFyU2l6ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckNvbnRhaW5lclN0eWxlID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IGZsZXg6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGxlZnQ6IDBweDsgdG9wOiAwcHg7XCI7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgICAgICAgICAgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgZmxleDogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgei1pbmRleDogLTE7IHZpc2liaWxpdHk6IGhpZGRlbjsgXCIgKyBnZXRMZWZ0VG9wQm90dG9tUmlnaHRDc3NUZXh0KC0oMSArIHNjcm9sbGJhcldpZHRoKSwgLSgxICsgc2Nyb2xsYmFySGVpZ2h0KSwgLXNjcm9sbGJhckhlaWdodCwgLXNjcm9sbGJhcldpZHRoKTtcbiAgICAgICAgICAgIHZhciBleHBhbmRTdHlsZSAgICAgICAgICAgICA9IFwicG9zaXRpb246IGFic29sdXRlOyBmbGV4OiBub25lOyBvdmVyZmxvdzogc2Nyb2xsOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiO1xuICAgICAgICAgICAgdmFyIHNocmlua1N0eWxlICAgICAgICAgICAgID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IGZsZXg6IG5vbmU7IG92ZXJmbG93OiBzY3JvbGw7IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XCI7XG4gICAgICAgICAgICB2YXIgZXhwYW5kQ2hpbGRTdHlsZSAgICAgICAgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwO1wiO1xuICAgICAgICAgICAgdmFyIHNocmlua0NoaWxkU3R5bGUgICAgICAgID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCU7XCI7XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXJDb250YWluZXIgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIGV4cGFuZCAgICAgICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZCAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgc2hyaW5rICAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIHNocmlua0NoaWxkICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgLy8gU29tZSBicm93c2VycyBjaG9rZSBvbiB0aGUgcmVzaXplIHN5c3RlbSBiZWluZyBydGwsIHNvIGZvcmNlIGl0IHRvIGx0ci4gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9pc3N1ZXMvNTZcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGRpciBzaG91bGQgbm90IGJlIHNldCBvbiB0aGUgdG9wIGxldmVsIGNvbnRhaW5lciBhcyBpdCBhbHRlcnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRhcmdldCBlbGVtZW50IGluIHNvbWUgYnJvd3NlcnMuXG4gICAgICAgICAgICBjb250YWluZXJDb250YWluZXIuZGlyICAgICAgICAgICAgICA9IFwibHRyXCI7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lckNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICAgID0gY29udGFpbmVyQ29udGFpbmVyU3R5bGU7XG4gICAgICAgICAgICBjb250YWluZXJDb250YWluZXIuY2xhc3NOYW1lICAgICAgICA9IGRldGVjdGlvbkNvbnRhaW5lckNsYXNzO1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSAgICAgICAgICAgICAgICAgPSBkZXRlY3Rpb25Db250YWluZXJDbGFzcztcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICAgICAgICAgICAgID0gY29udGFpbmVyU3R5bGU7XG4gICAgICAgICAgICBleHBhbmQuc3R5bGUuY3NzVGV4dCAgICAgICAgICAgICAgICA9IGV4cGFuZFN0eWxlO1xuICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuY3NzVGV4dCAgICAgICAgICAgPSBleHBhbmRDaGlsZFN0eWxlO1xuICAgICAgICAgICAgc2hyaW5rLnN0eWxlLmNzc1RleHQgICAgICAgICAgICAgICAgPSBzaHJpbmtTdHlsZTtcbiAgICAgICAgICAgIHNocmlua0NoaWxkLnN0eWxlLmNzc1RleHQgICAgICAgICAgID0gc2hyaW5rQ2hpbGRTdHlsZTtcblxuICAgICAgICAgICAgZXhwYW5kLmFwcGVuZENoaWxkKGV4cGFuZENoaWxkKTtcbiAgICAgICAgICAgIHNocmluay5hcHBlbmRDaGlsZChzaHJpbmtDaGlsZCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZXhwYW5kKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzaHJpbmspO1xuICAgICAgICAgICAgY29udGFpbmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICByb290Q29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lckNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRXhwYW5kU2Nyb2xsKCkge1xuICAgICAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uRXhwYW5kICYmIGdldFN0YXRlKGVsZW1lbnQpLm9uRXhwYW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uU2hyaW5rU2Nyb2xsKCkge1xuICAgICAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uU2hyaW5rICYmIGdldFN0YXRlKGVsZW1lbnQpLm9uU2hyaW5rKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZEV2ZW50KGV4cGFuZCwgXCJzY3JvbGxcIiwgb25FeHBhbmRTY3JvbGwpO1xuICAgICAgICAgICAgYWRkRXZlbnQoc2hyaW5rLCBcInNjcm9sbFwiLCBvblNocmlua1Njcm9sbCk7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBldmVudCBoYW5kbGVycyBoZXJlIHNvIHRoYXQgdGhleSBtYXkgYmUgcmVtb3ZlZCB3aGVuIHVuaW5zdGFsbCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBTZWUgdW5pbnN0YWxsIGZ1bmN0aW9uIGZvciBhbiBleHBsYW5hdGlvbiB3aHkgaXQgaXMgbmVlZGVkLlxuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25FeHBhbmRTY3JvbGwgPSBvbkV4cGFuZFNjcm9sbDtcbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uU2hyaW5rU2Nyb2xsID0gb25TaHJpbmtTY3JvbGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyc0FuZFBvc2l0aW9uRWxlbWVudHMoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZFNpemVzKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kQ2hpbGQgICAgICAgICAgICAgPSBnZXRFeHBhbmRDaGlsZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZFdpZHRoICAgICAgICAgICAgID0gZ2V0RXhwYW5kV2lkdGgod2lkdGgpO1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRIZWlnaHQgICAgICAgICAgICA9IGdldEV4cGFuZEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoICAgICA9IGV4cGFuZFdpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLmhlaWdodCAgICA9IGV4cGFuZEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRGV0ZWN0b3JFbGVtZW50cyhkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoICAgICAgICAgICA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCAgICAgICAgICA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgZGVidWcoXCJTdG9yaW5nIGN1cnJlbnQgc2l6ZVwiLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHN5bmMgaGVyZSwgc28gdGhhdCBtdWx0aXBsZSBzY3JvbGwgZXZlbnRzIG1heSBiZSBpZ25vcmVkIGluIHRoZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBpZi1jaGVjayBpbiBoYW5kbGVTY3JvbGwgaXMgdXNlbGVzcy5cbiAgICAgICAgICAgICAgICBzdG9yZUN1cnJlbnRTaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgZGVsYXkgdGhlIHByb2Nlc3Npbmcgb2YgdGhlIGJhdGNoLCB0aGVyZSBpcyBhIHJpc2sgdGhhdCB1bmluc3RhbGwgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSB0aGUgYmF0Y2ggZ2V0cyB0byBleGVjdXRlLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBjYW5jZWwgdGhlIGZuIGV4ZWN1dGlvbnMsIHdlIG5lZWQgdG8gYWRkIGFuIHVuaW5zdGFsbCBndWFyZCB0byBhbGwgZm5zIG9mIHRoZSBiYXRjaC5cblxuICAgICAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCgwLCBmdW5jdGlvbiBwZXJmb3JtVXBkYXRlQ2hpbGRTaXplcygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgaGFzIGJlZW4gdW5pbnN0YWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZUVsZW1lbnRzSW5qZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgY29udGFpbmVyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodyAhPT0gd2lkdGggfHwgaCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZXIud2FybihpZEhhbmRsZXIuZ2V0KGVsZW1lbnQpLCBcIlNjcm9sbDogU2l6ZSBjaGFuZ2VkIGJlZm9yZSB1cGRhdGluZyBkZXRlY3RvciBlbGVtZW50cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZFNpemVzKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYmF0Y2hQcm9jZXNzb3IuYWRkKDEsIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVFbGVtZW50c0luamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGNvbnRhaW5lciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblNjcm9sbGJhcnMoZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVFbGVtZW50c0luamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgY29udGFpbmVyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXJlRWxlbWVudHNJbmplY3RlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFnZXRTdGF0ZShlbGVtZW50KS5jb250YWluZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVyc0lmTmVlZGVkKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzRmlyc3ROb3RpZnkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdGF0ZShlbGVtZW50KS5sYXN0Tm90aWZpZWRXaWR0aCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlYnVnKFwibm90aWZ5TGlzdGVuZXJzSWZOZWVkZWQgaW52b2tlZFwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgbm90aWZ5IHRoZSBpZiB0aGUgY3VycmVudCBzaXplIGlzIHRoZSBzdGFydCBzaXplLCBhbmQgdGhpcyBpcyB0aGUgZmlyc3Qgbm90aWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0Tm90aWZ5KCkgJiYgc3RhdGUubGFzdFdpZHRoID09PSBzdGF0ZS5zdGFydFNpemUud2lkdGggJiYgc3RhdGUubGFzdEhlaWdodCA9PT0gc3RhdGUuc3RhcnRTaXplLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVidWcoXCJOb3Qgbm90aWZ5aW5nOiBTaXplIGlzIHRoZSBzYW1lIGFzIHRoZSBzdGFydCBzaXplLCBhbmQgdGhlcmUgaGFzIGJlZW4gbm8gbm90aWZpY2F0aW9uIHlldC5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgbm90aWZ5IGlmIHRoZSBzaXplIGFscmVhZHkgaGFzIGJlZW4gbm90aWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3RXaWR0aCA9PT0gc3RhdGUubGFzdE5vdGlmaWVkV2lkdGggJiYgc3RhdGUubGFzdEhlaWdodCA9PT0gc3RhdGUubGFzdE5vdGlmaWVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcIk5vdCBub3RpZnlpbmc6IFNpemUgYWxyZWFkeSBub3RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ3VycmVudCBzaXplIG5vdCBub3RpZmllZCwgbm90aWZ5aW5nLi4uXCIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmxhc3ROb3RpZmllZFdpZHRoID0gc3RhdGUubGFzdFdpZHRoO1xuICAgICAgICAgICAgICAgIHN0YXRlLmxhc3ROb3RpZmllZEhlaWdodCA9IHN0YXRlLmxhc3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChnZXRTdGF0ZShlbGVtZW50KS5saXN0ZW5lcnMsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3RhcnRhbmltYXRpb24gdHJpZ2dlcmVkLlwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1VucmVuZGVyZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJJZ25vcmluZyBzaW5jZSBlbGVtZW50IGlzIHN0aWxsIHVucmVuZGVyZWQuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkVsZW1lbnQgcmVuZGVyZWQuXCIpO1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmQgPSBnZXRFeHBhbmRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBzaHJpbmsgPSBnZXRTaHJpbmtFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmQuc2Nyb2xsTGVmdCA9PT0gMCB8fCBleHBhbmQuc2Nyb2xsVG9wID09PSAwIHx8IHNocmluay5zY3JvbGxMZWZ0ID09PSAwIHx8IHNocmluay5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJTY3JvbGxiYXJzIG91dCBvZiBzeW5jLiBVcGRhdGluZyBkZXRlY3RvciBlbGVtZW50cy4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGV0ZWN0b3JFbGVtZW50cyhub3RpZnlMaXN0ZW5lcnNJZk5lZWRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJTY3JvbGwgZGV0ZWN0ZWQuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5yZW5kZXJlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGlzIHN0aWxsIHVucmVuZGVyZWQuIFNraXAgdGhpcyBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiU2Nyb2xsIGV2ZW50IGZpcmVkIHdoaWxlIHVucmVuZGVyZWQuIElnbm9yaW5nLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggIT09IGdldFN0YXRlKGVsZW1lbnQpLmxhc3RXaWR0aCB8fCBoZWlnaHQgIT09IGdldFN0YXRlKGVsZW1lbnQpLmxhc3RIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJFbGVtZW50IHNpemUgY2hhbmdlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURldGVjdG9yRWxlbWVudHMobm90aWZ5TGlzdGVuZXJzSWZOZWVkZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiRWxlbWVudCBzaXplIGhhcyBub3QgY2hhbmdlZCAoXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCIpLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlYnVnKFwicmVnaXN0ZXJMaXN0ZW5lcnNBbmRQb3NpdGlvbkVsZW1lbnRzIGludm9rZWQuXCIpO1xuXG4gICAgICAgICAgICBpZiAoIWdldFN0YXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgaGFzIGJlZW4gdW5pbnN0YWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vblJlbmRlcmVkID0gaGFuZGxlUmVuZGVyO1xuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25FeHBhbmQgPSBoYW5kbGVTY3JvbGw7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vblNocmluayA9IGhhbmRsZVNjcm9sbDtcblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0U3RhdGUoZWxlbWVudCkuc3R5bGU7XG4gICAgICAgICAgICB1cGRhdGVDaGlsZFNpemVzKGVsZW1lbnQsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVEb21NdXRhdGlvbigpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZmluYWxpemVEb21NdXRhdGlvbiBpbnZva2VkLlwiKTtcblxuICAgICAgICAgICAgaWYgKCFnZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0U3RhdGUoZWxlbWVudCkuc3R5bGU7XG4gICAgICAgICAgICBzdG9yZUN1cnJlbnRTaXplKGVsZW1lbnQsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgICAgICAgcG9zaXRpb25TY3JvbGxiYXJzKGVsZW1lbnQsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIkluc3RhbGxpbmcuLi5cIik7XG4gICAgICAgICAgICBpbml0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzdG9yZVN0YXJ0U2l6ZSgpO1xuXG4gICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMCwgc3RvcmVTdHlsZSk7XG4gICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMSwgaW5qZWN0U2Nyb2xsRWxlbWVudHMpO1xuICAgICAgICAgICAgYmF0Y2hQcm9jZXNzb3IuYWRkKDIsIHJlZ2lzdGVyTGlzdGVuZXJzQW5kUG9zaXRpb25FbGVtZW50cyk7XG4gICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMywgZmluYWxpemVEb21NdXRhdGlvbik7XG4gICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoNCwgcmVhZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoXCJNYWtpbmcgZGV0ZWN0YWJsZS4uLlwiKTtcblxuICAgICAgICBpZiAoaXNEZXRhY2hlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgZGVidWcoXCJFbGVtZW50IGlzIGRldGFjaGVkXCIpO1xuXG4gICAgICAgICAgICBpbmplY3RDb250YWluZXJFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIGRlYnVnKFwiV2FpdGluZyB1bnRpbCBlbGVtZW50IGlzIGF0dGFjaGVkLi4uXCIpO1xuXG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vblJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiRWxlbWVudCBpcyBub3cgYXR0YWNoZWRcIik7XG4gICAgICAgICAgICAgICAgaW5zdGFsbCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbGwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaW5zdGFsbChlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFVuaW5zdGFsbCBoYXMgYmVlbiBjYWxsZWQgb24gYSBub24tZXJkIGVsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmluc3RhbGwgbWF5IGhhdmUgYmVlbiBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyBzY2VuYXJpb3M6XG4gICAgICAgIC8vICgxKSBSaWdodCBiZXR3ZWVuIHRoZSBzeW5jIGNvZGUgYW5kIGFzeW5jIGJhdGNoIChoZXJlIHN0YXRlLmJ1c3kgPSB0cnVlLCBidXQgbm90aGluZyBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBvciBpbmplY3RlZCkuXG4gICAgICAgIC8vICgyKSBJbiB0aGUgcmVhZHkgY2FsbGJhY2sgb2YgdGhlIGxhc3QgbGV2ZWwgb2YgdGhlIGJhdGNoIGJ5IGFub3RoZXIgZWxlbWVudCAoaGVyZSwgc3RhdGUuYnVzeSA9IHRydWUsIGJ1dCBhbGwgdGhlIHN0dWZmIGhhcyBiZWVuIGluamVjdGVkKS5cbiAgICAgICAgLy8gKDMpIEFmdGVyIHRoZSBpbnN0YWxsYXRpb24gcHJvY2VzcyAoaGVyZSwgc3RhdGUuYnVzeSA9IGZhbHNlIGFuZCBhbGwgdGhlIHN0dWZmIGhhcyBiZWVuIGluamVjdGVkKS5cbiAgICAgICAgLy8gU28gdG8gYmUgb24gdGhlIHNhZmUgc2lkZSwgbGV0J3MgY2hlY2sgZm9yIGVhY2ggdGhpbmcgYmVmb3JlIHJlbW92aW5nLlxuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnMsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBldmVudCBtaWdodCBmaXJlIG9uIGFuIHVuaW5zdGFsbCBlbGVtZW50IHdoaWNoIHJlc3VsdHMgaW4gYW4gZXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSBzdGF0ZSBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgc3RhdGUub25FeHBhbmRTY3JvbGwgJiYgcmVtb3ZlRXZlbnQoZ2V0RXhwYW5kRWxlbWVudChlbGVtZW50KSwgXCJzY3JvbGxcIiwgc3RhdGUub25FeHBhbmRTY3JvbGwpO1xuICAgICAgICBzdGF0ZS5vblNocmlua1Njcm9sbCAmJiByZW1vdmVFdmVudChnZXRTaHJpbmtFbGVtZW50KGVsZW1lbnQpLCBcInNjcm9sbFwiLCBzdGF0ZS5vblNocmlua1Njcm9sbCk7XG4gICAgICAgIHN0YXRlLm9uQW5pbWF0aW9uU3RhcnQgJiYgcmVtb3ZlRXZlbnQoc3RhdGUuY29udGFpbmVyLCBcImFuaW1hdGlvbnN0YXJ0XCIsIHN0YXRlLm9uQW5pbWF0aW9uU3RhcnQpO1xuXG4gICAgICAgIHN0YXRlLmNvbnRhaW5lciAmJiBlbGVtZW50LnJlbW92ZUNoaWxkKHN0YXRlLmNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFrZURldGVjdGFibGU6IG1ha2VEZXRlY3RhYmxlLFxuICAgICAgICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gICAgICAgIHVuaW5zdGFsbDogdW5pbnN0YWxsXG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci9zcmMvZGV0ZWN0aW9uLXN0cmF0ZWd5L3Njcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"item\",\n    staticClass: \"vue-grid-layout\",\n    style: (_vm.mergedStyle)\n  }, [_vm._t(\"default\"), _vm._v(\" \"), _c('grid-item', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.isDragging),\n      expression: \"isDragging\"\n    }],\n    staticClass: \"vue-grid-placeholder\",\n    attrs: {\n      \"x\": _vm.placeholder.x,\n      \"y\": _vm.placeholder.y,\n      \"w\": _vm.placeholder.w,\n      \"h\": _vm.placeholder.h,\n      \"i\": _vm.placeholder.i\n    }\n  })], 2)\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JpZExheW91dC52dWU/NzM2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgcmVmOiBcIml0ZW1cIixcbiAgICBzdGF0aWNDbGFzczogXCJ2dWUtZ3JpZC1sYXlvdXRcIixcbiAgICBzdHlsZTogKF92bS5tZXJnZWRTdHlsZSlcbiAgfSwgW192bS5fdChcImRlZmF1bHRcIiksIF92bS5fdihcIiBcIiksIF9jKCdncmlkLWl0ZW0nLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgIHZhbHVlOiAoX3ZtLmlzRHJhZ2dpbmcpLFxuICAgICAgZXhwcmVzc2lvbjogXCJpc0RyYWdnaW5nXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJ2dWUtZ3JpZC1wbGFjZWhvbGRlclwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInhcIjogX3ZtLnBsYWNlaG9sZGVyLngsXG4gICAgICBcInlcIjogX3ZtLnBsYWNlaG9sZGVyLnksXG4gICAgICBcIndcIjogX3ZtLnBsYWNlaG9sZGVyLncsXG4gICAgICBcImhcIjogX3ZtLnBsYWNlaG9sZGVyLmgsXG4gICAgICBcImlcIjogX3ZtLnBsYWNlaG9sZGVyLmlcbiAgICB9XG4gIH0pXSwgMilcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNkNGJiOWE0XCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9HcmlkTGF5b3V0LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(41)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(43),\n  /* template */\n  __webpack_require__(44),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGVzdEVsZW1lbnQudnVlPzJlZDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQW1NOztBQUVuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9taW5pbWl6ZSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zZTJlMzQ0OFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vVGVzdEVsZW1lbnQudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL1Rlc3RFbGVtZW50LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2UyZTM0NDhcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vVGVzdEVsZW1lbnQudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9UZXN0RWxlbWVudC52dWVcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(42);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1)(\"4ff59386\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGVzdEVsZW1lbnQudnVlPzMzYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBb007QUFDcE07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bWluaW1pemUhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2UyZTM0NDhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL1Rlc3RFbGVtZW50LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNGZmNTkzODZcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP21pbmltaXplIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtM2UyZTM0NDhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvVGVzdEVsZW1lbnQudnVlXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)();\n// imports\n\n\n// module\nexports.push([module.i, \"\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGVzdEVsZW1lbnQudnVlP2ZlZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/bWluaW1pemUhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zZTJlMzQ0OFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3NyYy9UZXN0RWxlbWVudC52dWVcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n    name: \"TestElement\",\n    props: {\n        text: {\n            type: String,\n            default: \"x\"\n        }\n    },\n    data: function data() {\n        return {};\n    },\n    mounted: function mounted() {\n        console.log(\"### \" + this.text + \" ready!\");\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vVGVzdEVsZW1lbnQudnVlPzI5NzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBUUE7OztVQUVBOzs7a0JBR0E7cUJBR0E7QUFKQTtBQURBOzBCQU1BO2VBRUE7QUFDQTtnQ0FDQTt5Q0FDQTtBQUNBO0FBZEEiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8c3BhbiBjbGFzcz1cInRleHRcIj5cclxuICAgICAgICB7e3RleHR9fVxyXG4gICAgPC9zcGFuPlxyXG48L3RlbXBsYXRlPlxyXG48c3R5bGU+XHJcbjwvc3R5bGU+XHJcbjxzY3JpcHQ+XHJcbiAgICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICAgICAgbmFtZTogXCJUZXN0RWxlbWVudFwiLFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgIHRleHQgOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBcInhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3VudGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgXCIgKyB0aGlzLnRleHQgKyBcIiByZWFkeSFcIik7XHJcbiAgICAgICAgfSxcclxuICAgIH1cclxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIFRlc3RFbGVtZW50LnZ1ZT83NWY0MDgzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\\n    \" + _vm._s(_vm.text) + \"\\n\")])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGVzdEVsZW1lbnQudnVlPzZhNDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGV4dFwiXG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgXCIgKyBfdm0uX3MoX3ZtLnRleHQpICsgXCJcXG5cIildKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtM2UyZTM0NDhcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL1Rlc3RFbGVtZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(46)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(48),\n  /* template */\n  __webpack_require__(49),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ3VzdG9tRHJhZ0VsZW1lbnQudnVlPzYzMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0Esc0JBQW1NOztBQUVuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9taW5pbWl6ZSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xZmI0NGNjOVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ3VzdG9tRHJhZ0VsZW1lbnQudnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0N1c3RvbURyYWdFbGVtZW50LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWZiNDRjYzlcXFwifSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQ3VzdG9tRHJhZ0VsZW1lbnQudnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9DdXN0b21EcmFnRWxlbWVudC52dWVcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(47);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(1)(\"2ddfa052\", content, true);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ3VzdG9tRHJhZ0VsZW1lbnQudnVlPzQ3YzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxvQ0FBb007QUFDcE07QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/bWluaW1pemUhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWZiNDRjYzlcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0N1c3RvbURyYWdFbGVtZW50LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMmRkZmEwNTJcIiwgY29udGVudCwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP21pbmltaXplIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMWZiNDRjYzlcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvQ3VzdG9tRHJhZ0VsZW1lbnQudnVlXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(0)();\n// imports\n\n\n// module\nexports.push([module.i, \".vue-draggable-handle{position:absolute;width:20px;height:20px;top:0;left:0;background:url(\\\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><circle cx='5' cy='5' r='5' fill='#999999'/></svg>\\\") no-repeat;background-position:100% 100%;padding:0 8px 8px 0;background-repeat:no-repeat;background-origin:content-box;box-sizing:border-box;cursor:pointer}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ3VzdG9tRHJhZ0VsZW1lbnQudnVlPzc5ODUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwrQ0FBZ0Qsa0JBQWtCLFdBQVcsWUFBWSxNQUFNLE9BQU8sb0NBQW9DLG9JQUFvSSw4QkFBOEIsb0JBQW9CLDRCQUE0Qiw4QkFBOEIsc0JBQXNCLGVBQWU7O0FBRS9aIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7dG9wOjA7bGVmdDowO2JhY2tncm91bmQ6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzEwJyBoZWlnaHQ9JzEwJz48Y2lyY2xlIGN4PSc1JyBjeT0nNScgcj0nNScgZmlsbD0nIzk5OTk5OScvPjwvc3ZnPlxcXCIpIG5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjEwMCUgMTAwJTtwYWRkaW5nOjAgOHB4IDhweCAwO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y3Vyc29yOnBvaW50ZXJ9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9taW5pbWl6ZSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTFmYjQ0Y2M5XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL0N1c3RvbURyYWdFbGVtZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n    name: \"CustomDragElement\",\n    props: {\n        text: {\n            type: String,\n            default: \"x\"\n        }\n    },\n    data: function data() {\n        return {};\n    },\n    mounted: function mounted() {\n        console.log(\"### \" + this.text + \" ready!\");\n    }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQ3VzdG9tRHJhZ0VsZW1lbnQudnVlPzY3OWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7O1VBRUE7OztrQkFHQTtxQkFHQTtBQUpBO0FBREE7MEJBTUE7ZUFFQTtBQUNBO2dDQUNBO3lDQUNBO0FBQ0E7QUFkQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cclxuICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxyXG4gICAgICAgIHt7dGV4dH19XHJcbiAgICA8YnV0dG9uPnh4eDwvYnV0dG9uPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJ2dWUtZHJhZ2dhYmxlLWhhbmRsZVwiPjwvc3Bhbj5cclxuICAgIDwvc3Bhbj5cclxuPC90ZW1wbGF0ZT5cclxuPHN0eWxlPlxyXG4gICAgLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlIHtcclxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgICAgd2lkdGg6IDIwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xyXG4gICAgICAgIHRvcDogMDtcclxuICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgIGJhY2tncm91bmQ6IHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnPjxjaXJjbGUgY3g9JzUnIGN5PSc1JyByPSc1JyBmaWxsPScjOTk5OTk5Jy8+PC9zdmc+XCIpIG5vLXJlcGVhdDtcclxuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gcmlnaHQ7XHJcbiAgICAgICAgcGFkZGluZzogMCA4cHggOHB4IDA7XHJcbiAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcclxuICAgICAgICBiYWNrZ3JvdW5kLW9yaWdpbjogY29udGVudC1ib3g7XHJcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcbjxzY3JpcHQ+XHJcbiAgICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICAgICAgbmFtZTogXCJDdXN0b21EcmFnRWxlbWVudFwiLFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgIHRleHQgOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBcInhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3VudGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgXCIgKyB0aGlzLnRleHQgKyBcIiByZWFkeSFcIik7XHJcbiAgICAgICAgfSxcclxuICAgIH1cclxuPC9zY3JpcHQ+XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIEN1c3RvbURyYWdFbGVtZW50LnZ1ZT8wN2IzZTI3ZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\\n    \" + _vm._s(_vm.text) + \"\\n\"), _c('button', [_vm._v(\"xxx\")]), _vm._v(\" \"), _c('span', {\n    staticClass: \"vue-draggable-handle\"\n  })])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ3VzdG9tRHJhZ0VsZW1lbnQudnVlP2U3ODQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGV4dFwiXG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgXCIgKyBfdm0uX3MoX3ZtLnRleHQpICsgXCJcXG5cIiksIF9jKCdidXR0b24nLCBbX3ZtLl92KFwieHh4XCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCJcbiAgfSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMWZiNDRjYzlcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL0N1c3RvbURyYWdFbGVtZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('h1', [_vm._v(\"Vue Grid Layout\")]), _vm._v(\" \"), _c('div', [_c('div', {\n    staticClass: \"layoutJSON\"\n  }, [_vm._v(\"\\n            Displayed as \"), _c('code', [_vm._v(\"[x, y, w, h]\")]), _vm._v(\":\\n            \"), _c('div', {\n    staticClass: \"columns\"\n  }, _vm._l((_vm.layout), function(item) {\n    return _c('div', {\n      staticClass: \"layoutItem\"\n    }, [_c('b', [_vm._v(_vm._s(item.i))]), _vm._v(\": [\" + _vm._s(item.x) + \", \" + _vm._s(item.y) + \", \" + _vm._s(item.w) + \", \" + _vm._s(item.h) + \"]\\n                \")])\n  }))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"layoutJSON\"\n  }, [_vm._v(\"\\n            Displayed as \"), _c('code', [_vm._v(\"[x, y, w, h]\")]), _vm._v(\":\\n            \"), _c('div', {\n    staticClass: \"columns\"\n  }, _vm._l((_vm.layout2), function(item) {\n    return _c('div', {\n      staticClass: \"layoutItem\"\n    }, [_c('b', [_vm._v(_vm._s(item.i))]), _vm._v(\": [\" + _vm._s(item.x) + \", \" + _vm._s(item.y) + \", \" + _vm._s(item.w) + \", \" + _vm._s(item.h) + \"]\\n                \")])\n  }))])]), _vm._v(\" \"), _c('div', {\n    attrs: {\n      \"id\": \"content\"\n    }\n  }, [_c('button', {\n    on: {\n      \"click\": _vm.decreaseWidth\n    }\n  }, [_vm._v(\"Decrease Width\")]), _vm._v(\" \"), _c('button', {\n    on: {\n      \"click\": _vm.increaseWidth\n    }\n  }, [_vm._v(\"Increase Width\")]), _vm._v(\" \"), _c('button', {\n    on: {\n      \"click\": _vm.addItem\n    }\n  }, [_vm._v(\"Add an item\")]), _vm._v(\" \"), _c('button', {\n    on: {\n      \"click\": _vm.changeDirection\n    }\n  }, [_vm._v(\"Change Direction\")]), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.draggable),\n      expression: \"draggable\"\n    }],\n    attrs: {\n      \"type\": \"checkbox\"\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.draggable) ? _vm._i(_vm.draggable, null) > -1 : (_vm.draggable)\n    },\n    on: {\n      \"change\": function($event) {\n        var $$a = _vm.draggable,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$el.checked) {\n            $$i < 0 && (_vm.draggable = $$a.concat([$$v]))\n          } else {\n            $$i > -1 && (_vm.draggable = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.draggable = $$c\n        }\n      }\n    }\n  }), _vm._v(\" Draggable\\n        \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.resizable),\n      expression: \"resizable\"\n    }],\n    attrs: {\n      \"type\": \"checkbox\"\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.resizable) ? _vm._i(_vm.resizable, null) > -1 : (_vm.resizable)\n    },\n    on: {\n      \"change\": function($event) {\n        var $$a = _vm.resizable,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$el.checked) {\n            $$i < 0 && (_vm.resizable = $$a.concat([$$v]))\n          } else {\n            $$i > -1 && (_vm.resizable = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.resizable = $$c\n        }\n      }\n    }\n  }), _vm._v(\" Resizable\\n        \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.mirrored),\n      expression: \"mirrored\"\n    }],\n    attrs: {\n      \"type\": \"checkbox\"\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.mirrored) ? _vm._i(_vm.mirrored, null) > -1 : (_vm.mirrored)\n    },\n    on: {\n      \"change\": function($event) {\n        var $$a = _vm.mirrored,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$el.checked) {\n            $$i < 0 && (_vm.mirrored = $$a.concat([$$v]))\n          } else {\n            $$i > -1 && (_vm.mirrored = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.mirrored = $$c\n        }\n      }\n    }\n  }), _vm._v(\" Mirrored\\n        \"), _c('br'), _vm._v(\"\\n        Row Height: \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.rowHeight),\n      expression: \"rowHeight\"\n    }],\n    attrs: {\n      \"type\": \"number\"\n    },\n    domProps: {\n      \"value\": (_vm.rowHeight)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.rowHeight = $event.target.value\n      }\n    }\n  }), _vm._v(\" \"), _c('br'), _vm._v(\" \"), _c('grid-layout', {\n    attrs: {\n      \"layout\": _vm.layout,\n      \"col-num\": 12,\n      \"row-height\": _vm.rowHeight,\n      \"is-draggable\": _vm.draggable,\n      \"is-resizable\": _vm.resizable,\n      \"is-mirrored\": _vm.mirrored,\n      \"vertical-compact\": true,\n      \"use-css-transforms\": true\n    }\n  }, _vm._l((_vm.layout), function(item) {\n    return _c('grid-item', {\n      key: item.i,\n      attrs: {\n        \"x\": item.x,\n        \"y\": item.y,\n        \"w\": item.w,\n        \"h\": item.h,\n        \"min-w\": 2,\n        \"min-h\": 2,\n        \"i\": item.i\n      },\n      on: {\n        \"resize\": _vm.resize,\n        \"move\": _vm.move,\n        \"resized\": _vm.resized,\n        \"moved\": _vm.moved\n      }\n    }, [_c('test-element', {\n      attrs: {\n        \"text\": item.i\n      }\n    })], 1)\n  })), _vm._v(\" \"), _c('hr')], 1)])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9kNWEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImFwcFwiXG4gICAgfVxuICB9LCBbX2MoJ2gxJywgW192bS5fdihcIlZ1ZSBHcmlkIExheW91dFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2JywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGF5b3V0SlNPTlwiXG4gIH0sIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICBEaXNwbGF5ZWQgYXMgXCIpLCBfYygnY29kZScsIFtfdm0uX3YoXCJbeCwgeSwgdywgaF1cIildKSwgX3ZtLl92KFwiOlxcbiAgICAgICAgICAgIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb2x1bW5zXCJcbiAgfSwgX3ZtLl9sKChfdm0ubGF5b3V0KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibGF5b3V0SXRlbVwiXG4gICAgfSwgW19jKCdiJywgW192bS5fdihfdm0uX3MoaXRlbS5pKSldKSwgX3ZtLl92KFwiOiBbXCIgKyBfdm0uX3MoaXRlbS54KSArIFwiLCBcIiArIF92bS5fcyhpdGVtLnkpICsgXCIsIFwiICsgX3ZtLl9zKGl0ZW0udykgKyBcIiwgXCIgKyBfdm0uX3MoaXRlbS5oKSArIFwiXVxcbiAgICAgICAgICAgICAgICBcIildKVxuICB9KSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYXlvdXRKU09OXCJcbiAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgIERpc3BsYXllZCBhcyBcIiksIF9jKCdjb2RlJywgW192bS5fdihcIlt4LCB5LCB3LCBoXVwiKV0pLCBfdm0uX3YoXCI6XFxuICAgICAgICAgICAgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbHVtbnNcIlxuICB9LCBfdm0uX2woKF92bS5sYXlvdXQyKSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibGF5b3V0SXRlbVwiXG4gICAgfSwgW19jKCdiJywgW192bS5fdihfdm0uX3MoaXRlbS5pKSldKSwgX3ZtLl92KFwiOiBbXCIgKyBfdm0uX3MoaXRlbS54KSArIFwiLCBcIiArIF92bS5fcyhpdGVtLnkpICsgXCIsIFwiICsgX3ZtLl9zKGl0ZW0udykgKyBcIiwgXCIgKyBfdm0uX3MoaXRlbS5oKSArIFwiXVxcbiAgICAgICAgICAgICAgICBcIildKVxuICB9KSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiY29udGVudFwiXG4gICAgfVxuICB9LCBbX2MoJ2J1dHRvbicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uZGVjcmVhc2VXaWR0aFxuICAgIH1cbiAgfSwgW192bS5fdihcIkRlY3JlYXNlIFdpZHRoXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdidXR0b24nLCB7XG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmluY3JlYXNlV2lkdGhcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJJbmNyZWFzZSBXaWR0aFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYnV0dG9uJywge1xuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5hZGRJdGVtXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiQWRkIGFuIGl0ZW1cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2J1dHRvbicsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uY2hhbmdlRGlyZWN0aW9uXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiQ2hhbmdlIERpcmVjdGlvblwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0uZHJhZ2dhYmxlKSxcbiAgICAgIGV4cHJlc3Npb246IFwiZHJhZ2dhYmxlXCJcbiAgICB9XSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwiY2hlY2tib3hcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiY2hlY2tlZFwiOiBBcnJheS5pc0FycmF5KF92bS5kcmFnZ2FibGUpID8gX3ZtLl9pKF92bS5kcmFnZ2FibGUsIG51bGwpID4gLTEgOiAoX3ZtLmRyYWdnYWJsZSlcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNoYW5nZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgdmFyICQkYSA9IF92bS5kcmFnZ2FibGUsXG4gICAgICAgICAgJCRlbCA9ICRldmVudC50YXJnZXQsXG4gICAgICAgICAgJCRjID0gJCRlbC5jaGVja2VkID8gKHRydWUpIDogKGZhbHNlKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoJCRhKSkge1xuICAgICAgICAgIHZhciAkJHYgPSBudWxsLFxuICAgICAgICAgICAgJCRpID0gX3ZtLl9pKCQkYSwgJCR2KTtcbiAgICAgICAgICBpZiAoJCRlbC5jaGVja2VkKSB7XG4gICAgICAgICAgICAkJGkgPCAwICYmIChfdm0uZHJhZ2dhYmxlID0gJCRhLmNvbmNhdChbJCR2XSkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkaSA+IC0xICYmIChfdm0uZHJhZ2dhYmxlID0gJCRhLnNsaWNlKDAsICQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkgKyAxKSkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF92bS5kcmFnZ2FibGUgPSAkJGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBEcmFnZ2FibGVcXG4gICAgICAgIFwiKSwgX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnJlc2l6YWJsZSksXG4gICAgICBleHByZXNzaW9uOiBcInJlc2l6YWJsZVwiXG4gICAgfV0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcImNoZWNrYm94XCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcImNoZWNrZWRcIjogQXJyYXkuaXNBcnJheShfdm0ucmVzaXphYmxlKSA/IF92bS5faShfdm0ucmVzaXphYmxlLCBudWxsKSA+IC0xIDogKF92bS5yZXNpemFibGUpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjaGFuZ2VcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIHZhciAkJGEgPSBfdm0ucmVzaXphYmxlLFxuICAgICAgICAgICQkZWwgPSAkZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICQkYyA9ICQkZWwuY2hlY2tlZCA/ICh0cnVlKSA6IChmYWxzZSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KCQkYSkpIHtcbiAgICAgICAgICB2YXIgJCR2ID0gbnVsbCxcbiAgICAgICAgICAgICQkaSA9IF92bS5faSgkJGEsICQkdik7XG4gICAgICAgICAgaWYgKCQkZWwuY2hlY2tlZCkge1xuICAgICAgICAgICAgJCRpIDwgMCAmJiAoX3ZtLnJlc2l6YWJsZSA9ICQkYS5jb25jYXQoWyQkdl0pKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkJGkgPiAtMSAmJiAoX3ZtLnJlc2l6YWJsZSA9ICQkYS5zbGljZSgwLCAkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpICsgMSkpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdm0ucmVzaXphYmxlID0gJCRjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgUmVzaXphYmxlXFxuICAgICAgICBcIiksIF9jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5taXJyb3JlZCksXG4gICAgICBleHByZXNzaW9uOiBcIm1pcnJvcmVkXCJcbiAgICB9XSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwiY2hlY2tib3hcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiY2hlY2tlZFwiOiBBcnJheS5pc0FycmF5KF92bS5taXJyb3JlZCkgPyBfdm0uX2koX3ZtLm1pcnJvcmVkLCBudWxsKSA+IC0xIDogKF92bS5taXJyb3JlZClcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNoYW5nZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgdmFyICQkYSA9IF92bS5taXJyb3JlZCxcbiAgICAgICAgICAkJGVsID0gJGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAkJGMgPSAkJGVsLmNoZWNrZWQgPyAodHJ1ZSkgOiAoZmFsc2UpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSgkJGEpKSB7XG4gICAgICAgICAgdmFyICQkdiA9IG51bGwsXG4gICAgICAgICAgICAkJGkgPSBfdm0uX2koJCRhLCAkJHYpO1xuICAgICAgICAgIGlmICgkJGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICQkaSA8IDAgJiYgKF92bS5taXJyb3JlZCA9ICQkYS5jb25jYXQoWyQkdl0pKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkJGkgPiAtMSAmJiAoX3ZtLm1pcnJvcmVkID0gJCRhLnNsaWNlKDAsICQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkgKyAxKSkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF92bS5taXJyb3JlZCA9ICQkY1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIE1pcnJvcmVkXFxuICAgICAgICBcIiksIF9jKCdicicpLCBfdm0uX3YoXCJcXG4gICAgICAgIFJvdyBIZWlnaHQ6IFwiKSwgX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnJvd0hlaWdodCksXG4gICAgICBleHByZXNzaW9uOiBcInJvd0hlaWdodFwiXG4gICAgfV0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnJvd0hlaWdodClcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS5yb3dIZWlnaHQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2JyJyksIF92bS5fdihcIiBcIiksIF9jKCdncmlkLWxheW91dCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJsYXlvdXRcIjogX3ZtLmxheW91dCxcbiAgICAgIFwiY29sLW51bVwiOiAxMixcbiAgICAgIFwicm93LWhlaWdodFwiOiBfdm0ucm93SGVpZ2h0LFxuICAgICAgXCJpcy1kcmFnZ2FibGVcIjogX3ZtLmRyYWdnYWJsZSxcbiAgICAgIFwiaXMtcmVzaXphYmxlXCI6IF92bS5yZXNpemFibGUsXG4gICAgICBcImlzLW1pcnJvcmVkXCI6IF92bS5taXJyb3JlZCxcbiAgICAgIFwidmVydGljYWwtY29tcGFjdFwiOiB0cnVlLFxuICAgICAgXCJ1c2UtY3NzLXRyYW5zZm9ybXNcIjogdHJ1ZVxuICAgIH1cbiAgfSwgX3ZtLl9sKChfdm0ubGF5b3V0KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBfYygnZ3JpZC1pdGVtJywge1xuICAgICAga2V5OiBpdGVtLmksXG4gICAgICBhdHRyczoge1xuICAgICAgICBcInhcIjogaXRlbS54LFxuICAgICAgICBcInlcIjogaXRlbS55LFxuICAgICAgICBcIndcIjogaXRlbS53LFxuICAgICAgICBcImhcIjogaXRlbS5oLFxuICAgICAgICBcIm1pbi13XCI6IDIsXG4gICAgICAgIFwibWluLWhcIjogMixcbiAgICAgICAgXCJpXCI6IGl0ZW0uaVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwicmVzaXplXCI6IF92bS5yZXNpemUsXG4gICAgICAgIFwibW92ZVwiOiBfdm0ubW92ZSxcbiAgICAgICAgXCJyZXNpemVkXCI6IF92bS5yZXNpemVkLFxuICAgICAgICBcIm1vdmVkXCI6IF92bS5tb3ZlZFxuICAgICAgfVxuICAgIH0sIFtfYygndGVzdC1lbGVtZW50Jywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJ0ZXh0XCI6IGl0ZW0uaVxuICAgICAgfVxuICAgIH0pXSwgMSlcbiAgfSkpLCBfdm0uX3YoXCIgXCIpLCBfYygnaHInKV0sIDEpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTZiNTBjYzczXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50\n");

/***/ })
/******/ ]);